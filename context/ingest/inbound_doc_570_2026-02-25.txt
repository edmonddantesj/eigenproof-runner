How to Build an AI Trading System From Scratch: A Technical Deep Dive




dYdZ


@jjjjeerryyyy

Â·
6ì‹œê°„
Most people hear "AI trading" and imagine a chatbot picking stocks. That's not what this is.
What I've built is a pipeline â€” a structured system where information flows through multiple stages, each with a specific job, until it becomes an executable trading strategy running 24/7.
The core logic is simple:
Data â†’ Ideas â†’ AI Structuring â†’ Strategy Script â†’ Backtest â†’ Paper Trade â†’ Live Execution
But the devil is in every step. Let me walk you through each one.
The Full Pipeline: 7 Stages Let's break down each stage.
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 1    â”‚  Data Sources & Signal Collection
â”‚  INPUT      â”‚  (What's happening in the world?)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 2    â”‚  Information Synthesis & Idea Generation
â”‚  PROCESS    â”‚  (What does this mean? What's the trade?)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 3    â”‚  AI Strategy Structuring
â”‚  TRANSLATE  â”‚  (Turn the idea into formal logic)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 4    â”‚  Code Generation â€” Strategy Tree Script
â”‚  BUILD      â”‚  (Make it executable)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 5    â”‚  Backtesting
â”‚  VALIDATE   â”‚  (Does this actually work on historical data?)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 6    â”‚  Paper Trading (Simulation)
â”‚  TEST       â”‚  (Does it work in real-time conditions?)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stage 7    â”‚  Live Execution
â”‚  DEPLOY     â”‚  (Real money, real stakes)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚FEEDBACKâ”‚ â†’ Performance data feeds back to Stage 1-3
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Stage 1: Data Sources & Signal Collection
Goal: Continuously ingest every piece of information that could affect your trading decisions.
This is the foundation. Garbage in, garbage out. The quality and breadth of your data determines the ceiling of everything downstream.
What to collect:
Market Data (Price & Volume)
â€¢ Real-time OHLCV across timeframes (1m, 5m, 1h, 4h, 1D)
â€¢ Order book depth and bid-ask spread
â€¢ Funding rates (for perpetual futures)
â€¢ Open interest changes
ğŸ”§ Tools: CCXT (unified API for 100+ exchanges), Binance API, Coinbase Advanced API, Alpaca (for US equities), Interactive Brokers API, etc.
â€¨
On-Chain Data (Crypto-specific)
â€¢ Exchange net inflow/outflow (large flows = potential selling/buying pressure)
â€¢ Whale wallet tracking (wallets holding >1000 BTC)
â€¢ Stablecoin mint/burn rates (USDT/USDC supply changes = liquidity proxy)
â€¢ DeFi TVL changes, DEX volume trends
â€¢ Gas fees and network activity
ğŸ”§ Tools: Glassnode API, Dune Analytics, Nansen, Arkham Intelligence, DefiLlama API, Etherscan/Solscan APIs
â€¨
Macro Data
â€¢ Economic calendar events (CPI, PPI, NFP, FOMC decisions)
â€¢ Actual vs. consensus estimates (the surprise factor is what moves markets)
â€¢ Central bank balance sheet data
â€¢ Dollar index (DXY), US 10Y yield, VIX
ğŸ”§ Tools: FRED API (Federal Reserve), Trading Economics API, 
Investing.com
calendar scraper, Alpha Vantage
â€¨
Sentiment Data
â€¢ Fear & Greed Index
â€¢ Options Put/Call ratio
â€¢ Social media keyword frequency and anomaly detection (X, Reddit, Telegram)
â€¢ News headline sentiment scoring
ğŸ”§ Tools: 
Alternative.me
API (Fear & Greed), LunarCrush, Santiment, GDELT (news), snscrape + custom NLP pipeline, NewsAPI
â€¨
Cross-Market Signals
â€¢ Correlation tracking: BTC vs NASDAQ, BTC vs DXY, BTC vs Gold
â€¢ JPY carry trade indicators (USD/JPY + rate differentials)
â€¢ ETF flow data (GBTC, IBIT, etc.)
ğŸ”§ Tools: Yahoo Finance API, 
ETF.com
data, custom correlation scripts
Architecture:
python
# Example: Multi-source data aggregator
class DataCollector:
    def __init__(self):
        # Define source feeds for multiple data domains
        self.sources = {
            'price': CCXTFeed(exchanges=['binance', 'coinbase']),
            'onchain': GlassnodeFeed(metrics=['exchange_netflow', 'whale_count']),
            'macro': FREDFeed(series=['DGS10', 'DTWEXBGS']),
            'sentiment': SentimentFeed(sources=['fear_greed', 'social']),
        }

    async def collect(self):
        """Collect from all sources, normalize, store"""
        signals = {}

        # Fetch signals asynchronously from each source
        for name, source in self.sources.items():
            signals[name] = await source.fetch()

        # Store in time-series DB
        await self.store(signals)

        # Check for anomalies
        alerts = self.detect_anomalies(signals)
        if alerts:
            await self.notify(alerts)
ğŸ”§ Storage: TimescaleDB (time-series optimized PostgreSQL), InfluxDB, QuestDB, or simply SQLite for small-scale
ğŸ”§ Orchestration: cron jobs, Celery, APScheduler, or an AI Agent framework like OpenClaw (with built-in CRON scheduling)
â€¨
Stage 2: Information Synthesis & Idea Generation
Goal: Turn raw data into actionable trading hypotheses.
This is where AI acts as your research analyst. It reads all the data you're collecting and surfaces patterns, anomalies, and potential trade setups.
How it works: You feed the AI a structured prompt with current market context:
## Current Market State (auto-generated)
- BTC: $67,420 (+2.3% 24h), RSI(1D): 42, RSI(4h): 58
- Exchange netflow: -4,200 BTC (24h) â€” net outflow
- Fear & Greed: 31 (Fear)
- DXY: 104.2 (â†“0.5% this week)
- US10Y: 4.38% (â†“3bp)
- Next macro event: FOMC minutes in 18 hours
- Social anomaly: "accumulation" keyword frequency +340% on CT

## Your Investment Thesis (you write this once, update monthly)
I believe we're in a mid-cycle consolidation. Liquidity is slowly expanding.
I'm looking for high-conviction entries on BTC and SOL during fear-driven dips.
My risk tolerance: max 5% portfolio per trade, max 15% total exposure.

## Task
Based on the above, generate 1-3 potential trade ideas with:
- Entry thesis (why now?)
- Key signals supporting the trade
- Key risks / what would invalidate the thesis
- Suggested entry zone, stop loss, take profit levels
The AI outputs structured trade ideas â€” not predictions, but hypotheses with explicit logic.
You then decide which ones to pursue.
ğŸ”§ Tools: Claude API / GPT-4 API / DeepSeek with structured output, LangChain or OpenClaw Skills for templated prompting
â€¨
Stage 3: AI Strategy Structuring
Goal: Convert your selected trade idea from natural language into formal, unambiguous logic.
This is the critical translation layer. Most traders skip this â€” they go from "I think BTC is going up" straight to clicking the buy button. That's where emotions creep in.
Input (your words):
"I want to long BTC if RSI drops below 30 on the daily, exchange outflow stays above 3000 BTC for 2 consecutive days, and Fear & Greed is below 25. Scale in 3 batches. Stop at 8% below average entry. Take profit in 2 stages: half at +15%, rest at +30%."
Output (structured strategy tree):
strategy:
  name: "BTC_fear_accumulation_v1"
  asset: BTC/USDT
  timeframe: 1D
  
  entry:
    conditions:
      - RSI(BTC, 1D) < 30
      - exchange_netflow(BTC, 48h) < -3000  # 2-day cumulative
      - fear_greed_index < 25
    logic: ALL  # all conditions must be true simultaneously
    
  position:
    type: scaled_entry
    batches: 3
    size_per_batch: 3.3%  # of total portfolio
    interval: 4h  # between batches
    max_total_exposure: 10%
    
  risk:
    stop_loss:
      type: percentage
      value: 8%
      reference: average_entry_price
    
  take_profit:
    - level: 15%
      action: close_50%
    - level: 30%
      action: close_remaining
      
  filters:
    - no_entry_within: 24h_of_FOMC
    - no_entry_if: BTC_dominance < 40%
    
  expiry: 30d  # strategy expires if not triggered in 30 days
Notice what happened: a fuzzy idea became precise, testable, executable rules.
Every parameter is explicit. No ambiguity. No room for "I'll decide in the moment."
ğŸ”§ Tools: Claude / GPT-4 with structured output (JSON/YAML mode), custom prompt templates, Pydantic for schema validation
â€¨
Stage 4: Code Generation â€” Executable Strategy Script
Goal: Turn the strategy tree into actual runnable code.
This is where AI becomes a coding assistant. It takes the YAML/JSON strategy definition and generates a production-ready script.
What gets generated:
python
# Auto-generated by AI Strategy Builder
# Strategy: BTC_fear_accumulation_v1
# Generated: 2026-02-24
# âš ï¸ Review all logic before deployment

import ccxt
from indicators import RSI
from data_feeds import get_exchange_netflow, get_fear_greed

class BTCFearAccumulation:
    def __init__(self, exchange, config):
        self.exchange = exchange
        self.asset = 'BTC/USDT'
        self.batches_entered = 0
        self.max_batches = 3
        self.batch_size = config['portfolio_value'] * 0.033
        self.entries = []
        
    def check_entry_signal(self, market_data):
        """Check if all entry conditions are met"""
        rsi = RSI(market_data['btc_daily'], period=14)
        netflow = get_exchange_netflow('BTC', hours=48)
        fg_index = get_fear_greed()
        
        conditions = {
            'rsi_oversold': rsi < 30,
            'sustained_outflow': netflow < -3000,
            'extreme_fear': fg_index < 25,
            'not_near_fomc': not self.is_within_fomc_window(24),
            'btc_dominance_ok': market_data['btc_dominance'] > 40,
        }
        
        # Log which conditions are met
        for name, met in conditions.items():
            logger.info(f"  {name}: {'âœ…' if met else 'âŒ'}")
        
        return all(conditions.values())
    
    def check_stop_loss(self):
        """Hard stop at 8% below average entry"""
        if not self.entries:
            return False
        avg_entry = sum(e['price'] for e in self.entries) / len(self.entries)
        current = self.get_current_price()
        drawdown = (current - avg_entry) / avg_entry
        return drawdown <= -0.08
    
    def check_take_profit(self):
        """Staged exit: 50% at +15%, remaining at +30%"""
        if not self.entries:
            return None
        avg_entry = sum(e['price'] for e in self.entries) / len(self.entries)
        current = self.get_current_price()
        gain = (current - avg_entry) / avg_entry
        
        if gain >= 0.30:
            return 'close_all'
        elif gain >= 0.15 and not self.first_tp_hit:
            return 'close_half'
        return None
    
    def execute(self):
        """Main loop â€” called every candle close"""
        # Check exits first (always)
        if self.check_stop_loss():
            self.close_position('stop_loss')
            return
            
        tp_action = self.check_take_profit()
        if tp_action:
            self.execute_take_profit(tp_action)
            return
        
        # Check new entries
        if self.batches_entered < self.max_batches:
            if self.check_entry_signal(self.get_market_data()):
                self.enter_batch()
Key principle: the AI generates the code, but you review every line before it runs.
The strategy tree from Stage 3 serves as the specification. The code should be a 1:1 implementation. If they don't match, something is wrong.
ğŸ”§ Code generation: Claude / Cursor / GitHub Copilot
ğŸ”§ Languages: Python (most common), JavaScript/TypeScript, Pine Script (TradingView)
ğŸ”§ Frameworks: CCXT (exchange connectivity), backtrader, vectorbt, Freqtrade
â€¨
Stage 5: Backtesting
Goal: Test your strategy against historical data to see if it would have worked.
This is your reality check. Before risking real money, you run the strategy against years of past data.
What to measure:
| Metric        | What It Tells You                 | Red Flag                       |
| ------------- | --------------------------------- | ------------------------------ |
| Win Rate      | % of profitable trades            | <30% (unless R:R is very high) |
| Profit Factor | Gross profit / gross loss         | <1.5                           |
| Max Drawdown  | Largest peak-to-trough decline    | >25% for most retail           |
| Sharpe Ratio  | Risk-adjusted return              | <1.0                           |
| Avg R:R       | Average reward vs risk per trade  | <1.5                           |
| Trade Count   | Statistical significance          | <30 trades = not reliable      |
| Recovery Time | Time to recover from max drawdown | >3 months = concerning         |
Backtesting pitfalls to watch for:
âš ï¸ Overfitting â€” Strategy works perfectly on historical data but fails live. Fix: use walk-forward optimization, test on out-of-sample data.
âš ï¸ Survivorship bias â€” Only testing on assets that still exist. The ones that went to zero aren't in your dataset.
âš ï¸ Look-ahead bias â€” Accidentally using future data in your logic (e.g., using close price for decisions made at open).
âš ï¸ Slippage & fees ignored â€” A strategy that makes 0.1% per trade looks great until you account for 0.05% fees + 0.05% slippage. Now it's break-even.
python
# Backtest execution example
from backtester import Backtester

bt = Backtester(
    strategy=BTCFearAccumulation,
    data='BTC_USDT_1D_2022_2025.csv',
    initial_capital=100000,
    commission=0.0004,      # 0.04% per trade (Binance VIP)
    slippage=0.0005,        # 0.05% estimated slippage
)

results = bt.run()

print(f"Total Return: {results.total_return:.1%}")
print(f"Max Drawdown: {results.max_drawdown:.1%}")
print(f"Sharpe Ratio: {results.sharpe:.2f}")
print(f"Win Rate: {results.win_rate:.1%}")
print(f"Profit Factor: {results.profit_factor:.2f}")
print(f"Total Trades: {results.trade_count}")

# Walk-forward validation
wf_results = bt.walk_forward(
    in_sample_months=12,
    out_of_sample_months=3,
    rolling=True
)
ğŸ”§ Tools: backtrader (Python, most flexible), vectorbt (fast, vectorized), Freqtrade (built-in backtesting for crypto), Jesse, QuantConnect (cloud-based), TradingView (Pine Script, visual)
â€¨
Stage 6: Paper Trading (Simulation)
Goal: Test the strategy in real-time market conditions, but without real money.
Backtesting uses historical data. Paper trading runs your exact code against a live data feed, executing simulated trades at real prices.
Why this step matters:
â€¢ Latency: Backtesting is instant. Live markets have API delays, order book changes, partial fills.
â€¢ Market impact: Your backtest assumes infinite liquidity. Reality doesn't.
â€¢ Data feed reliability: APIs drop connections. Price feeds lag. Your code needs to handle this.
â€¢ Edge cases: What happens during a flash crash? During exchange maintenance? When your API rate limit is hit?
How long to paper trade:
| Strategy Timeframe | Minimum Paper Trading Period |
| ------------------ | ---------------------------- |
| Scalping (1m-15m)  | 2-4 weeks                    |
| Intraday (1h-4h)   | 1-2 months                   |
| Swing (1D)         | 2-3 months                   |
| Position (1W)      | 3-6 months                   |
You need enough trades to be statistically meaningful. If your strategy triggers once a month, you need at least 6 months of paper trading to get useful data.
ğŸ”§ Tools: Binance Testnet, Bybit Testnet, Alpaca Paper Trading (US equities), Freqtrade dry-run mode, Interactive Brokers Paper Account
â€¨
Stage 7: Live Execution
Goal: Deploy with real capital. Start small.
Deployment rules:
1. Start with 10% of intended capital. If the strategy is meant for $100K, start with $10K. Scale up only after 1 month of consistent live results matching backtest expectations.
2. Monitor actively for the first 2 weeks. After that, daily 15-minute report review is sufficient.
3. Set hard circuit breakers:
python
CIRCUIT_BREAKERS = {
    'max_daily_loss': -0.03,        # Stop all trading if down 3% in a day
    'max_weekly_loss': -0.07,       # Stop all trading if down 7% in a week  
    'max_drawdown': -0.15,          # Kill switch at 15% total drawdown
    'max_consecutive_losses': 5,     # Pause after 5 losses in a row
    'max_position_size': 0.10,      # Never risk more than 10% on one trade
}
4. Log everything. Every signal, every decision, every execution. You'll need this for Stage 2 of the feedback loop.
Infrastructure for live trading:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   VPS/Cloud  â”‚â”€â”€â”€â”€â–¶ï¸â”‚  Trading Bot â”‚â”€â”€â”€â”€â–¶ï¸â”‚   Exchange   â”‚
â”‚  (Always On) â”‚     â”‚  (Your Code) â”‚     â”‚   (Binance)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                     â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚   Monitoring â”‚
                     â”‚  Dashboard   â”‚
                     â”‚  + Alerts    â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ğŸ”§ Hosting: AWS EC2 / Google Cloud / Hetzner (cheap, reliable) / Railway / your own server
ğŸ”§ Monitoring: Grafana + Prometheus, custom Telegram bot alerts, PagerDuty for critical failures
ğŸ”§ Exchange APIs: CCXT (unified), direct exchange SDKs for lower latency
The Feedback Loop: Why This System Gets Better Over Time
After each week of live trading, the AI performs an automated review:
## Weekly Performance Review (AI-generated)

### Stats
- Trades executed: 4
- Win rate: 75% (3W/1L)
- Net P&L: +4.2%
- Max intraday drawdown: -1.8%

### Signal Analysis
- Entry signals generated: 7
- Entries taken: 4 (3 filtered by FOMC proximity rule)
- Avg time in position: 3.2 days

### What Worked
- RSI + netflow combo correctly identified 3 bounces
- Staged exit captured 82% of the move on average

### What Didn't Work
- 1 stop loss hit: entry was technically valid but BTC was correlating 
  with NASDAQ selloff â€” strategy doesn't account for equity correlation

### Suggested Adjustments
1. Add filter: no entry when NASDAQ 1D RSI < 35 (equity risk-off regime)
2. Consider tightening stop from 8% to 6% during high-correlation periods
3. Batch interval of 4h may be too tight â€” test 8h or 12h spacing

### Action Required
- Review suggestions above
- Approve/reject adjustments
- Updated strategy tree will be generated upon approval
You review, approve the changes you agree with, and the system updates itself.
This is the compounding effect: the system isn't just executing trades â€” it's continuously learning what works for your specific strategy and market conditions.
â€¨
Tool Stack Summary
| Stage                | Purpose                                | Recommended Tools                          |
| -------------------- | -------------------------------------- | ------------------------------------------ |
| Data Collection      | Market, on-chain, macro, sentiment     | CCXT, Glassnode, FRED, LunarCrush, NewsAPI |
| Data Storage         | Time-series storage                    | TimescaleDB, InfluxDB, SQLite              |
| Idea Generation      | AI-assisted trade hypothesis           | Claude API, GPT-4, OpenClaw                |
| Strategy Structuring | Natural language â†’ formal logic        | Claude + structured output, Pydantic       |
| Code Generation      | Strategy tree â†’ executable script      | Claude, Cursor, Copilot                    |
| Backtesting          | Historical validation                  | backtrader, vectorbt, Freqtrade, Jesse     |
| Paper Trading        | Live simulation                        | Exchange testnets, Freqtrade dry-run       |
| Live Execution       | Real trading                           | CCXT, exchange APIs, VPS                   |
| Monitoring           | Alerts & dashboards                    | Grafana, Telegram alerts, custom dashboard |
| Orchestration        | Scheduling & automation                | OpenClaw CRON, Celery, APScheduler         |
| Feedback & Review    | Weekly AI-generated performance review | Claude API + custom templates              |
â€¨
Final Note: The Human in the Loop
Every piece of AI in this pipeline is a tool, not a decision-maker.
â€¢ AI collects data â†’ you decide what matters
â€¢ AI generates ideas â†’ you decide which to pursue
â€¢ AI structures strategies â†’ you review every rule
â€¢ AI writes code â†’ you audit every line
â€¢ AI executes trades â†’ your rules, 100% deterministic â€¢ AI reviews performance â†’ you approve any changes
The system is powerful precisely because it keeps you in control while eliminating everything that wastes your time and corrupts your judgment.
You're not outsourcing your thinking. You're amplifying it.
Follow 
@jjjjeerryyyy
for more AI trading series.

