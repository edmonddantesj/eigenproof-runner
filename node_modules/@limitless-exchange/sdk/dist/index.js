"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  APIError: () => APIError,
  AuthenticationError: () => AuthenticationError,
  BASE_SEPOLIA_CHAIN_ID: () => BASE_SEPOLIA_CHAIN_ID,
  CONTRACT_ADDRESSES: () => CONTRACT_ADDRESSES,
  ConsoleLogger: () => ConsoleLogger,
  DEFAULT_API_URL: () => DEFAULT_API_URL,
  DEFAULT_CHAIN_ID: () => DEFAULT_CHAIN_ID,
  DEFAULT_WS_URL: () => DEFAULT_WS_URL,
  HttpClient: () => HttpClient,
  Market: () => Market,
  MarketFetcher: () => MarketFetcher,
  NoOpLogger: () => NoOpLogger,
  OrderBuilder: () => OrderBuilder,
  OrderClient: () => OrderClient,
  OrderSigner: () => OrderSigner,
  OrderType: () => OrderType,
  OrderValidationError: () => OrderValidationError,
  PortfolioFetcher: () => PortfolioFetcher,
  RateLimitError: () => RateLimitError,
  RetryConfig: () => RetryConfig,
  RetryableClient: () => RetryableClient,
  SIGNING_MESSAGE_TEMPLATE: () => SIGNING_MESSAGE_TEMPLATE,
  Side: () => Side,
  SignatureType: () => SignatureType,
  ValidationError: () => ValidationError,
  WebSocketClient: () => WebSocketClient,
  WebSocketState: () => WebSocketState,
  ZERO_ADDRESS: () => ZERO_ADDRESS,
  getContractAddress: () => getContractAddress,
  retryOnErrors: () => retryOnErrors,
  validateOrderArgs: () => validateOrderArgs,
  validateSignedOrder: () => validateSignedOrder,
  validateUnsignedOrder: () => validateUnsignedOrder,
  withRetry: () => withRetry
});
module.exports = __toCommonJS(index_exports);

// src/types/logger.ts
var NoOpLogger = class {
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
};
var ConsoleLogger = class {
  constructor(level = "info") {
    this.level = level;
  }
  shouldLog(messageLevel) {
    const levels = ["debug", "info", "warn", "error"];
    return levels.indexOf(messageLevel) >= levels.indexOf(this.level);
  }
  debug(message, meta) {
    if (this.shouldLog("debug")) {
      console.debug("[Limitless SDK]", message, meta || "");
    }
  }
  info(message, meta) {
    if (this.shouldLog("info")) {
      console.info("[Limitless SDK]", message, meta || "");
    }
  }
  warn(message, meta) {
    if (this.shouldLog("warn")) {
      console.warn("[Limitless SDK]", message, meta || "");
    }
  }
  error(message, error, meta) {
    if (this.shouldLog("error")) {
      const errorMsg = error ? error.message : "";
      console.error("[Limitless SDK]", message, errorMsg ? `- ${errorMsg}` : "", meta || "");
    }
  }
};

// src/types/orders.ts
var Side = /* @__PURE__ */ ((Side2) => {
  Side2[Side2["BUY"] = 0] = "BUY";
  Side2[Side2["SELL"] = 1] = "SELL";
  return Side2;
})(Side || {});
var OrderType = /* @__PURE__ */ ((OrderType2) => {
  OrderType2["FOK"] = "FOK";
  OrderType2["GTC"] = "GTC";
  return OrderType2;
})(OrderType || {});
var SignatureType = /* @__PURE__ */ ((SignatureType2) => {
  SignatureType2[SignatureType2["EOA"] = 0] = "EOA";
  SignatureType2[SignatureType2["POLY_PROXY"] = 1] = "POLY_PROXY";
  SignatureType2[SignatureType2["POLY_GNOSIS_SAFE"] = 2] = "POLY_GNOSIS_SAFE";
  return SignatureType2;
})(SignatureType || {});

// src/types/websocket.ts
var WebSocketState = /* @__PURE__ */ ((WebSocketState2) => {
  WebSocketState2["DISCONNECTED"] = "disconnected";
  WebSocketState2["CONNECTING"] = "connecting";
  WebSocketState2["CONNECTED"] = "connected";
  WebSocketState2["RECONNECTING"] = "reconnecting";
  WebSocketState2["ERROR"] = "error";
  return WebSocketState2;
})(WebSocketState || {});

// src/types/market-class.ts
var Market = class _Market {
  /**
   * Creates a Market instance.
   *
   * @param data - Market data from API
   * @param httpClient - HTTP client for making requests
   */
  constructor(data, httpClient) {
    Object.assign(this, data);
    this.httpClient = httpClient;
    if (data.markets && Array.isArray(data.markets)) {
      this.markets = data.markets.map((m) => new _Market(m, httpClient));
    }
  }
  /**
   * Get user's orders for this market.
   *
   * @remarks
   * Fetches all orders placed by the authenticated user for this specific market.
   * Uses the http_client from the MarketFetcher that created this Market instance.
   *
   * @returns Promise resolving to array of user orders
   * @throws Error if market wasn't fetched via MarketFetcher
   *
   * @example
   * ```typescript
   * // Clean fluent API
   * const market = await marketFetcher.getMarket("bitcoin-2024");
   * const orders = await market.getUserOrders();
   * console.log(`You have ${orders.length} orders in ${market.title}`);
   * ```
   */
  async getUserOrders() {
    if (!this.httpClient) {
      throw new Error(
        "This Market instance has no httpClient attached. Make sure to fetch the market via MarketFetcher.getMarket() to use this method."
      );
    }
    const response = await this.httpClient.get(`/markets/${this.slug}/user-orders`);
    const orders = Array.isArray(response) ? response : response.orders || [];
    return orders;
  }
};

// src/api/http.ts
var import_axios = __toESM(require("axios"));
var import_http = __toESM(require("http"));
var import_https = __toESM(require("https"));

// src/utils/constants.ts
var DEFAULT_API_URL = "https://api.limitless.exchange";
var DEFAULT_WS_URL = "wss://ws.limitless.exchange";
var DEFAULT_CHAIN_ID = 8453;
var BASE_SEPOLIA_CHAIN_ID = 84532;
var SIGNING_MESSAGE_TEMPLATE = "Welcome to Limitless.exchange! Please sign this message to verify your identity.\n\nNonce: {NONCE}";
var ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
var CONTRACT_ADDRESSES = {
  // Base mainnet (chainId: 8453)
  8453: {
    USDC: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    // Native USDC on Base
    CTF: "0xC9c98965297Bc527861c898329Ee280632B76e18"
    // Conditional Token Framework
  },
  // Base Sepolia testnet (chainId: 84532)
  84532: {
    USDC: "0x...",
    CTF: "0x..."
  }
};
function getContractAddress(contractType, chainId = DEFAULT_CHAIN_ID) {
  const addresses = CONTRACT_ADDRESSES[chainId];
  if (!addresses) {
    throw new Error(
      `No contract addresses configured for chainId ${chainId}. Supported chains: ${Object.keys(CONTRACT_ADDRESSES).join(", ")}`
    );
  }
  const address = addresses[contractType];
  if (!address || address === "0x...") {
    throw new Error(
      `Contract address for ${contractType} not available on chainId ${chainId}. Please configure the address in constants.ts or use environment variables.`
    );
  }
  return address;
}

// src/api/errors.ts
var APIError = class _APIError extends Error {
  /**
   * Creates a new API error.
   *
   * @param message - Human-readable error message
   * @param status - HTTP status code
   * @param data - Raw API response data
   * @param url - Request URL
   * @param method - Request method
   */
  constructor(message, status, data, url, method) {
    super(message);
    this.name = "APIError";
    this.status = status;
    this.data = data;
    this.url = url;
    this.method = method;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _APIError);
    }
  }
  /**
   * Checks if this error is an authentication/authorization error.
   *
   * @returns True if the error is due to expired or invalid authentication
   *
   * @example
   * ```typescript
   * try {
   *   await portfolioFetcher.getPositions();
   * } catch (error) {
   *   if (error instanceof APIError && error.isAuthError()) {
   *     // Re-authenticate and retry
   *     await authenticator.authenticate({ client: 'eoa' });
   *     await portfolioFetcher.getPositions();
   *   }
   * }
   * ```
   */
  isAuthError() {
    return this.status === 401 || this.status === 403;
  }
};
var RateLimitError = class _RateLimitError extends APIError {
  constructor(message = "Rate limit exceeded", status = 429, data = null, url, method) {
    super(message, status, data, url, method);
    this.name = "RateLimitError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _RateLimitError);
    }
  }
};
var AuthenticationError = class _AuthenticationError extends APIError {
  constructor(message = "Authentication failed", status = 401, data = null, url, method) {
    super(message, status, data, url, method);
    this.name = "AuthenticationError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _AuthenticationError);
    }
  }
};
var ValidationError = class _ValidationError extends APIError {
  constructor(message, status = 400, data = null, url, method) {
    super(message, status, data, url, method);
    this.name = "ValidationError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _ValidationError);
    }
  }
};

// src/api/http.ts
var HttpClient = class {
  /**
   * Creates a new HTTP client instance.
   *
   * @param config - Configuration options for the HTTP client
   */
  constructor(config = {}) {
    this.apiKey = config.apiKey || process.env.LIMITLESS_API_KEY;
    this.logger = config.logger || new NoOpLogger();
    if (!this.apiKey) {
      this.logger.warn(
        "API key not set. Authenticated endpoints will fail. Set LIMITLESS_API_KEY environment variable or pass apiKey parameter."
      );
    }
    const keepAlive = config.keepAlive !== false;
    const maxSockets = config.maxSockets || 50;
    const maxFreeSockets = config.maxFreeSockets || 10;
    const socketTimeout = config.socketTimeout || 6e4;
    const httpAgent = new import_http.default.Agent({
      keepAlive,
      maxSockets,
      maxFreeSockets,
      timeout: socketTimeout
    });
    const httpsAgent = new import_https.default.Agent({
      keepAlive,
      maxSockets,
      maxFreeSockets,
      timeout: socketTimeout
    });
    this.client = import_axios.default.create({
      baseURL: config.baseURL || DEFAULT_API_URL,
      timeout: config.timeout || 3e4,
      httpAgent,
      httpsAgent,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        ...config.additionalHeaders
      }
    });
    this.logger.debug("HTTP client initialized", {
      baseURL: config.baseURL || DEFAULT_API_URL,
      keepAlive,
      maxSockets,
      maxFreeSockets
    });
    this.setupInterceptors();
  }
  /**
   * Sets up request and response interceptors.
   * @internal
   */
  setupInterceptors() {
    this.client.interceptors.request.use(
      (config) => {
        if (this.apiKey) {
          config.headers["X-API-Key"] = this.apiKey;
        }
        const fullUrl = `${config.baseURL || ""}${config.url || ""}`;
        const method = config.method?.toUpperCase() || "GET";
        const logHeaders = { ...config.headers };
        if (logHeaders["X-API-Key"]) {
          logHeaders["X-API-Key"] = "***";
        }
        this.logger.debug(`\u2192 ${method} ${fullUrl}`, {
          headers: logHeaders,
          body: config.data
        });
        return config;
      },
      (error) => Promise.reject(error)
    );
    this.client.interceptors.response.use(
      (response) => {
        const method = response.config.method?.toUpperCase() || "GET";
        const url = response.config.url || "";
        this.logger.debug(`\u2713 ${response.status} ${method} ${url}`, {
          data: response.data
        });
        return response;
      },
      (error) => {
        if (error.response) {
          const status = error.response.status;
          const data = error.response.data;
          const url = error.config?.url;
          const method = error.config?.method?.toUpperCase();
          let message = error.message;
          if (data) {
            this.logger.debug(`\u2717 ${status} ${method} ${url}`, {
              error: data
            });
            if (typeof data === "object") {
              if (Array.isArray(data.message)) {
                const messages = data.message.map((err) => {
                  const details = Object.entries(err).filter(([_key, val]) => val !== "" && val !== null && val !== void 0).map(([key, val]) => `${key}: ${val}`).join(", ");
                  return details || JSON.stringify(err);
                }).filter((msg) => msg.trim() !== "").join(" | ");
                message = messages || data.error || JSON.stringify(data);
              } else {
                message = data.message || data.error || data.msg || data.errors && JSON.stringify(data.errors) || JSON.stringify(data);
              }
            } else {
              message = String(data);
            }
          }
          if (status === 429) {
            throw new RateLimitError(message, status, data, url, method);
          } else if (status === 401 || status === 403) {
            throw new AuthenticationError(message, status, data, url, method);
          } else if (status === 400) {
            throw new ValidationError(message, status, data, url, method);
          } else {
            throw new APIError(message, status, data, url, method);
          }
        } else if (error.request) {
          throw new Error("No response received from API");
        } else {
          throw new Error(`Request failed: ${error.message}`);
        }
      }
    );
  }
  /**
   * Sets the API key for authenticated requests.
   *
   * @param apiKey - API key value
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Clears the API key.
   */
  clearApiKey() {
    this.apiKey = void 0;
  }
  /**
   * Performs a GET request.
   *
   * @param url - Request URL
   * @param config - Additional request configuration
   * @returns Promise resolving to the response data
   */
  async get(url, config) {
    const response = await this.client.get(url, config);
    return response.data;
  }
  /**
   * Performs a POST request.
   *
   * @param url - Request URL
   * @param data - Request body data
   * @param config - Additional request configuration
   * @returns Promise resolving to the response data
   */
  async post(url, data, config) {
    const response = await this.client.post(url, data, config);
    return response.data;
  }
  /**
   * Performs a DELETE request.
   *
   * @remarks
   * DELETE requests typically don't have a body, so we remove the Content-Type header
   * to avoid "Body cannot be empty" errors from the API.
   *
   * @param url - Request URL
   * @param config - Additional request configuration
   * @returns Promise resolving to the response data
   */
  async delete(url, config) {
    const deleteConfig = {
      ...config,
      headers: {
        ...config?.headers,
        "Content-Type": void 0
      }
    };
    const response = await this.client.delete(url, deleteConfig);
    return response.data;
  }
};

// src/api/retry.ts
var RetryConfig = class {
  /**
   * Creates a new retry configuration.
   *
   * @param options - Configuration options
   */
  constructor(options = {}) {
    this.statusCodes = new Set(options.statusCodes || [429, 500, 502, 503, 504]);
    this.maxRetries = options.maxRetries ?? 3;
    this.delays = options.delays;
    this.exponentialBase = options.exponentialBase ?? 2;
    this.maxDelay = options.maxDelay ?? 60;
    this.onRetry = options.onRetry;
  }
  /**
   * Calculates delay for a given retry attempt.
   *
   * @param attempt - Retry attempt number (0-based)
   * @returns Delay in seconds
   */
  getDelay(attempt) {
    if (this.delays) {
      return this.delays[Math.min(attempt, this.delays.length - 1)];
    } else {
      return Math.min(Math.pow(this.exponentialBase, attempt), this.maxDelay);
    }
  }
};
function sleep(seconds) {
  return new Promise((resolve) => setTimeout(resolve, seconds * 1e3));
}
function retryOnErrors(options = {}) {
  const config = new RetryConfig(options);
  return function(_target, _propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = async function(...args) {
      let lastError;
      try {
        return await originalMethod.apply(this, args);
      } catch (error) {
        if (error instanceof APIError && config.statusCodes.has(error.status)) {
          lastError = error;
        } else {
          throw error;
        }
      }
      for (let attempt = 0; attempt < config.maxRetries; attempt++) {
        try {
          const delay = config.getDelay(attempt);
          if (config.onRetry && lastError) {
            config.onRetry(attempt, lastError, delay);
          }
          await sleep(delay);
          return await originalMethod.apply(this, args);
        } catch (error) {
          if (error instanceof APIError && config.statusCodes.has(error.status)) {
            lastError = error;
          } else {
            throw error;
          }
        }
      }
      throw lastError;
    };
    return descriptor;
  };
}
async function withRetry(fn, options = {}, logger = new NoOpLogger()) {
  const config = new RetryConfig(options);
  let lastError;
  try {
    return await fn();
  } catch (error) {
    if (error instanceof APIError && config.statusCodes.has(error.status)) {
      lastError = error;
      logger.warn("API error, starting retries", { status: error.status });
    } else {
      throw error;
    }
  }
  for (let attempt = 0; attempt < config.maxRetries; attempt++) {
    try {
      const delay = config.getDelay(attempt);
      if (config.onRetry && lastError) {
        config.onRetry(attempt, lastError, delay);
      }
      logger.info("Retrying operation", { attempt: attempt + 1, delay });
      await sleep(delay);
      return await fn();
    } catch (error) {
      if (error instanceof APIError && config.statusCodes.has(error.status)) {
        lastError = error;
        logger.warn("Retry failed", { attempt: attempt + 1, status: error.status });
      } else {
        throw error;
      }
    }
  }
  logger.error("All retries exhausted");
  throw lastError;
}
var RetryableClient = class {
  /**
   * Creates a new retryable client wrapper.
   *
   * @param httpClient - HTTP client to wrap
   * @param retryConfig - Retry configuration
   * @param logger - Optional logger
   */
  constructor(httpClient, retryConfig = new RetryConfig(), logger = new NoOpLogger()) {
    this.httpClient = httpClient;
    this.retryConfig = retryConfig;
    this.logger = logger;
  }
  /**
   * Performs a GET request with retry logic.
   *
   * @param url - Request URL
   * @param config - Additional request configuration
   * @returns Promise resolving to the response data
   */
  async get(url, config) {
    return withRetry(
      async () => this.httpClient.get(url, config),
      {
        statusCodes: Array.from(this.retryConfig.statusCodes),
        maxRetries: this.retryConfig.maxRetries,
        delays: this.retryConfig.delays,
        exponentialBase: this.retryConfig.exponentialBase,
        maxDelay: this.retryConfig.maxDelay,
        onRetry: this.retryConfig.onRetry
      },
      this.logger
    );
  }
  /**
   * Performs a POST request with retry logic.
   *
   * @param url - Request URL
   * @param data - Request body data
   * @param config - Additional request configuration
   * @returns Promise resolving to the response data
   */
  async post(url, data, config) {
    return withRetry(
      async () => this.httpClient.post(url, data, config),
      {
        statusCodes: Array.from(this.retryConfig.statusCodes),
        maxRetries: this.retryConfig.maxRetries,
        delays: this.retryConfig.delays,
        exponentialBase: this.retryConfig.exponentialBase,
        maxDelay: this.retryConfig.maxDelay,
        onRetry: this.retryConfig.onRetry
      },
      this.logger
    );
  }
  /**
   * Performs a DELETE request with retry logic.
   *
   * @param url - Request URL
   * @param config - Additional request configuration
   * @returns Promise resolving to the response data
   */
  async delete(url, config) {
    return withRetry(
      async () => this.httpClient.delete(url, config),
      {
        statusCodes: Array.from(this.retryConfig.statusCodes),
        maxRetries: this.retryConfig.maxRetries,
        delays: this.retryConfig.delays,
        exponentialBase: this.retryConfig.exponentialBase,
        maxDelay: this.retryConfig.maxDelay,
        onRetry: this.retryConfig.onRetry
      },
      this.logger
    );
  }
};

// src/orders/builder.ts
var import_ethers = require("ethers");
var ZERO_ADDRESS2 = "0x0000000000000000000000000000000000000000";
var DEFAULT_PRICE_TICK = 1e-3;
var OrderBuilder = class {
  /**
   * Creates a new order builder instance.
   *
   * @param makerAddress - Ethereum address of the order maker
   * @param feeRateBps - Fee rate in basis points (e.g., 100 = 1%)
   * @param priceTick - Price tick size (default: 0.001 for 3 decimals)
   *
   * @example
   * ```typescript
   * const builder = new OrderBuilder(
   *   '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb',
   *   300, // 3% fee
   *   0.001 // 3 decimal price precision
   * );
   * ```
   */
  constructor(makerAddress, feeRateBps, priceTick = DEFAULT_PRICE_TICK) {
    this.makerAddress = makerAddress;
    this.feeRateBps = feeRateBps;
    this.priceTick = priceTick;
  }
  /**
   * Builds an unsigned order payload.
   *
   * @param args - Order arguments (FOK or GTC)
   * @returns Unsigned order ready for signing
   *
   * @throws Error if validation fails or tick alignment fails
   *
   * @example
   * ```typescript
   * // FOK order (market order)
   * const fokOrder = builder.buildOrder({
   *   tokenId: '123456',
   *   makerAmount: 50,  // 50 USDC to spend
   *   side: Side.BUY
   * });
   *
   * // GTC order (price + size)
   * const gtcOrder = builder.buildOrder({
   *   tokenId: '123456',
   *   price: 0.38,
   *   size: 22.123,  // Will be rounded to tick-aligned: 22.123 shares
   *   side: Side.BUY
   * });
   * ```
   */
  buildOrder(args) {
    this.validateOrderArgs(args);
    const { makerAmount, takerAmount, price } = this.isFOKOrder(args) ? this.calculateFOKAmounts(args.makerAmount) : this.calculateGTCAmountsTickAligned(args.price, args.size, args.side);
    const order = {
      salt: this.generateSalt(),
      maker: this.makerAddress,
      signer: this.makerAddress,
      taker: args.taker || ZERO_ADDRESS2,
      tokenId: args.tokenId,
      makerAmount,
      takerAmount,
      expiration: args.expiration || "0",
      nonce: args.nonce || 0,
      feeRateBps: this.feeRateBps,
      side: args.side,
      signatureType: 0 /* EOA */
    };
    if (price !== void 0) {
      order.price = price;
    }
    return order;
  }
  /**
   * Type guard to check if order arguments are for FOK order.
   *
   * @param args - Order arguments
   * @returns True if FOK order arguments
   *
   * @internal
   */
  isFOKOrder(args) {
    return "makerAmount" in args;
  }
  /**
   * Generates a unique salt using timestamp + nano-offset pattern.
   *
   * @remarks
   * This follows the reference implementation pattern:
   * salt = timestamp * 1000 + nanoOffset + 24h
   *
   * This ensures uniqueness even when creating orders rapidly.
   *
   * @returns Unique salt value
   *
   * @internal
   */
  generateSalt() {
    const timestamp = Date.now();
    const nanoOffset = Math.floor(performance.now() * 1e3) % 1e6;
    const oneDayMs = 1e3 * 60 * 60 * 24;
    return timestamp * 1e3 + nanoOffset + oneDayMs;
  }
  /**
   * Parses decimal string to scaled BigInt.
   *
   * @param value - Decimal string (e.g., "0.38")
   * @param scale - Scale factor (e.g., 1_000_000n for 6 decimals)
   * @returns Scaled BigInt value
   *
   * @internal
   */
  parseDecToInt(value, scale) {
    const s = value.trim();
    const [intPart, fracPart = ""] = s.split(".");
    const decimals = scale.toString().length - 1;
    const frac = (fracPart + "0".repeat(decimals)).slice(0, decimals);
    const sign = intPart.startsWith("-") ? -1n : 1n;
    const intPartAbs = intPart.replace("-", "");
    return sign * (BigInt(intPartAbs || "0") * scale + BigInt(frac || "0"));
  }
  /**
   * Ceiling division for BigInt.
   *
   * @param numerator - Numerator
   * @param denominator - Denominator
   * @returns Ceiling of numerator / denominator
   *
   * @internal
   */
  divCeil(numerator, denominator) {
    if (denominator === 0n) {
      throw new Error("Division by zero");
    }
    return (numerator + denominator - 1n) / denominator;
  }
  /**
   * Calculates maker and taker amounts for GTC orders with tick alignment validation.
   *
   * @remarks
   * Validates and calculates amounts to ensure:
   * 1. Price aligns to tick size (e.g., 0.001 for 3 decimals)
   * 2. Size produces takerAmount divisible by sharesStep
   * 3. No auto-rounding - fails fast if values are invalid
   * 4. Transparent error messages guide users to valid values
   *
   * **Algorithm**:
   * - sharesStep = priceScale / tickInt (e.g., 1000 for 0.001 tick)
   * - Validates shares are divisible by sharesStep
   * - Calculates collateral from shares Ã— price (ceil for BUY, floor for SELL)
   * - Assigns maker/taker based on side:
   *   - BUY: maker = collateral, taker = shares
   *   - SELL: maker = shares, taker = collateral
   * - Throws clear error if size is not tick-aligned
   *
   * @param price - Price per share (0.0 to 1.0, max 3 decimals)
   * @param size - Number of shares (must be tick-aligned)
   * @param side - Order side (BUY or SELL)
   * @returns Object with validated makerAmount, takerAmount, and price
   *
   * @throws Error if price or size not tick-aligned
   *
   * @internal
   */
  calculateGTCAmountsTickAligned(price, size, side) {
    const sharesScale = 1000000n;
    const collateralScale = 1000000n;
    const priceScale = 1000000n;
    const shares = this.parseDecToInt(size.toString(), sharesScale);
    const priceInt = this.parseDecToInt(price.toString(), priceScale);
    const tickInt = this.parseDecToInt(this.priceTick.toString(), priceScale);
    if (tickInt <= 0n) {
      throw new Error(`Invalid priceTick: ${this.priceTick}`);
    }
    if (priceInt <= 0n) {
      throw new Error(`Invalid price: ${price}`);
    }
    if (priceInt % tickInt !== 0n) {
      throw new Error(
        `Price ${price} is not tick-aligned. Must be multiple of ${this.priceTick} (e.g., 0.380, 0.381, etc.)`
      );
    }
    const sharesStep = priceScale / tickInt;
    if (shares % sharesStep !== 0n) {
      const validSizeDown = Number(shares / sharesStep * sharesStep) / 1e6;
      const validSizeUp = Number(this.divCeil(shares, sharesStep) * sharesStep) / 1e6;
      throw new Error(
        `Invalid size: ${size}. Size must produce contracts divisible by ${sharesStep} (sharesStep). Try ${validSizeDown} (rounded down) or ${validSizeUp} (rounded up) instead.`
      );
    }
    const numerator = shares * priceInt * collateralScale;
    const denominator = sharesScale * priceScale;
    const collateral = side === 0 /* BUY */ ? this.divCeil(numerator, denominator) : numerator / denominator;
    let makerAmount;
    let takerAmount;
    if (side === 0 /* BUY */) {
      makerAmount = collateral;
      takerAmount = shares;
    } else {
      makerAmount = shares;
      takerAmount = collateral;
    }
    return {
      makerAmount: Number(makerAmount),
      takerAmount: Number(takerAmount),
      price
    };
  }
  /**
   * Calculates maker and taker amounts for FOK (market) orders.
   *
   * @remarks
   * FOK orders use makerAmount for both BUY and SELL:
   * - BUY: makerAmount = USDC amount to spend (e.g., 50 = $50 USDC)
   * - SELL: makerAmount = number of shares to sell (e.g., 18.64 shares)
   *
   * takerAmount is always 1 (constant for FOK orders)
   *
   * @param makerAmount - Amount in human-readable format (max 6 decimals)
   * @returns Object with makerAmount (scaled), takerAmount (always 1), and undefined price
   *
   * @internal
   */
  calculateFOKAmounts(makerAmount) {
    const DECIMALS = 6;
    const amountStr = makerAmount.toString();
    const decimalIndex = amountStr.indexOf(".");
    if (decimalIndex !== -1) {
      const decimalPlaces = amountStr.length - decimalIndex - 1;
      if (decimalPlaces > DECIMALS) {
        throw new Error(
          `Invalid makerAmount: ${makerAmount}. Can have max ${DECIMALS} decimal places. Try ${makerAmount.toFixed(DECIMALS)} instead.`
        );
      }
    }
    const amountFormatted = makerAmount.toFixed(DECIMALS);
    const amountScaled = import_ethers.ethers.parseUnits(amountFormatted, DECIMALS);
    const collateralAmount = Number(amountScaled);
    return {
      makerAmount: collateralAmount,
      takerAmount: 1,
      price: void 0
    };
  }
  /**
   * Validates order arguments.
   *
   * @param args - Order arguments to validate
   * @throws Error if validation fails
   *
   * @internal
   */
  validateOrderArgs(args) {
    if (!args.tokenId || args.tokenId === "0") {
      throw new Error("Invalid tokenId: tokenId is required.");
    }
    if (args.taker && !import_ethers.ethers.isAddress(args.taker)) {
      throw new Error(`Invalid taker address: ${args.taker}`);
    }
    if (this.isFOKOrder(args)) {
      if (!args.makerAmount) {
        throw new Error("FOK orders require makerAmount");
      }
      if (args.makerAmount <= 0) {
        throw new Error(`Invalid makerAmount: ${args.makerAmount}. Maker amount must be positive.`);
      }
    } else {
      if (args.price == null || args.price < 0 || args.price > 1) {
        throw new Error(`Invalid price: ${args.price}. Price must be between 0 and 1.`);
      }
      if (args.size <= 0) {
        throw new Error(`Invalid size: ${args.size}. Size must be positive.`);
      }
      const priceStr = args.price.toString();
      const decimalIndex = priceStr.indexOf(".");
      if (decimalIndex !== -1) {
        const decimalPlaces = priceStr.length - decimalIndex - 1;
        if (decimalPlaces > 3) {
          throw new Error(
            `Invalid price: ${args.price}. Price must have max 3 decimal places (e.g., 0.380, 0.001).`
          );
        }
      }
    }
  }
};

// src/orders/signer.ts
var OrderSigner = class {
  /**
   * Creates a new order signer instance.
   *
   * @param wallet - Ethers wallet for signing
   * @param logger - Optional logger for debugging (default: no logging)
   *
   * @example
   * ```typescript
   * import { ethers } from 'ethers';
   * import { OrderSigner } from '@limitless-exchange/sdk';
   *
   * const wallet = new ethers.Wallet(privateKey);
   * const signer = new OrderSigner(wallet);
   * ```
   */
  constructor(wallet, logger) {
    this.wallet = wallet;
    this.logger = logger || new NoOpLogger();
  }
  /**
   * Signs an order with EIP-712.
   *
   * @param order - Unsigned order to sign
   * @param config - Signing configuration (chainId, contract address, market type)
   * @returns Promise resolving to EIP-712 signature
   *
   * @throws Error if wallet address doesn't match order signer
   * @throws Error if signing fails
   *
   * @example
   * ```typescript
   * const signature = await signer.signOrder(unsignedOrder, {
   *   chainId: 8453,
   *   contractAddress: '0x...'
   * });
   * ```
   */
  async signOrder(order, config) {
    this.logger.debug("Signing order with EIP-712", {
      tokenId: order.tokenId,
      side: order.side,
      verifyingContract: config.contractAddress
    });
    const walletAddress = await this.wallet.getAddress();
    if (walletAddress.toLowerCase() !== order.signer.toLowerCase()) {
      const error = `Wallet address mismatch! Signing with: ${walletAddress}, but order signer is: ${order.signer}`;
      this.logger.error(error);
      throw new Error(error);
    }
    const domain = this.getDomain(config);
    this.logger.debug("EIP-712 Domain", domain);
    const types = this.getTypes();
    const orderValue = {
      salt: order.salt,
      maker: order.maker,
      signer: order.signer,
      taker: order.taker,
      tokenId: order.tokenId,
      makerAmount: order.makerAmount,
      takerAmount: order.takerAmount,
      expiration: order.expiration,
      nonce: order.nonce,
      feeRateBps: order.feeRateBps,
      side: order.side,
      signatureType: order.signatureType
    };
    this.logger.debug("EIP-712 Order Value", orderValue);
    this.logger.debug("Full signing payload", {
      domain,
      types: this.getTypes(),
      value: orderValue
    });
    try {
      const signature = await this.wallet.signTypedData(domain, types, orderValue);
      this.logger.info("Successfully generated EIP-712 signature", {
        signature: signature.slice(0, 10) + "..."
      });
      return signature;
    } catch (error) {
      this.logger.error("Failed to sign order", error);
      throw error;
    }
  }
  /**
   * Gets the EIP-712 domain for signing.
   *
   * @param config - Signing configuration
   * @returns EIP-712 domain object
   *
   * @internal
   */
  getDomain(config) {
    return {
      name: "Limitless CTF Exchange",
      version: "1",
      chainId: config.chainId,
      verifyingContract: config.contractAddress
    };
  }
  /**
   * Gets the EIP-712 type definitions.
   *
   * @remarks
   * This matches the order structure expected by the Limitless Exchange
   * smart contracts.
   *
   * @returns EIP-712 types definition
   *
   * @internal
   */
  getTypes() {
    return {
      Order: [
        { name: "salt", type: "uint256" },
        { name: "maker", type: "address" },
        { name: "signer", type: "address" },
        { name: "taker", type: "address" },
        { name: "tokenId", type: "uint256" },
        { name: "makerAmount", type: "uint256" },
        { name: "takerAmount", type: "uint256" },
        { name: "expiration", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "feeRateBps", type: "uint256" },
        { name: "side", type: "uint8" },
        { name: "signatureType", type: "uint8" }
      ]
    };
  }
};

// src/orders/validator.ts
var import_ethers2 = require("ethers");
var OrderValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "OrderValidationError";
  }
};
function isFOKOrder(args) {
  return "amount" in args;
}
function validateOrderArgs(args) {
  if (!args.tokenId) {
    throw new OrderValidationError("TokenId is required");
  }
  if (args.tokenId === "0") {
    throw new OrderValidationError("TokenId cannot be zero");
  }
  if (!/^\d+$/.test(args.tokenId)) {
    throw new OrderValidationError(`Invalid tokenId format: ${args.tokenId}`);
  }
  if (args.taker && !import_ethers2.ethers.isAddress(args.taker)) {
    throw new OrderValidationError(`Invalid taker address: ${args.taker}`);
  }
  if (args.expiration !== void 0) {
    if (!/^\d+$/.test(args.expiration)) {
      throw new OrderValidationError(`Invalid expiration format: ${args.expiration}`);
    }
  }
  if (args.nonce !== void 0) {
    if (!Number.isInteger(args.nonce) || args.nonce < 0) {
      throw new OrderValidationError(`Invalid nonce: ${args.nonce}`);
    }
  }
  if (isFOKOrder(args)) {
    if (typeof args.makerAmount !== "number" || isNaN(args.makerAmount)) {
      throw new OrderValidationError("Amount must be a valid number");
    }
    if (args.makerAmount <= 0) {
      throw new OrderValidationError(`Amount must be positive, got: ${args.makerAmount}`);
    }
    const amountStr = args.makerAmount.toString();
    const decimalIndex = amountStr.indexOf(".");
    if (decimalIndex !== -1) {
      const decimalPlaces = amountStr.length - decimalIndex - 1;
      if (decimalPlaces > 2) {
        throw new OrderValidationError(
          `Amount must have max 2 decimal places, got: ${args.makerAmount} (${decimalPlaces} decimals)`
        );
      }
    }
  } else {
    if (typeof args.price !== "number" || isNaN(args.price)) {
      throw new OrderValidationError("Price must be a valid number");
    }
    if (args.price < 0 || args.price > 1) {
      throw new OrderValidationError(`Price must be between 0 and 1, got: ${args.price}`);
    }
    if (typeof args.size !== "number" || isNaN(args.size)) {
      throw new OrderValidationError("Size must be a valid number");
    }
    if (args.size <= 0) {
      throw new OrderValidationError(`Size must be positive, got: ${args.size}`);
    }
  }
}
function validateUnsignedOrder(order) {
  if (!import_ethers2.ethers.isAddress(order.maker)) {
    throw new OrderValidationError(`Invalid maker address: ${order.maker}`);
  }
  if (!import_ethers2.ethers.isAddress(order.signer)) {
    throw new OrderValidationError(`Invalid signer address: ${order.signer}`);
  }
  if (!import_ethers2.ethers.isAddress(order.taker)) {
    throw new OrderValidationError(`Invalid taker address: ${order.taker}`);
  }
  if (!order.makerAmount || order.makerAmount === 0) {
    throw new OrderValidationError("MakerAmount must be greater than zero");
  }
  if (!order.takerAmount || order.takerAmount === 0) {
    throw new OrderValidationError("TakerAmount must be greater than zero");
  }
  if (typeof order.makerAmount !== "number" || order.makerAmount <= 0) {
    throw new OrderValidationError(`Invalid makerAmount: ${order.makerAmount}`);
  }
  if (typeof order.takerAmount !== "number" || order.takerAmount <= 0) {
    throw new OrderValidationError(`Invalid takerAmount: ${order.takerAmount}`);
  }
  if (!/^\d+$/.test(order.tokenId)) {
    throw new OrderValidationError(`Invalid tokenId format: ${order.tokenId}`);
  }
  if (!/^\d+$/.test(order.expiration)) {
    throw new OrderValidationError(`Invalid expiration format: ${order.expiration}`);
  }
  if (!Number.isInteger(order.salt) || order.salt <= 0) {
    throw new OrderValidationError(`Invalid salt: ${order.salt}`);
  }
  if (!Number.isInteger(order.nonce) || order.nonce < 0) {
    throw new OrderValidationError(`Invalid nonce: ${order.nonce}`);
  }
  if (!Number.isInteger(order.feeRateBps) || order.feeRateBps < 0) {
    throw new OrderValidationError(`Invalid feeRateBps: ${order.feeRateBps}`);
  }
  if (order.side !== 0 && order.side !== 1) {
    throw new OrderValidationError(`Invalid side: ${order.side}. Must be 0 (BUY) or 1 (SELL)`);
  }
  if (!Number.isInteger(order.signatureType) || order.signatureType < 0) {
    throw new OrderValidationError(`Invalid signatureType: ${order.signatureType}`);
  }
  if (order.price !== void 0) {
    if (typeof order.price !== "number" || isNaN(order.price)) {
      throw new OrderValidationError("Price must be a valid number");
    }
    if (order.price < 0 || order.price > 1) {
      throw new OrderValidationError(`Price must be between 0 and 1, got: ${order.price}`);
    }
  }
}
function validateSignedOrder(order) {
  validateUnsignedOrder(order);
  if (!order.signature) {
    throw new OrderValidationError("Signature is required");
  }
  if (!order.signature.startsWith("0x")) {
    throw new OrderValidationError("Signature must start with 0x");
  }
  if (order.signature.length !== 132) {
    throw new OrderValidationError(
      `Invalid signature length: ${order.signature.length}. Expected 132 characters.`
    );
  }
  if (!/^0x[0-9a-fA-F]{130}$/.test(order.signature)) {
    throw new OrderValidationError("Signature must be valid hex string");
  }
}

// src/markets/fetcher.ts
var MarketFetcher = class {
  /**
   * Creates a new market fetcher instance.
   *
   * @param httpClient - HTTP client for API requests
   * @param logger - Optional logger for debugging (default: no logging)
   *
   * @example
   * ```typescript
   * const fetcher = new MarketFetcher(httpClient);
   * ```
   */
  constructor(httpClient, logger) {
    this.httpClient = httpClient;
    this.logger = logger || new NoOpLogger();
    this.venueCache = /* @__PURE__ */ new Map();
  }
  /**
   * Gets active markets with query parameters and pagination support.
   *
   * @param params - Query parameters for filtering and pagination
   * @returns Promise resolving to active markets response
   * @throws Error if API request fails
   *
   * @example
   * ```typescript
   * // Get 8 markets sorted by LP rewards
   * const response = await fetcher.getActiveMarkets({
   *   limit: 8,
   *   sortBy: 'lp_rewards'
   * });
   * console.log(`Found ${response.data.length} of ${response.totalMarketsCount} markets`);
   *
   * // Get page 2
   * const page2 = await fetcher.getActiveMarkets({
   *   limit: 8,
   *   page: 2,
   *   sortBy: 'ending_soon'
   * });
   * ```
   */
  async getActiveMarkets(params) {
    const queryParams = new URLSearchParams();
    if (params?.limit !== void 0) {
      queryParams.append("limit", params.limit.toString());
    }
    if (params?.page !== void 0) {
      queryParams.append("page", params.page.toString());
    }
    if (params?.sortBy) {
      queryParams.append("sortBy", params.sortBy);
    }
    const queryString = queryParams.toString();
    const endpoint = `/markets/active${queryString ? `?${queryString}` : ""}`;
    this.logger.debug("Fetching active markets", { params });
    try {
      const response = await this.httpClient.get(endpoint);
      const markets = response.data.map((marketData) => new Market(marketData, this.httpClient));
      const result = {
        data: markets,
        totalMarketsCount: response.totalMarketsCount
      };
      this.logger.info("Active markets fetched successfully", {
        count: markets.length,
        total: response.totalMarketsCount,
        sortBy: params?.sortBy,
        page: params?.page
      });
      return result;
    } catch (error) {
      this.logger.error("Failed to fetch active markets", error, { params });
      throw error;
    }
  }
  /**
   * Gets a single market by slug.
   *
   * @remarks
   * Automatically caches venue information for efficient order signing.
   * Always call this method before creating orders to ensure venue data
   * is available and avoid additional API requests.
   *
   * @param slug - Market slug identifier
   * @returns Promise resolving to market details
   * @throws Error if API request fails or market not found
   *
   * @example
   * ```typescript
   * // Get market
   * const market = await fetcher.getMarket('bitcoin-price-2024');
   * console.log(`Market: ${market.title}`);
   *
   * // Fluent API - get user orders for this market (clean!)
   * const orders = await market.getUserOrders();
   * console.log(`You have ${orders.length} orders`);
   *
   * // Venue is now cached for order signing
   * await orderClient.createOrder({
   *   marketSlug: 'bitcoin-price-2024',
   *   ...
   * });
   * ```
   */
  async getMarket(slug) {
    this.logger.debug("Fetching market", { slug });
    try {
      const response = await this.httpClient.get(`/markets/${slug}`);
      const market = new Market(response, this.httpClient);
      if (market.venue) {
        this.venueCache.set(slug, market.venue);
        this.logger.debug("Venue cached for order signing", {
          slug,
          exchange: market.venue.exchange,
          adapter: market.venue.adapter,
          cacheSize: this.venueCache.size
        });
      } else {
        this.logger.warn("Market has no venue data", { slug });
      }
      this.logger.info("Market fetched successfully", {
        slug,
        title: market.title
      });
      return market;
    } catch (error) {
      this.logger.error("Failed to fetch market", error, { slug });
      throw error;
    }
  }
  /**
   * Gets cached venue information for a market.
   *
   * @remarks
   * Returns venue data previously cached by getMarket() call.
   * Used internally by OrderClient for efficient order signing.
   *
   * @param slug - Market slug identifier
   * @returns Cached venue information, or undefined if not in cache
   *
   * @example
   * ```typescript
   * const venue = fetcher.getVenue('bitcoin-price-2024');
   * if (venue) {
   *   console.log(`Exchange: ${venue.exchange}`);
   * }
   * ```
   */
  getVenue(slug) {
    const venue = this.venueCache.get(slug);
    if (venue) {
      this.logger.debug("Venue cache hit", {
        slug,
        exchange: venue.exchange
      });
    } else {
      this.logger.debug("Venue cache miss", { slug });
    }
    return venue;
  }
  /**
   * Gets the orderbook for a CLOB market.
   *
   * @param slug - Market slug identifier
   * @returns Promise resolving to orderbook data
   * @throws Error if API request fails
   *
   * @example
   * ```typescript
   * const orderbook = await fetcher.getOrderBook('bitcoin-price-2024');
   * console.log(`Bids: ${orderbook.bids.length}, Asks: ${orderbook.asks.length}`);
   * ```
   */
  async getOrderBook(slug) {
    this.logger.debug("Fetching orderbook", { slug });
    try {
      const orderbook = await this.httpClient.get(
        `/markets/${slug}/orderbook`
      );
      this.logger.info("Orderbook fetched successfully", {
        slug,
        bids: orderbook.bids.length,
        asks: orderbook.asks.length,
        tokenId: orderbook.tokenId
      });
      return orderbook;
    } catch (error) {
      this.logger.error("Failed to fetch orderbook", error, { slug });
      throw error;
    }
  }
};

// src/portfolio/fetcher.ts
var PortfolioFetcher = class {
  /**
   * Creates a new portfolio fetcher instance.
   *
   * @param httpClient - Authenticated HTTP client for API requests
   * @param logger - Optional logger for debugging (default: no logging)
   *
   * @example
   * ```typescript
   * // Create authenticated client
   * const httpClient = new HttpClient({ baseURL: API_URL });
   * await authenticator.authenticate({ client: 'eoa' });
   *
   * // Create portfolio fetcher
   * const portfolioFetcher = new PortfolioFetcher(httpClient);
   * ```
   */
  constructor(httpClient, logger) {
    this.httpClient = httpClient;
    this.logger = logger || new NoOpLogger();
  }
  /**
   * Gets user profile for a specific wallet address.
   *
   * @remarks
   * Returns user profile data including user ID and fee rate.
   * Used internally by OrderClient to fetch user data.
   *
   * @param address - Wallet address to fetch profile for
   * @returns Promise resolving to user profile data
   * @throws Error if API request fails or user is not authenticated
   *
   * @example
   * ```typescript
   * const profile = await portfolioFetcher.getProfile('0x1234...');
   * console.log(`User ID: ${profile.id}`);
   * console.log(`Account: ${profile.account}`);
   * console.log(`Fee Rate: ${profile.rank?.feeRateBps}`);
   * ```
   */
  async getProfile(address) {
    this.logger.debug("Fetching user profile", { address });
    try {
      const response = await this.httpClient.get(`/profiles/${address}`);
      this.logger.info("User profile fetched successfully", { address });
      return response;
    } catch (error) {
      this.logger.error("Failed to fetch user profile", error, { address });
      throw error;
    }
  }
  /**
   * Gets raw portfolio positions response from API.
   *
   * @returns Promise resolving to portfolio positions response with CLOB and AMM positions
   * @throws Error if API request fails or user is not authenticated
   *
   * @example
   * ```typescript
   * const response = await portfolioFetcher.getPositions();
   * console.log(`CLOB positions: ${response.clob.length}`);
   * console.log(`AMM positions: ${response.amm.length}`);
   * console.log(`Total points: ${response.accumulativePoints}`);
   * ```
   */
  async getPositions() {
    this.logger.debug("Fetching user positions");
    try {
      const response = await this.httpClient.get("/portfolio/positions");
      this.logger.info("Positions fetched successfully", {
        clobCount: response.clob?.length || 0,
        ammCount: response.amm?.length || 0
      });
      return response;
    } catch (error) {
      this.logger.error("Failed to fetch positions", error);
      throw error;
    }
  }
  /**
   * Gets CLOB positions only.
   *
   * @returns Promise resolving to array of CLOB positions
   * @throws Error if API request fails
   *
   * @example
   * ```typescript
   * const clobPositions = await portfolioFetcher.getCLOBPositions();
   * clobPositions.forEach(pos => {
   *   console.log(`${pos.market.title}: YES ${pos.positions.yes.unrealizedPnl} P&L`);
   * });
   * ```
   */
  async getCLOBPositions() {
    const response = await this.getPositions();
    return response.clob || [];
  }
  /**
   * Gets AMM positions only.
   *
   * @returns Promise resolving to array of AMM positions
   * @throws Error if API request fails
   *
   * @example
   * ```typescript
   * const ammPositions = await portfolioFetcher.getAMMPositions();
   * ammPositions.forEach(pos => {
   *   console.log(`${pos.market.title}: ${pos.unrealizedPnl} P&L`);
   * });
   * ```
   */
  async getAMMPositions() {
    const response = await this.getPositions();
    return response.amm || [];
  }
  /**
   * Gets paginated history of user actions.
   *
   *  Includes AMM trades, CLOB trades, Negrisk trades & conversions.
   *
   * @param page - Page number (starts at 1)
   * @param limit - Number of items per page
   * @returns Promise resolving to paginated history response
   * @throws Error if API request fails or user is not authenticated
   *
   * @example
   * ```typescript
   * // Get first page
   * const response = await portfolioFetcher.getUserHistory(1, 20);
   * console.log(`Found ${response.data.length} of ${response.totalCount} entries`);
   *
   * // Process history entries
   * for (const entry of response.data) {
   *   console.log(`Type: ${entry.type}`);
   *   console.log(`Market: ${entry.marketSlug}`);
   * }
   *
   * // Get next page
   * const page2 = await portfolioFetcher.getUserHistory(2, 20);
   * ```
   */
  async getUserHistory(page = 1, limit = 10) {
    this.logger.debug("Fetching user history", { page, limit });
    try {
      const params = new URLSearchParams({
        page: page.toString(),
        limit: limit.toString()
      });
      const response = await this.httpClient.get(
        `/portfolio/history?${params.toString()}`
      );
      this.logger.info("User history fetched successfully");
      return response;
    } catch (error) {
      this.logger.error("Failed to fetch user history", error, { page, limit });
      throw error;
    }
  }
};

// src/orders/client.ts
var OrderClient = class {
  /**
   * Creates a new order client instance.
   *
   * @param config - Order client configuration
   */
  constructor(config) {
    this.httpClient = config.httpClient;
    this.wallet = config.wallet;
    this.logger = config.logger || new NoOpLogger();
    this.orderSigner = new OrderSigner(config.wallet, this.logger);
    this.marketFetcher = config.marketFetcher || new MarketFetcher(config.httpClient, this.logger);
    if (config.signingConfig) {
      this.signingConfig = config.signingConfig;
    } else {
      const chainId = parseInt(process.env.CHAIN_ID || "8453");
      const contractAddress = ZERO_ADDRESS;
      this.signingConfig = {
        chainId,
        contractAddress
      };
      this.logger.info("Auto-configured signing (contract address from venue)", {
        chainId
      });
    }
  }
  /**
   * Ensures user data is loaded and cached.
   * Fetches from profile API on first call, then caches for subsequent calls.
   *
   * @returns Promise resolving to cached user data
   * @internal
   */
  async ensureUserData() {
    if (!this.cachedUserData) {
      this.logger.info("Fetching user profile for order client initialization...", {
        walletAddress: this.wallet.address
      });
      const portfolioFetcher = new PortfolioFetcher(this.httpClient);
      const profile = await portfolioFetcher.getProfile(this.wallet.address);
      this.cachedUserData = {
        userId: profile.id,
        feeRateBps: profile.rank?.feeRateBps || 300
      };
      this.orderBuilder = new OrderBuilder(
        this.wallet.address,
        this.cachedUserData.feeRateBps,
        1e-3
      );
      this.logger.info("Order Client initialized", {
        walletAddress: profile.account,
        userId: this.cachedUserData.userId,
        feeRate: `${this.cachedUserData.feeRateBps / 100}%`
      });
    }
    return this.cachedUserData;
  }
  /**
   * Creates and submits a new order.
   *
   * @remarks
   * This method handles the complete order creation flow:
   * 1. Resolve venue address (from cache or API)
   * 2. Build unsigned order
   * 3. Sign with EIP-712 using venue.exchange as verifyingContract
   * 4. Submit to API
   *
   * Performance best practice: Always call marketFetcher.getMarket(marketSlug)
   * before createOrder() to cache venue data and avoid additional API requests.
   *
   * @param params - Order parameters
   * @returns Promise resolving to order response
   *
   * @throws Error if order creation fails or venue not found
   *
   * @example
   * ```typescript
   * // Best practice: fetch market first to cache venue
   * const market = await marketFetcher.getMarket('bitcoin-2024');
   *
   * const order = await orderClient.createOrder({
   *   tokenId: market.tokens.yes,
   *   price: 0.65,
   *   size: 100,
   *   side: Side.BUY,
   *   orderType: OrderType.GTC,
   *   marketSlug: 'bitcoin-2024'
   * });
   *
   * console.log(`Order created: ${order.order.id}`);
   * ```
   */
  async createOrder(params) {
    const userData = await this.ensureUserData();
    this.logger.info("Creating order", {
      side: params.side,
      orderType: params.orderType,
      marketSlug: params.marketSlug
    });
    let venue = this.marketFetcher.getVenue(params.marketSlug);
    if (!venue) {
      this.logger.warn(
        "Venue not cached, fetching market details. For better performance, call marketFetcher.getMarket() before createOrder().",
        { marketSlug: params.marketSlug }
      );
      const market = await this.marketFetcher.getMarket(params.marketSlug);
      if (!market.venue) {
        throw new Error(
          `Market ${params.marketSlug} does not have venue information. Venue data is required for order signing.`
        );
      }
      venue = market.venue;
    }
    const dynamicSigningConfig = {
      ...this.signingConfig,
      contractAddress: venue.exchange
    };
    this.logger.debug("Using venue for order signing", {
      marketSlug: params.marketSlug,
      exchange: venue.exchange,
      adapter: venue.adapter
    });
    const unsignedOrder = this.orderBuilder.buildOrder(params);
    this.logger.debug("Built unsigned order", {
      salt: unsignedOrder.salt,
      makerAmount: unsignedOrder.makerAmount,
      takerAmount: unsignedOrder.takerAmount
    });
    const signature = await this.orderSigner.signOrder(unsignedOrder, dynamicSigningConfig);
    const payload = {
      order: {
        ...unsignedOrder,
        signature
      },
      orderType: params.orderType,
      marketSlug: params.marketSlug,
      ownerId: userData.userId
    };
    this.logger.debug("Submitting order to API", payload);
    const apiResponse = await this.httpClient.post("/orders", payload);
    this.logger.info("Order created successfully", {
      orderId: apiResponse.order.id
    });
    return this.transformOrderResponse(apiResponse);
  }
  /**
   * Transforms raw API response to clean OrderResponse DTO.
   *
   * @param apiResponse - Raw API response with nested objects
   * @returns Clean OrderResponse with only essential fields
   *
   * @internal
   */
  transformOrderResponse(apiResponse) {
    const cleanOrder = {
      order: {
        id: apiResponse.order.id,
        createdAt: apiResponse.order.createdAt,
        makerAmount: apiResponse.order.makerAmount,
        takerAmount: apiResponse.order.takerAmount,
        expiration: apiResponse.order.expiration,
        signatureType: apiResponse.order.signatureType,
        salt: apiResponse.order.salt,
        maker: apiResponse.order.maker,
        signer: apiResponse.order.signer,
        taker: apiResponse.order.taker,
        tokenId: apiResponse.order.tokenId,
        side: apiResponse.order.side,
        feeRateBps: apiResponse.order.feeRateBps,
        nonce: apiResponse.order.nonce,
        signature: apiResponse.order.signature,
        orderType: apiResponse.order.orderType,
        price: apiResponse.order.price,
        marketId: apiResponse.order.marketId
      }
    };
    if (apiResponse.makerMatches && apiResponse.makerMatches.length > 0) {
      cleanOrder.makerMatches = apiResponse.makerMatches.map((match) => ({
        id: match.id,
        createdAt: match.createdAt,
        matchedSize: match.matchedSize,
        orderId: match.orderId
      }));
    }
    return cleanOrder;
  }
  /**
   * Cancels an existing order by ID.
   *
   * @param orderId - Order ID to cancel
   * @returns Promise resolving to cancellation message
   *
   * @throws Error if cancellation fails
   *
   * @example
   * ```typescript
   * const result = await orderClient.cancel('order-id-123');
   * console.log(result.message); // "Order canceled successfully"
   * ```
   */
  async cancel(orderId) {
    this.logger.info("Cancelling order", { orderId });
    const response = await this.httpClient.delete(`/orders/${orderId}`);
    this.logger.info("Order cancellation response", {
      orderId,
      message: response.message
    });
    return response;
  }
  /**
   * Cancels all orders for a specific market.
   *
   * @param marketSlug - Market slug to cancel all orders for
   * @returns Promise resolving to cancellation message
   *
   * @throws Error if cancellation fails
   *
   * @example
   * ```typescript
   * const result = await orderClient.cancelAll('market-slug-123');
   * console.log(result.message); // "Orders canceled successfully"
   * ```
   */
  async cancelAll(marketSlug) {
    this.logger.info("Cancelling all orders for market", { marketSlug });
    const response = await this.httpClient.delete(`/orders/all/${marketSlug}`);
    this.logger.info("All orders cancellation response", {
      marketSlug,
      message: response.message
    });
    return response;
  }
  /**
   * Builds an unsigned order without submitting.
   *
   * @remarks
   * Useful for advanced use cases where you need the unsigned order
   * before signing and submission.
   *
   * @param params - Order parameters
   * @returns Promise resolving to unsigned order
   *
   * @example
   * ```typescript
   * const unsignedOrder = await orderClient.buildUnsignedOrder({
   *   tokenId: '123456',
   *   price: 0.65,
   *   size: 100,
   *   side: Side.BUY
   * });
   * ```
   */
  async buildUnsignedOrder(params) {
    await this.ensureUserData();
    return this.orderBuilder.buildOrder(params);
  }
  /**
   * Signs an unsigned order without submitting.
   *
   * @remarks
   * Useful for advanced use cases where you need to inspect
   * the signature before submission.
   *
   * @param order - Unsigned order to sign
   * @returns Promise resolving to signature
   *
   * @example
   * ```typescript
   * const signature = await orderClient.signOrder(unsignedOrder);
   * ```
   */
  async signOrder(order) {
    return await this.orderSigner.signOrder(order, this.signingConfig);
  }
  /**
   * Gets the wallet address.
   *
   * @returns Ethereum address of the wallet
   *
   * @example
   * ```typescript
   * const address = orderClient.walletAddress;
   * console.log(`Wallet: ${address}`);
   * ```
   */
  get walletAddress() {
    return this.wallet.address;
  }
  /**
   * Gets the owner ID (user ID from profile).
   *
   * @returns Owner ID from user profile, or undefined if not yet loaded
   *
   * @example
   * ```typescript
   * const ownerId = orderClient.ownerId;
   * if (ownerId) {
   *   console.log(`Owner ID: ${ownerId}`);
   * }
   * ```
   */
  get ownerId() {
    return this.cachedUserData?.userId;
  }
};

// src/websocket/client.ts
var import_socket = require("socket.io-client");
var WebSocketClient = class {
  /**
   * Creates a new WebSocket client.
   *
   * @param config - WebSocket configuration
   * @param logger - Optional logger for debugging
   */
  constructor(config = {}, logger) {
    this.socket = null;
    this.state = "disconnected" /* DISCONNECTED */;
    this.reconnectAttempts = 0;
    this.subscriptions = /* @__PURE__ */ new Map();
    this.pendingListeners = [];
    this.config = {
      url: config.url || DEFAULT_WS_URL,
      apiKey: config.apiKey || process.env.LIMITLESS_API_KEY || "",
      autoReconnect: config.autoReconnect ?? true,
      reconnectDelay: config.reconnectDelay || 1e3,
      maxReconnectAttempts: config.maxReconnectAttempts || Infinity,
      timeout: config.timeout || 1e4
    };
    this.logger = logger || new NoOpLogger();
  }
  /**
   * Gets current connection state.
   *
   * @returns Current WebSocket state
   */
  getState() {
    return this.state;
  }
  /**
   * Checks if client is connected.
   *
   * @returns True if connected
   */
  isConnected() {
    return this.state === "connected" /* CONNECTED */ && this.socket?.connected === true;
  }
  /**
   * Sets the API key for authentication.
   *
   * @param apiKey - API key value
   *
   * @remarks
   * API key is required for authenticated subscriptions (positions, transactions).
   * If already connected, this will trigger a reconnection with the new API key.
   */
  setApiKey(apiKey) {
    this.config.apiKey = apiKey;
    if (this.socket?.connected) {
      this.logger.info("API key updated, reconnecting...");
      this.reconnectWithNewAuth();
    }
  }
  /**
   * Reconnects with new authentication credentials.
   * @internal
   */
  async reconnectWithNewAuth() {
    await this.disconnect();
    await this.connect();
  }
  /**
   * Connects to the WebSocket server.
   *
   * @returns Promise that resolves when connected
   * @throws Error if connection fails
   *
   * @example
   * ```typescript
   * await wsClient.connect();
   * console.log('Connected!');
   * ```
   */
  async connect() {
    if (this.socket?.connected || this.state === "connecting" /* CONNECTING */) {
      this.logger.info("Already connected or connecting");
      return;
    }
    this.logger.info("Connecting to WebSocket", { url: this.config.url });
    this.state = "connecting" /* CONNECTING */;
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error(`Connection timeout after ${this.config.timeout}ms`));
      }, this.config.timeout);
      const wsUrl = this.config.url;
      const socketOptions = {
        transports: ["websocket"],
        // Use WebSocket transport only
        reconnection: this.config.autoReconnect,
        reconnectionDelay: this.config.reconnectDelay,
        reconnectionDelayMax: Math.min(this.config.reconnectDelay * 32, 6e4),
        // Max 60s
        reconnectionAttempts: this.config.maxReconnectAttempts === Infinity ? 0 : this.config.maxReconnectAttempts,
        // 0 = infinite
        randomizationFactor: 0.2,
        // Add jitter to prevent thundering herd
        timeout: this.config.timeout
      };
      if (this.config.apiKey) {
        socketOptions.extraHeaders = {
          "X-API-Key": this.config.apiKey
        };
      }
      this.socket = (0, import_socket.io)(wsUrl + "/markets", socketOptions);
      this.attachPendingListeners();
      this.setupEventHandlers();
      this.socket.once("connect", () => {
        clearTimeout(timeout);
        this.state = "connected" /* CONNECTED */;
        this.reconnectAttempts = 0;
        this.logger.info("WebSocket connected");
        this.resubscribeAll();
        resolve();
      });
      this.socket.once("connect_error", (error) => {
        clearTimeout(timeout);
        this.state = "error" /* ERROR */;
        this.logger.error("WebSocket connection error", error);
        reject(error);
      });
    });
  }
  /**
   * Disconnects from the WebSocket server.
   *
   * @returns Promise that resolves when disconnected
   *
   * @example
   * ```typescript
   * await wsClient.disconnect();
   * ```
   */
  async disconnect() {
    if (!this.socket) {
      return;
    }
    this.logger.info("Disconnecting from WebSocket");
    this.socket.disconnect();
    this.socket = null;
    this.state = "disconnected" /* DISCONNECTED */;
    this.subscriptions.clear();
  }
  /**
   * Subscribes to a channel.
   *
   * @param channel - Channel to subscribe to
   * @param options - Subscription options
   * @returns Promise that resolves immediately (kept async for API compatibility)
   * @throws Error if not connected
   *
   * @example
   * ```typescript
   * // Subscribe to orderbook for a specific market
   * await wsClient.subscribe('orderbook', { marketSlugs: ['market-123'] });
   *
   * // Subscribe to all trades
   * await wsClient.subscribe('trades');
   *
   * // Subscribe to your orders
   * await wsClient.subscribe('orders');
   * ```
   */
  async subscribe(channel, options = {}) {
    if (!this.isConnected()) {
      throw new Error("WebSocket not connected. Call connect() first.");
    }
    const authenticatedChannels = [
      "subscribe_positions",
      "subscribe_transactions"
    ];
    if (authenticatedChannels.includes(channel) && !this.config.apiKey) {
      throw new Error(
        `API key is required for '${channel}' subscription. Please provide an API key in the constructor or set LIMITLESS_API_KEY environment variable. You can generate an API key at https://limitless.exchange`
      );
    }
    const subscriptionKey = this.getSubscriptionKey(channel, options);
    this.subscriptions.set(subscriptionKey, options);
    this.logger.info("Subscribing to channel", { channel, options });
    this.socket.emit(channel, options);
    this.logger.info("Subscription request sent", { channel, options });
  }
  /**
   * Unsubscribes from a channel.
   *
   * @param channel - Channel to unsubscribe from
   * @param options - Subscription options (must match subscribe call)
   * @returns Promise that resolves when unsubscribed
   * @throws Error if not connected or unsubscribe fails
   *
   * @example
   * ```typescript
   * await wsClient.unsubscribe('orderbook', { marketSlugs: ['market-123'] });
   * ```
   */
  async unsubscribe(channel, options = {}) {
    if (!this.isConnected()) {
      throw new Error("WebSocket not connected");
    }
    const subscriptionKey = this.getSubscriptionKey(channel, options);
    this.subscriptions.delete(subscriptionKey);
    this.logger.info("Unsubscribing from channel", { channel, options });
    try {
      const unsubscribeData = { channel, ...options };
      const response = await this.socket.timeout(5e3).emitWithAck("unsubscribe", unsubscribeData);
      if (response && typeof response === "object" && "error" in response) {
        const errorMsg = response.error;
        this.logger.error("Unsubscribe failed", new Error(errorMsg), { error: errorMsg });
        throw new Error(`Unsubscribe failed: ${errorMsg}`);
      }
      this.logger.info("Unsubscribed successfully", { channel, options });
    } catch (error) {
      this.logger.error("Unsubscribe error", error, { channel });
      throw error;
    }
  }
  /**
   * Registers an event listener.
   *
   * @param event - Event name
   * @param handler - Event handler
   * @returns This client for chaining
   *
   * @example
   * ```typescript
   * wsClient
   *   .on('orderbook', (data) => console.log('Orderbook:', data))
   *   .on('trade', (data) => console.log('Trade:', data))
   *   .on('error', (error) => console.error('Error:', error));
   * ```
   */
  on(event, handler) {
    if (!this.socket) {
      this.pendingListeners.push({ event, handler });
      return this;
    }
    this.socket.on(event, handler);
    return this;
  }
  /**
   * Registers a one-time event listener.
   *
   * @param event - Event name
   * @param handler - Event handler
   * @returns This client for chaining
   */
  once(event, handler) {
    if (!this.socket) {
      throw new Error("WebSocket not initialized. Call connect() first.");
    }
    this.socket.once(event, handler);
    return this;
  }
  /**
   * Removes an event listener.
   *
   * @param event - Event name
   * @param handler - Event handler to remove (if undefined, removes all handlers for event)
   * @returns This client for chaining
   *
   * @example
   * ```typescript
   * // Remove specific handler
   * wsClient.off('orderbookUpdate', myHandler);
   *
   * // Remove all handlers for event
   * wsClient.off('orderbookUpdate');
   * ```
   */
  off(event, handler) {
    if (!this.socket) {
      return this;
    }
    if (handler === void 0) {
      this.socket.removeAllListeners(event);
    } else {
      this.socket.off(event, handler);
    }
    return this;
  }
  /**
   * Attach any pending event listeners that were added before connect().
   * @internal
   */
  attachPendingListeners() {
    if (!this.socket || this.pendingListeners.length === 0) {
      return;
    }
    for (const { event, handler } of this.pendingListeners) {
      this.socket.on(event, handler);
    }
    this.pendingListeners = [];
  }
  /**
   * Setup internal event handlers for connection management.
   * @internal
   */
  setupEventHandlers() {
    if (!this.socket) {
      return;
    }
    this.socket.on("connect", () => {
      this.state = "connected" /* CONNECTED */;
      this.reconnectAttempts = 0;
      this.logger.info("WebSocket connected");
    });
    this.socket.on("disconnect", (reason) => {
      this.state = "disconnected" /* DISCONNECTED */;
      this.logger.info("WebSocket disconnected", { reason });
    });
    this.socket.on("error", (error) => {
      this.state = "error" /* ERROR */;
      this.logger.error("WebSocket error", error);
    });
    this.socket.io.on("reconnect_attempt", (attempt) => {
      this.state = "reconnecting" /* RECONNECTING */;
      this.reconnectAttempts = attempt;
      this.logger.info("Reconnecting...", { attempt });
    });
    this.socket.io.on("reconnect", (attempt) => {
      this.state = "connected" /* CONNECTED */;
      this.logger.info("Reconnected", { attempts: attempt });
      this.resubscribeAll();
    });
    this.socket.io.on("reconnect_error", (error) => {
      this.logger.error("Reconnection error", error);
    });
    this.socket.io.on("reconnect_failed", () => {
      this.state = "error" /* ERROR */;
      this.logger.error("Reconnection failed");
    });
  }
  /**
   * Re-subscribes to all previous subscriptions after reconnection.
   * @internal
   */
  async resubscribeAll() {
    if (this.subscriptions.size === 0) {
      return;
    }
    this.logger.info("Re-subscribing to channels", {
      count: this.subscriptions.size
    });
    for (const [key, options] of this.subscriptions.entries()) {
      const channel = this.getChannelFromKey(key);
      try {
        await this.subscribe(channel, options);
      } catch (error) {
        this.logger.error("Failed to re-subscribe", error, { channel, options });
      }
    }
  }
  /**
   * Creates a unique subscription key.
   * @internal
   */
  getSubscriptionKey(channel, options) {
    return `${channel}:${options.marketSlug || "global"}`;
  }
  /**
   * Extracts channel from subscription key.
   * @internal
   */
  getChannelFromKey(key) {
    return key.split(":")[0];
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  APIError,
  AuthenticationError,
  BASE_SEPOLIA_CHAIN_ID,
  CONTRACT_ADDRESSES,
  ConsoleLogger,
  DEFAULT_API_URL,
  DEFAULT_CHAIN_ID,
  DEFAULT_WS_URL,
  HttpClient,
  Market,
  MarketFetcher,
  NoOpLogger,
  OrderBuilder,
  OrderClient,
  OrderSigner,
  OrderType,
  OrderValidationError,
  PortfolioFetcher,
  RateLimitError,
  RetryConfig,
  RetryableClient,
  SIGNING_MESSAGE_TEMPLATE,
  Side,
  SignatureType,
  ValidationError,
  WebSocketClient,
  WebSocketState,
  ZERO_ADDRESS,
  getContractAddress,
  retryOnErrors,
  validateOrderArgs,
  validateSignedOrder,
  validateUnsignedOrder,
  withRetry
});
//# sourceMappingURL=index.js.map