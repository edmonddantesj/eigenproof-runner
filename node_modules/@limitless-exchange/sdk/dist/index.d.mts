import { AxiosRequestConfig } from 'axios';
import { ethers } from 'ethers';

/**
 * Trading mode for user interface.
 * @public
 */
type TradingMode = 'SIMPLE' | 'ADVANCED';
/**
 * User rank information.
 * @public
 */
interface UserRank {
    /**
     * Rank ID
     */
    id: number;
    /**
     * Rank name
     */
    name: string;
    /**
     * Fee rate in basis points
     */
    feeRateBps: number;
}
/**
 * Referral data for a user.
 * @public
 */
interface ReferralData {
    /**
     * Referral creation timestamp
     */
    createdAt: string;
    /**
     * Referral ID
     */
    id: number;
    /**
     * Referred user's profile ID
     */
    referredProfileId: number;
    /**
     * Profile picture URL
     */
    pfpUrl: string | null;
    /**
     * Display name
     */
    displayName: string;
}
/**
 * User profile information (1:1 with API response).
 * @public
 */
interface UserProfile {
    /**
     * User ID (used as ownerId for orders)
     */
    id: number;
    /**
     * User's Ethereum address
     */
    account: string;
    /**
     * User rank information containing feeRateBps
     */
    rank?: UserRank;
    /**
     * Account creation timestamp
     */
    createdAt?: string;
    /**
     * Username
     */
    username?: string;
    /**
     * Display name for the user
     */
    displayName?: string;
    /**
     * Profile picture URL
     */
    pfpUrl?: string;
    /**
     * User bio
     */
    bio?: string;
    /**
     * Social media URL
     */
    socialUrl?: string;
    /**
     * Trade wallet option
     */
    tradeWalletOption?: string;
    /**
     * Embedded account address
     */
    embeddedAccount?: string;
    /**
     * Total points
     */
    points?: number;
    /**
     * Accumulative points
     */
    accumulativePoints?: number;
    /**
     * Whether enrolled in points program
     */
    enrolledInPointsProgram?: boolean;
    /**
     * Position on leaderboard
     */
    leaderboardPosition?: number;
    /**
     * Whether user is in top 100
     */
    isTop100?: boolean;
    /**
     * Whether user is a captain
     */
    isCaptain?: boolean;
    /**
     * List of referral information
     */
    referralData?: ReferralData[];
    /**
     * Count of referred users
     */
    referredUsersCount?: number;
}
/**
 * Mode information from authentication response.
 * @public
 */
interface ModeInfo {
    /**
     * Trading interface mode
     */
    mode: TradingMode;
    /**
     * Whether the user is new to the platform
     */
    isUserNew: boolean;
}
/**
 * User data for order operations.
 *
 * @remarks
 * Contains user-specific information needed for creating orders.
 *
 * @public
 */
interface UserData {
    /**
     * User ID (owner ID) from the API
     */
    userId: number;
    /**
     * Fee rate in basis points for this user
     * Common values: 100 (1%), 200 (2%), 300 (3%)
     */
    feeRateBps: number;
}

/**
 * Logger interface for SDK integration.
 * Allows users to inject their own logging implementation.
 *
 * @public
 */
interface ILogger {
    /**
     * Log debug information (verbose, development only)
     */
    debug(message: string, meta?: Record<string, any>): void;
    /**
     * Log informational messages
     */
    info(message: string, meta?: Record<string, any>): void;
    /**
     * Log warning messages
     */
    warn(message: string, meta?: Record<string, any>): void;
    /**
     * Log error messages
     */
    error(message: string, error?: Error, meta?: Record<string, any>): void;
}
/**
 * No-op logger (default) - does nothing.
 * Zero performance overhead when logging is not needed.
 *
 * @internal
 */
declare class NoOpLogger implements ILogger {
    debug(): void;
    info(): void;
    warn(): void;
    error(): void;
}
/**
 * Simple console logger for development.
 * Can be used as a starting point or for debugging.
 *
 * @example
 * ```typescript
 * import { ConsoleLogger } from '@limitless-exchange/sdk';
 *
 * const logger = new ConsoleLogger('debug');
 * const authenticator = new Authenticator(httpClient, signer, logger);
 * ```
 *
 * @public
 */
declare class ConsoleLogger implements ILogger {
    private level;
    constructor(level?: 'debug' | 'info' | 'warn' | 'error');
    private shouldLog;
    debug(message: string, meta?: Record<string, any>): void;
    info(message: string, meta?: Record<string, any>): void;
    warn(message: string, meta?: Record<string, any>): void;
    error(message: string, error?: Error, meta?: Record<string, any>): void;
}

/**
 * Order-related types for Limitless Exchange.
 * @module types/orders
 */
/**
 * Order side enum.
 * @public
 */
declare enum Side {
    BUY = 0,
    SELL = 1
}
/**
 * Order type enum.
 * @public
 */
declare enum OrderType {
    /** Fill-or-Kill: Execute immediately or cancel */
    FOK = "FOK",
    /** Good-Til-Cancelled: Remain on orderbook until filled or cancelled */
    GTC = "GTC"
}
/**
 * Signature type enum.
 * @public
 */
declare enum SignatureType {
    /** Externally Owned Account */
    EOA = 0,
    /** Polymarket Proxy */
    POLY_PROXY = 1,
    /** Polymarket Gnosis Safe */
    POLY_GNOSIS_SAFE = 2
}
/**
 * Base arguments shared by all order types.
 * @public
 */
interface BaseOrderArgs {
    /**
     * Token ID for the outcome
     */
    tokenId: string;
    /**
     * Order side (BUY or SELL)
     */
    side: Side;
    /**
     * Expiration timestamp (0 for no expiration)
     * @defaultValue '0'
     */
    expiration?: string;
    /**
     * Nonce for order replay protection
     * @defaultValue 0
     */
    nonce?: number;
    /**
     * Taker address (ZERO_ADDRESS for any taker)
     * @defaultValue '0x0000000000000000000000000000000000000000'
     */
    taker?: string;
}
/**
 * Arguments for FOK (Fill-or-Kill) market orders.
 *
 * @remarks
 * FOK orders are market orders that execute immediately at the best available price.
 * Specify the maker amount (human-readable, max 6 decimals).
 *
 * For BUY orders: Amount in USDC to spend (e.g., 50.0 = spend $50 USDC)
 * For SELL orders: Number of shares to sell (e.g., 18.64 = sell 18.64 shares)
 *
 * @example
 * ```typescript
 * // BUY: Spend 50 USDC
 * {
 *   tokenId: '123...',
 *   makerAmount: 50,      // Spend $50 USDC
 *   side: Side.BUY
 * }
 *
 * // SELL: Sell 18.64 shares
 * {
 *   tokenId: '123...',
 *   makerAmount: 18.64,   // Sell 18.64 shares
 *   side: Side.SELL
 * }
 * ```
 *
 * @public
 */
interface FOKOrderArgs extends BaseOrderArgs {
    /**
     * Maker amount (human-readable, max 6 decimals)
     *
     * For BUY orders: Amount of USDC to spend
     * For SELL orders: Number of shares to sell
     *
     * @example
     * // BUY examples
     * 50 = Spend $50 USDC
     * 1.5 = Spend $1.50 USDC
     * 0.75 = Spend $0.75 USDC
     *
     * // SELL examples
     * 18.64 = Sell 18.64 shares
     * 44.111 = Sell 44.111 shares
     */
    makerAmount: number;
}
/**
 * Arguments for GTC (Good-Til-Cancelled) limit orders.
 *
 * @remarks
 * GTC orders are limit orders that remain on the orderbook until filled or cancelled.
 * You specify the price and number of shares.
 *
 * @example
 * ```typescript
 * // BUY: Buy 10 shares at 0.65 price
 * {
 *   tokenId: '123...',
 *   price: 0.65,
 *   size: 10,
 *   side: Side.BUY
 * }
 *
 * // SELL: Sell 5 shares at 0.75 price
 * {
 *   tokenId: '123...',
 *   price: 0.75,
 *   size: 5,
 *   side: Side.SELL
 * }
 * ```
 *
 * @public
 */
interface GTCOrderArgs extends BaseOrderArgs {
    /**
     * Price per share (0.0 to 1.0)
     */
    price: number;
    /**
     * Number of shares to trade
     */
    size: number;
}
/**
 * Union type for all order arguments.
 * @public
 */
type OrderArgs = FOKOrderArgs | GTCOrderArgs;
/**
 * Unsigned order payload.
 * @public
 */
interface UnsignedOrder {
    /**
     * Unique salt for order identification
     */
    salt: number;
    /**
     * Maker address (order creator)
     */
    maker: string;
    /**
     * Signer address (must match maker for EOA)
     */
    signer: string;
    /**
     * Taker address (ZERO_ADDRESS for any taker)
     */
    taker: string;
    /**
     * Token ID for the outcome
     */
    tokenId: string;
    /**
     * Maker amount in USDC units (6 decimals)
     */
    makerAmount: number;
    /**
     * Taker amount in USDC units (6 decimals)
     */
    takerAmount: number;
    /**
     * Expiration timestamp (0 for no expiration)
     */
    expiration: string;
    /**
     * Nonce for replay protection
     */
    nonce: number;
    /**
     * Fee rate in basis points
     */
    feeRateBps: number;
    /**
     * Order side (BUY or SELL)
     */
    side: Side;
    /**
     * Signature type (EOA, POLY_PROXY, etc.)
     */
    signatureType: SignatureType;
    /**
     * Price per share (required for GTC orders)
     */
    price?: number;
}
/**
 * Signed order payload.
 * @public
 */
interface SignedOrder extends UnsignedOrder {
    /**
     * EIP-712 signature
     */
    signature: string;
}
/**
 * Complete order payload for API submission.
 * @public
 */
interface NewOrderPayload {
    /**
     * Signed order details
     */
    order: SignedOrder;
    /**
     * Order type (FOK or GTC)
     */
    orderType: OrderType;
    /**
     * Market slug identifier
     */
    marketSlug: string;
    /**
     * Owner ID from user profile
     */
    ownerId: number;
}
/**
 * Clean order data returned from API.
 *
 * @remarks
 * This is a minimal, user-friendly representation of an order
 * that excludes unnecessary API metadata.
 *
 * @public
 */
interface CreatedOrder {
    /**
     * Order database ID
     */
    id: string;
    /**
     * Creation timestamp (ISO 8601)
     */
    createdAt: string;
    /**
     * Maker amount (USDC units with 6 decimals)
     */
    makerAmount: number;
    /**
     * Taker amount (USDC units with 6 decimals)
     */
    takerAmount: number;
    /**
     * Expiration timestamp (null for no expiration)
     */
    expiration: string | null;
    /**
     * Signature type (0 = EOA, 1 = Polymarket Proxy, 2 = Gnosis Safe)
     */
    signatureType: number;
    /**
     * Unique salt for order identification
     */
    salt: number;
    /**
     * Maker address
     */
    maker: string;
    /**
     * Signer address
     */
    signer: string;
    /**
     * Taker address (zero address for any taker)
     */
    taker: string;
    /**
     * Token ID for the outcome
     */
    tokenId: string;
    /**
     * Order side (0 = BUY, 1 = SELL)
     */
    side: Side;
    /**
     * Fee rate in basis points
     */
    feeRateBps: number;
    /**
     * Nonce for replay protection
     */
    nonce: number;
    /**
     * EIP-712 signature
     */
    signature: string;
    /**
     * Order type (GTC or FOK)
     */
    orderType: string;
    /**
     * Price per share (0.0 to 1.0) - only for GTC orders
     */
    price: number | null;
    /**
     * Market database ID
     */
    marketId: number;
}
/**
 * Match information for filled orders.
 *
 * @remarks
 * When a FOK order is filled or a GTC order is partially matched,
 * this provides minimal information about the match.
 *
 * @public
 */
interface OrderMatch {
    /**
     * Match database ID
     */
    id: string;
    /**
     * Creation timestamp (ISO 8601)
     */
    createdAt: string;
    /**
     * Matched size (USDC units with 6 decimals)
     */
    matchedSize: string;
    /**
     * Matched order ID
     */
    orderId: string;
}
/**
 * Clean order creation response.
 *
 * @remarks
 * This is what users receive after successfully creating an order.
 * For GTC orders, makerMatches will be undefined or empty.
 * For FOK orders, makerMatches contains the fills.
 *
 * @public
 */
interface OrderResponse {
    /**
     * Created order data
     */
    order: CreatedOrder;
    /**
     * Matches if order was filled (FOK) or partially matched (GTC)
     */
    makerMatches?: OrderMatch[];
}
/**
 * Order signing configuration.
 * @public
 */
interface OrderSigningConfig {
    /**
     * Blockchain chain ID
     */
    chainId: number;
    /**
     * Contract address for verification (from venue.exchange)
     */
    contractAddress: string;
}

/**
 * Portfolio and position types for Limitless Exchange.
 * @module types/portfolio
 */
/**
 * Market information for a position.
 *
 * @public
 */
interface PositionMarket {
    /**
     * Market ID
     */
    id: number | string;
    /**
     * Market slug
     */
    slug: string;
    /**
     * Market title
     */
    title: string;
    /**
     * Market status
     */
    status?: string;
    /**
     * Whether market is closed
     */
    closed: boolean;
    /**
     * Market deadline
     */
    deadline: string;
    /**
     * Condition ID
     */
    conditionId?: string;
    /**
     * Winning outcome index (null if unresolved)
     */
    winningOutcomeIndex?: number | null;
    /**
     * Market group information
     */
    group?: {
        slug?: string;
        title?: string;
    };
}
/**
 * Position details for YES or NO side.
 *
 * @public
 */
interface PositionSide {
    /**
     * Cost basis (6 decimals)
     */
    cost: string;
    /**
     * Fill price (6 decimals for CLOB, decimal string for AMM)
     */
    fillPrice: string;
    /**
     * Current market value (6 decimals)
     */
    marketValue: string;
    /**
     * Realized P&L (6 decimals)
     */
    realisedPnl: string;
    /**
     * Unrealized P&L (6 decimals)
     */
    unrealizedPnl: string;
}
/**
 * Token balance for YES or NO side.
 *
 * @public
 */
interface TokenBalance {
    /**
     * YES token balance (6 decimals)
     */
    yes: string;
    /**
     * NO token balance (6 decimals)
     */
    no: string;
}
/**
 * Latest trade information.
 *
 * @public
 */
interface LatestTrade {
    /**
     * Latest YES price (0.0 to 1.0)
     */
    latestYesPrice: number;
    /**
     * Latest NO price (0.0 to 1.0)
     */
    latestNoPrice: number;
    /**
     * Outcome token price (0.0 to 1.0)
     */
    outcomeTokenPrice: number;
}
/**
 * CLOB (Central Limit Order Book) position.
 *
 * @public
 */
interface CLOBPosition {
    /**
     * Market information
     */
    market: PositionMarket;
    /**
     * User's wallet address
     */
    makerAddress: string;
    /**
     * Position details for YES and NO sides
     */
    positions: {
        yes: PositionSide;
        no: PositionSide;
    };
    /**
     * Token balances
     */
    tokensBalance: TokenBalance;
    /**
     * Latest trade information
     */
    latestTrade: LatestTrade;
    /**
     * Active orders information
     */
    orders?: {
        liveOrders: any[];
        totalCollateralLocked: string;
    };
    /**
     * Rewards information
     */
    rewards?: {
        epochs: any[];
        isEarning: boolean;
    };
}
/**
 * AMM (Automated Market Maker) position.
 *
 * @public
 */
interface AMMPosition {
    /**
     * Market information
     */
    market: PositionMarket;
    /**
     * User's wallet address
     */
    account: string;
    /**
     * Outcome index (0 for YES, 1 for NO)
     */
    outcomeIndex: number;
    /**
     * Collateral amount (decimal string)
     */
    collateralAmount: string;
    /**
     * Outcome token amount (decimal string)
     */
    outcomeTokenAmount: string;
    /**
     * Average fill price (decimal string)
     */
    averageFillPrice: string;
    /**
     * Total buys cost (decimal string)
     */
    totalBuysCost: string;
    /**
     * Total sells cost (decimal string)
     */
    totalSellsCost: string;
    /**
     * Realized P&L (decimal string)
     */
    realizedPnl: string;
    /**
     * Unrealized P&L (decimal string)
     */
    unrealizedPnl: string;
    /**
     * Latest trade information
     */
    latestTrade?: {
        outcomeTokenPrice: string;
    };
}
/**
 * API response for /portfolio/positions endpoint.
 *
 * @public
 */
interface PortfolioPositionsResponse {
    /**
     * AMM positions
     */
    amm: AMMPosition[];
    /**
     * CLOB positions
     */
    clob: CLOBPosition[];
    /**
     * Group positions
     */
    group: any[];
    /**
     * User points
     */
    points?: string;
    /**
     * Accumulative points
     */
    accumulativePoints?: string;
    /**
     * Rewards information
     */
    rewards?: {
        todaysRewards: string;
        rewardsByEpoch: any[];
        rewardsChartData: any[];
        totalUnpaidRewards: string;
        totalUserRewardsLastEpoch: string;
    };
}
/**
 * Simplified position for unified view.
 *
 * @public
 */
interface Position {
    /**
     * Position type
     */
    type: 'CLOB' | 'AMM';
    /**
     * Market information
     */
    market: PositionMarket;
    /**
     * Position side (YES or NO)
     */
    side: 'YES' | 'NO';
    /**
     * Cost basis in USDC (6 decimals)
     */
    costBasis: number;
    /**
     * Current market value in USDC (6 decimals)
     */
    marketValue: number;
    /**
     * Unrealized P&L in USDC (6 decimals)
     */
    unrealizedPnl: number;
    /**
     * Realized P&L in USDC (6 decimals)
     */
    realizedPnl: number;
    /**
     * Current price (0.0 to 1.0)
     */
    currentPrice: number;
    /**
     * Average entry price (0.0 to 1.0)
     */
    avgPrice: number;
    /**
     * Token balance (6 decimals)
     */
    tokenBalance: number;
}
/**
 * Portfolio summary statistics.
 *
 * @public
 */
interface PortfolioSummary {
    /**
     * Total portfolio value in USDC (6 decimals)
     */
    totalValue: number;
    /**
     * Total cost basis in USDC (6 decimals)
     */
    totalCostBasis: number;
    /**
     * Total unrealized P&L in USDC (6 decimals)
     */
    totalUnrealizedPnl: number;
    /**
     * Total realized P&L in USDC (6 decimals)
     */
    totalRealizedPnl: number;
    /**
     * Total unrealized P&L percentage
     */
    totalUnrealizedPnlPercent: number;
    /**
     * Number of open positions
     */
    positionCount: number;
    /**
     * Number of markets with positions
     */
    marketCount: number;
    /**
     * Breakdown by position type
     */
    breakdown: {
        clob: {
            positions: number;
            value: number;
            pnl: number;
        };
        amm: {
            positions: number;
            value: number;
            pnl: number;
        };
    };
}
/**
 * User history entry.
 *
 * Represents various types of user actions:
 * - AMM trades
 * - CLOB trades
 * - Token splits/merges
 * - NegRisk conversions
 *
 * @public
 */
interface HistoryEntry {
    /**
     * Entry ID
     */
    id: string;
    /**
     * Entry type (trade, split, merge, conversion, etc.)
     */
    type: string;
    /**
     * Entry creation timestamp
     */
    createdAt: string;
    /**
     * Associated market slug
     */
    marketSlug?: string;
    /**
     * Transaction amount
     */
    amount?: string;
    /**
     * Additional entry details
     */
    details?: Record<string, any>;
}
/**
 * Paginated user history response from /portfolio/history endpoint.
 *
 * @public
 */
interface HistoryResponse {
    /**
     * List of history entries
     */
    data: HistoryEntry[];
    /**
     * Total number of entries
     */
    totalCount: number;
}

/**
 * Market-related types for Limitless Exchange.
 * @module types/markets
 */
/**
 * Collateral token information.
 * @public
 */
interface CollateralToken {
    /**
     * Token contract address
     */
    address: string;
    /**
     * Token decimals
     */
    decimals: number;
    /**
     * Token symbol (e.g., "USDC")
     */
    symbol: string;
}
/**
 * Market creator information.
 * @public
 */
interface MarketCreator {
    /**
     * Creator name
     */
    name: string;
    /**
     * Creator image URL
     */
    imageURI?: string;
    /**
     * Creator link URL
     */
    link?: string;
}
/**
 * Market metadata.
 * @public
 */
interface MarketMetadata {
    /**
     * Fee enabled flag
     */
    fee: boolean;
    /**
     * Banner flag
     */
    isBannered?: boolean;
    /**
     * Polymarket arbitrage flag
     */
    isPolyArbitrage?: boolean;
    /**
     * Market making flag
     */
    shouldMarketMake?: boolean;
    /**
     * Opening price for oracle markets
     */
    openPrice?: string;
}
/**
 * Market settings for CLOB markets.
 * @public
 */
interface MarketSettings {
    /**
     * Minimum order size
     */
    minSize: string;
    /**
     * Maximum spread allowed
     */
    maxSpread: number;
    /**
     * Daily reward amount
     */
    dailyReward: string;
    /**
     * Rewards epoch duration
     */
    rewardsEpoch: string;
    /**
     * Constant parameter
     */
    c: string;
}
/**
 * Trade prices for different order types.
 * @public
 */
interface TradePrices {
    /**
     * Buy prices (market and limit) for yes/no tokens
     */
    buy: {
        market: [number, number];
        limit: [number, number];
    };
    /**
     * Sell prices (market and limit) for yes/no tokens
     */
    sell: {
        market: [number, number];
        limit: [number, number];
    };
}
/**
 * Price oracle metadata for oracle-based markets.
 * @public
 */
interface PriceOracleMetadata {
    /**
     * Asset ticker symbol
     */
    ticker: string;
    /**
     * Asset type (e.g., "CRYPTO")
     */
    assetType: string;
    /**
     * Pyth Network price feed address
     */
    pythAddress: string;
    /**
     * Price feed symbol
     */
    symbol: string;
    /**
     * Asset name
     */
    name: string;
    /**
     * Logo URL
     */
    logo: string;
}
/**
 * Orderbook entry (bid or ask).
 * Matches API response format exactly (1:1 parity).
 *
 * @public
 */
interface OrderbookEntry {
    /**
     * Price per share (0-1 range)
     */
    price: number;
    /**
     * Size in shares
     */
    size: number;
    /**
     * Order side ("BUY" or "SELL")
     */
    side: string;
}
/**
 * Complete orderbook for a market.
 * Matches API response format exactly (1:1 parity).
 *
 * @public
 */
interface OrderBook {
    /**
     * Bid orders (buy orders) sorted by price descending
     */
    bids: OrderbookEntry[];
    /**
     * Ask orders (sell orders) sorted by price ascending
     */
    asks: OrderbookEntry[];
    /**
     * Token ID for the orderbook (YES token)
     */
    tokenId: string;
    /**
     * Adjusted midpoint price between best bid and ask
     */
    adjustedMidpoint: number;
    /**
     * Maximum allowed spread for the market
     */
    maxSpread: string;
    /**
     * Minimum order size allowed
     */
    minSize: string;
    /**
     * Last trade price for the market
     */
    lastTradePrice: number;
}
/**
 * Market outcome information.
 * @public
 */
interface MarketOutcome {
    /**
     * Outcome ID
     */
    id: number;
    /**
     * Outcome title
     */
    title: string;
    /**
     * Token ID for this outcome
     */
    tokenId: string;
    /**
     * Current price
     */
    price?: number;
}
/**
 * Venue information for CLOB markets.
 *
 * @remarks
 * Contains contract addresses required for trading:
 * - exchange: Used as verifyingContract for EIP-712 order signing
 * - adapter: Required for NegRisk/Grouped market SELL approvals
 *
 * @public
 */
interface Venue {
    /**
     * Exchange contract address.
     *
     * @remarks
     * This address is used as the verifyingContract in EIP-712 order signing.
     * All BUY orders require USDC approval to this address.
     * Simple CLOB SELL orders require CT approval to this address.
     */
    exchange: string;
    /**
     * Adapter contract address.
     *
     * @remarks
     * Required for NegRisk/Grouped markets only.
     * SELL orders on NegRisk markets require CT approval to both exchange AND adapter.
     */
    adapter: string;
}
/**
 * Market token IDs for CLOB markets.
 * @public
 */
interface MarketTokens {
    yes: string;
    no: string;
}
/**
 * Complete market information (1:1 with API response).
 * Handles both CLOB single markets and NegRisk group markets.
 *
 * @public
 */
interface Market$1 {
    /**
     * Market database ID
     */
    id: number;
    /**
     * Market slug identifier
     */
    slug: string;
    /**
     * Market title
     */
    title: string;
    /**
     * Market proxy title
     */
    proxyTitle: string | null;
    /**
     * Market description
     */
    description?: string;
    /**
     * Collateral token information
     */
    collateralToken: CollateralToken;
    /**
     * Human-readable expiration date
     */
    expirationDate: string;
    /**
     * Expiration timestamp in milliseconds
     */
    expirationTimestamp: number;
    /**
     * Whether market is expired
     */
    expired?: boolean;
    /**
     * Creation timestamp
     */
    createdAt: string;
    /**
     * Last update timestamp
     */
    updatedAt: string;
    /**
     * Market categories
     */
    categories: string[];
    /**
     * Market status
     */
    status: string;
    /**
     * Creator information
     */
    creator: MarketCreator;
    /**
     * Market tags
     */
    tags: string[];
    /**
     * Trade type (clob or amm)
     */
    tradeType: string;
    /**
     * Market type (single or group)
     */
    marketType: string;
    /**
     * Priority index for sorting
     */
    priorityIndex: number;
    /**
     * Market metadata
     */
    metadata: MarketMetadata;
    /**
     * Trading volume
     */
    volume?: string;
    /**
     * Formatted trading volume
     */
    volumeFormatted?: string;
    /**
     * Condition ID (CLOB only)
     */
    conditionId?: string;
    /**
     * NegRisk request ID (CLOB only)
     */
    negRiskRequestId?: string | null;
    /**
     * Token IDs for yes/no outcomes (CLOB only)
     * @example
     * {
     *   yes: "27687694610130623013351012526567944730242898906227824547270172934678693687246",
     *   no: "9288900480010863316984252765488448624297561656655547117581633191173128271467"
     * }
     */
    tokens?: MarketTokens;
    /**
     * Current prices [yes, no] (CLOB only)
     */
    prices?: number[];
    /**
     * Trade prices for buy/sell market/limit orders (CLOB only)
     */
    tradePrices?: TradePrices;
    /**
     * Whether market is rewardable (CLOB only)
     */
    isRewardable?: boolean;
    /**
     * Market settings (CLOB only)
     */
    settings?: MarketSettings;
    /**
     * Venue information for CLOB markets.
     *
     * @remarks
     * Contains exchange and adapter contract addresses for order signing and approvals.
     * The exchange address is used as verifyingContract in EIP-712 signatures.
     *
     * Performance tip: Call getMarket() before createOrder() to cache venue data
     * and avoid additional API requests during order creation.
     */
    venue?: Venue;
    /**
     * Market logo URL
     */
    logo?: string | null;
    /**
     * Price oracle metadata (oracle markets only)
     */
    priceOracleMetadata?: PriceOracleMetadata;
    /**
     * Order within group (group markets only)
     */
    orderInGroup?: number;
    /**
     * Winning outcome index
     */
    winningOutcomeIndex?: number | null;
    /**
     * Outcome token names (group only)
     */
    outcomeTokens?: string[];
    /**
     * OG image URI (group only)
     */
    ogImageURI?: string;
    /**
     * NegRisk market ID (group only)
     */
    negRiskMarketId?: string;
    /**
     * Child markets in group (group only)
     */
    markets?: Market$1[];
    /**
     * Daily reward for group (group only)
     */
    dailyReward?: string;
    /**
     * Market contract address
     * @deprecated Use conditionId instead
     */
    address?: string | null;
    /**
     * Market type (CLOB or AMM)
     * @deprecated Use tradeType instead
     */
    type?: string;
    /**
     * Market outcomes
     * @deprecated Use tokens for CLOB markets
     */
    outcomes?: MarketOutcome[];
    /**
     * Resolution timestamp
     * @deprecated Use expirationTimestamp instead
     */
    resolutionDate?: string;
}
/**
 * Markets list response.
 * @public
 */
interface MarketsResponse {
    /**
     * Array of markets
     */
    markets: Market$1[];
    /**
     * Total count
     */
    total?: number;
    /**
     * Pagination offset
     */
    offset?: number;
    /**
     * Pagination limit
     */
    limit?: number;
}
/**
 * Sort options for active markets.
 * @public
 */
type ActiveMarketsSortBy = 'lp_rewards' | 'ending_soon' | 'newest' | 'high_value' | 'liquidity';
/**
 * Query parameters for active markets endpoint.
 * @public
 */
interface ActiveMarketsParams {
    /**
     * Maximum number of markets to return (max 25)
     * @defaultValue 25
     */
    limit?: number;
    /**
     * Page number for pagination (starts at 1)
     * @defaultValue 1
     */
    page?: number;
    /**
     * Sort order for markets
     */
    sortBy?: ActiveMarketsSortBy;
}
/**
 * Active markets response from API.
 * @public
 */
interface ActiveMarketsResponse {
    /**
     * Array of active markets
     */
    data: Market$1[];
    /**
     * Total count of active markets
     */
    totalMarketsCount: number;
}

/**
 * WebSocket types for real-time data streaming.
 * @module types/websocket
 */

/**
 * WebSocket connection configuration.
 * @public
 */
interface WebSocketConfig {
    /**
     * WebSocket URL (default: wss://ws.limitless.exchange)
     */
    url?: string;
    /**
     * API key for authentication
     *
     * @remarks
     * **Required** for authenticated subscriptions (positions, transactions).
     * Not required for public subscriptions (market prices, orderbook).
     *
     * You can generate an API key at https://limitless.exchange
     * and the LIMITLESS_API_KEY environment variable.
     */
    apiKey?: string;
    /**
     * Auto-reconnect on connection loss (default: true)
     */
    autoReconnect?: boolean;
    /**
     * Reconnection delay in ms (default: 1000)
     */
    reconnectDelay?: number;
    /**
     * Maximum reconnection attempts (default: Infinity)
     */
    maxReconnectAttempts?: number;
    /**
     * Connection timeout in ms (default: 10000)
     */
    timeout?: number;
}
/**
 * WebSocket connection state.
 * @public
 */
declare enum WebSocketState {
    DISCONNECTED = "disconnected",
    CONNECTING = "connecting",
    CONNECTED = "connected",
    RECONNECTING = "reconnecting",
    ERROR = "error"
}
/**
 * Subscription channels for WebSocket events.
 * @public
 */
type SubscriptionChannel = 'orderbook' | 'trades' | 'orders' | 'fills' | 'markets' | 'prices' | 'subscribe_market_prices' | 'subscribe_positions' | 'subscribe_transactions';
/**
 * Orderbook data structure (nested object in OrderbookUpdate).
 * @public
 */
interface OrderbookData {
    /** List of bid orders sorted by price descending */
    bids: OrderbookEntry[];
    /** List of ask orders sorted by price ascending */
    asks: OrderbookEntry[];
    /** Token ID for the orderbook */
    tokenId: string;
    /** Adjusted midpoint price */
    adjustedMidpoint: number;
    /** Maximum spread allowed */
    maxSpread: number;
    /** Minimum order size */
    minSize: number;
}
/**
 * Orderbook update event - matches API format exactly.
 * @public
 */
interface OrderbookUpdate {
    /** Market slug identifier (camelCase to match API) */
    marketSlug: string;
    /** Nested orderbook data object */
    orderbook: OrderbookData;
    /** Timestamp as Date or number after serialization */
    timestamp: Date | number | string;
}
/**
 * Trade event.
 * @public
 */
interface TradeEvent {
    marketSlug: string;
    side: 'BUY' | 'SELL';
    price: number;
    size: number;
    timestamp: number;
    tradeId: string;
}
/**
 * Order update event.
 * @public
 */
interface OrderUpdate {
    orderId: string;
    marketSlug: string;
    side: 'BUY' | 'SELL';
    price?: number;
    size: number;
    filled: number;
    status: 'OPEN' | 'FILLED' | 'CANCELLED' | 'PARTIALLY_FILLED';
    timestamp: number;
}
/**
 * Order fill event.
 * @public
 */
interface FillEvent {
    orderId: string;
    marketSlug: string;
    side: 'BUY' | 'SELL';
    price: number;
    size: number;
    timestamp: number;
    fillId: string;
}
/**
 * Market update event.
 * @public
 */
interface MarketUpdate {
    marketSlug: string;
    lastPrice?: number;
    volume24h?: number;
    priceChange24h?: number;
    timestamp: number;
}
/**
 * Price update event (deprecated - use NewPriceData for AMM prices).
 *
 * Note: This type does not match the actual API response.
 * Use NewPriceData for the correct AMM price update format.
 *
 * @public
 * @deprecated
 */
interface PriceUpdate {
    marketSlug: string;
    price: number;
    timestamp: number;
}
/**
 * Single AMM price entry in updatedPrices array.
 * @public
 */
interface AmmPriceEntry {
    /** Market ID */
    marketId: number;
    /** Market contract address */
    marketAddress: string;
    /** YES token price (0-1 range) */
    yesPrice: number;
    /** NO token price (0-1 range) */
    noPrice: number;
}
/**
 * AMM price update event (newPriceData) - matches API format exactly.
 * @public
 */
interface NewPriceData {
    /** Market contract address (camelCase to match API) */
    marketAddress: string;
    /** Array of price updates for this market */
    updatedPrices: AmmPriceEntry[];
    /** Blockchain block number */
    blockNumber: number;
    /** Timestamp as Date or number after serialization */
    timestamp: Date | number | string;
}
/**
 * Transaction event (blockchain transaction status).
 * @public
 */
interface TransactionEvent {
    /** User ID (optional) */
    userId?: number;
    /** Transaction hash (optional) */
    txHash?: string;
    /** Transaction status */
    status: 'CONFIRMED' | 'FAILED';
    /** Transaction source */
    source: string;
    /** Transaction timestamp */
    timestamp: Date | string;
    /** Market address (optional) */
    marketAddress?: string;
    /** Market slug identifier (optional) */
    marketSlug?: string;
    /** Token ID (optional) */
    tokenId?: string;
    /** Condition ID (optional) */
    conditionId?: string;
    /** Amount of contracts (optional, in string format) */
    amountContracts?: string;
    /** Amount of collateral (optional, in string format) */
    amountCollateral?: string;
    /** Price (optional, in string format) */
    price?: string;
    /** Trade side (optional) */
    side?: 'BUY' | 'SELL';
}
/**
 * WebSocket event types.
 * @public
 */
interface WebSocketEvents {
    /**
     * Connection established
     */
    connect: () => void;
    /**
     * Connection lost
     */
    disconnect: (reason: string) => void;
    /**
     * Connection error
     */
    error: (error: Error) => void;
    /**
     * Reconnection attempt
     */
    reconnecting: (attempt: number) => void;
    /**
     * Orderbook updates (CLOB markets) - API event name: orderbookUpdate
     */
    orderbookUpdate: (data: OrderbookUpdate) => void;
    /**
     * AMM price updates - API event name: newPriceData
     */
    newPriceData: (data: NewPriceData) => void;
    /**
     * Trade events
     */
    trade: (data: TradeEvent) => void;
    /**
     * Order updates
     */
    order: (data: OrderUpdate) => void;
    /**
     * Order fill events
     */
    fill: (data: FillEvent) => void;
    /**
     * Market updates
     */
    market: (data: MarketUpdate) => void;
    /**
     * Position updates
     */
    positions: (data: any) => void;
    /**
     * Transaction events (blockchain confirmations)
     */
    tx: (data: TransactionEvent) => void;
    /**
     * Price updates (deprecated - use newPriceData)
     * @deprecated
     */
    price: (data: PriceUpdate) => void;
}
/**
 * Subscription options.
 * @public
 */
interface SubscriptionOptions {
    /**
     * Market slug to subscribe to (required for market-specific channels)
     * @deprecated Use marketSlugs (array) instead - server expects array format
     */
    marketSlug?: string;
    /**
     * Market slugs to subscribe to (array format - required by server)
     */
    marketSlugs?: string[];
    /**
     * Market address to subscribe to (for AMM markets)
     * @deprecated Use marketAddresses (array) instead - server expects array format
     */
    marketAddress?: string;
    /**
     * Market addresses to subscribe to (array format - required by server)
     */
    marketAddresses?: string[];
    /**
     * Additional filters
     */
    filters?: Record<string, any>;
}

/**
 * Configuration options for the HTTP client.
 * @public
 */
interface HttpClientConfig {
    /**
     * Base URL for API requests
     * @defaultValue 'https://api.limitless.exchange'
     */
    baseURL?: string;
    /**
     * Request timeout in milliseconds
     * @defaultValue 30000
     */
    timeout?: number;
    /**
     * API key for authenticated requests
     * @remarks
     * If not provided, will attempt to load from LIMITLESS_API_KEY environment variable.
     * Required for authenticated endpoints (portfolio, orders, etc.)
     */
    apiKey?: string;
    /**
     * Optional logger for debugging
     * @defaultValue NoOpLogger (no logging)
     */
    logger?: ILogger;
    /**
     * Enable HTTP connection pooling with keepAlive
     * @defaultValue true
     * @remarks
     * When enabled, HTTP connections are reused across requests, reducing latency by 30-50%.
     * Recommended for production environments with high request volume.
     */
    keepAlive?: boolean;
    /**
     * Maximum number of sockets to allow per host
     * @defaultValue 50
     * @remarks
     * Controls the connection pool size. Higher values allow more concurrent requests
     * but consume more system resources.
     */
    maxSockets?: number;
    /**
     * Maximum number of free sockets to keep open per host
     * @defaultValue 10
     * @remarks
     * Determines how many idle connections to maintain in the pool.
     * Keeping connections open reduces latency for subsequent requests.
     */
    maxFreeSockets?: number;
    /**
     * Socket timeout in milliseconds
     * @defaultValue 60000
     * @remarks
     * Time to wait before closing an idle socket connection.
     */
    socketTimeout?: number;
    /**
     * Additional headers to include in all requests
     * @remarks
     * These headers will be merged with default headers and sent with every request.
     * Can be overridden by per-request headers.
     *
     * @example
     * ```typescript
     * const client = new HttpClient({
     *   additionalHeaders: {
     *     'X-Custom-Header': 'value',
     *     'X-API-Version': 'v1'
     *   }
     * });
     * ```
     */
    additionalHeaders?: Record<string, string>;
}
/**
 * HTTP client wrapper for Limitless Exchange API.
 *
 * @remarks
 * This class provides a centralized HTTP client with API key authentication,
 * error handling, and request/response interceptors.
 *
 * @public
 */
declare class HttpClient {
    private client;
    private apiKey?;
    private logger;
    /**
     * Creates a new HTTP client instance.
     *
     * @param config - Configuration options for the HTTP client
     */
    constructor(config?: HttpClientConfig);
    /**
     * Sets up request and response interceptors.
     * @internal
     */
    private setupInterceptors;
    /**
     * Sets the API key for authenticated requests.
     *
     * @param apiKey - API key value
     */
    setApiKey(apiKey: string): void;
    /**
     * Clears the API key.
     */
    clearApiKey(): void;
    /**
     * Performs a GET request.
     *
     * @param url - Request URL
     * @param config - Additional request configuration
     * @returns Promise resolving to the response data
     */
    get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>;
    /**
     * Performs a POST request.
     *
     * @param url - Request URL
     * @param data - Request body data
     * @param config - Additional request configuration
     * @returns Promise resolving to the response data
     */
    post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
    /**
     * Performs a DELETE request.
     *
     * @remarks
     * DELETE requests typically don't have a body, so we remove the Content-Type header
     * to avoid "Body cannot be empty" errors from the API.
     *
     * @param url - Request URL
     * @param config - Additional request configuration
     * @returns Promise resolving to the response data
     */
    delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>;
}

/**
 * Market class with fluent API methods.
 * @module types/market-class
 */

/**
 * Market class with fluent API support.
 *
 * @remarks
 * This class represents a market with methods for fetching related data.
 * Instances are created by MarketFetcher and have http_client attached.
 *
 * @public
 */
declare class Market {
    id: number;
    slug: string;
    title: string;
    proxyTitle: string | null;
    description?: string;
    collateralToken: CollateralToken;
    expirationDate: string;
    expirationTimestamp: number;
    expired?: boolean;
    createdAt: string;
    updatedAt: string;
    categories: string[];
    status: string;
    creator: MarketCreator;
    tags: string[];
    tradeType: string;
    marketType: string;
    priorityIndex: number;
    metadata: MarketMetadata;
    volume?: string;
    volumeFormatted?: string;
    conditionId?: string;
    negRiskRequestId?: string | null;
    tokens?: MarketTokens;
    prices?: number[];
    tradePrices?: TradePrices;
    isRewardable?: boolean;
    settings?: MarketSettings;
    venue?: Venue;
    logo?: string | null;
    priceOracleMetadata?: PriceOracleMetadata;
    orderInGroup?: number;
    winningOutcomeIndex?: number | null;
    outcomeTokens?: string[];
    ogImageURI?: string;
    negRiskMarketId?: string;
    markets?: Market[];
    dailyReward?: string;
    address?: string | null;
    type?: string;
    outcomes?: MarketOutcome[];
    resolutionDate?: string;
    private httpClient?;
    /**
     * Creates a Market instance.
     *
     * @param data - Market data from API
     * @param httpClient - HTTP client for making requests
     */
    constructor(data: any, httpClient?: HttpClient);
    /**
     * Get user's orders for this market.
     *
     * @remarks
     * Fetches all orders placed by the authenticated user for this specific market.
     * Uses the http_client from the MarketFetcher that created this Market instance.
     *
     * @returns Promise resolving to array of user orders
     * @throws Error if market wasn't fetched via MarketFetcher
     *
     * @example
     * ```typescript
     * // Clean fluent API
     * const market = await marketFetcher.getMarket("bitcoin-2024");
     * const orders = await market.getUserOrders();
     * console.log(`You have ${orders.length} orders in ${market.title}`);
     * ```
     */
    getUserOrders(): Promise<any[]>;
}

/**
 * API error types for Limitless Exchange SDK.
 * @module api/errors
 */
/**
 * Custom error class for API errors that preserves the original response data.
 *
 * @remarks
 * This error class allows users to access the raw API response for custom error handling.
 *
 * @example
 * ```typescript
 * try {
 *   await orderClient.createOrder(...);
 * } catch (error) {
 *   if (error instanceof APIError) {
 *     console.log('Status:', error.status);
 *     console.log('Raw response:', error.data);
 *     console.log('Message:', error.message);
 *   }
 * }
 * ```
 *
 * @public
 */
declare class APIError extends Error {
    /**
     * HTTP status code (e.g., 400, 404, 500)
     */
    readonly status: number;
    /**
     * Raw API response data (original JSON from API)
     */
    readonly data: any;
    /**
     * Request URL that failed
     */
    readonly url?: string;
    /**
     * Request method (GET, POST, etc.)
     */
    readonly method?: string;
    /**
     * Creates a new API error.
     *
     * @param message - Human-readable error message
     * @param status - HTTP status code
     * @param data - Raw API response data
     * @param url - Request URL
     * @param method - Request method
     */
    constructor(message: string, status: number, data: any, url?: string, method?: string);
    /**
     * Checks if this error is an authentication/authorization error.
     *
     * @returns True if the error is due to expired or invalid authentication
     *
     * @example
     * ```typescript
     * try {
     *   await portfolioFetcher.getPositions();
     * } catch (error) {
     *   if (error instanceof APIError && error.isAuthError()) {
     *     // Re-authenticate and retry
     *     await authenticator.authenticate({ client: 'eoa' });
     *     await portfolioFetcher.getPositions();
     *   }
     * }
     * ```
     */
    isAuthError(): boolean;
}
/**
 * Rate limit error (HTTP 429).
 *
 * @remarks
 * Thrown when API rate limits are exceeded. The request should be retried after a delay.
 *
 * @example
 * ```typescript
 * try {
 *   await marketFetcher.getActiveMarkets();
 * } catch (error) {
 *   if (error instanceof RateLimitError) {
 *     console.log('Rate limit exceeded, retry after delay');
 *   }
 * }
 * ```
 *
 * @public
 */
declare class RateLimitError extends APIError {
    constructor(message?: string, status?: number, data?: any, url?: string, method?: string);
}
/**
 * Authentication error (HTTP 401, 403).
 *
 * @remarks
 * Thrown when authentication fails or API key is invalid/missing.
 *
 * @example
 * ```typescript
 * try {
 *   await portfolioFetcher.getPositions();
 * } catch (error) {
 *   if (error instanceof AuthenticationError) {
 *     console.log('Authentication failed - check API key');
 *   }
 * }
 * ```
 *
 * @public
 */
declare class AuthenticationError extends APIError {
    constructor(message?: string, status?: number, data?: any, url?: string, method?: string);
}
/**
 * Validation error (HTTP 400).
 *
 * @remarks
 * Thrown when request validation fails (invalid parameters, missing required fields, etc.).
 *
 * @example
 * ```typescript
 * try {
 *   await orderClient.createOrder({ ... });
 * } catch (error) {
 *   if (error instanceof ValidationError) {
 *     console.log('Validation failed:', error.message);
 *   }
 * }
 * ```
 *
 * @public
 */
declare class ValidationError extends APIError {
    constructor(message: string, status?: number, data?: any, url?: string, method?: string);
}

/**
 * Retry mechanism for handling transient API failures.
 *
 * @remarks
 * This module provides flexible retry logic for handling rate limits (429),
 * server errors (500, 502, 503), and other transient failures.
 *
 * @example
 * ```typescript
 * // Decorator approach
 * @retryOnErrors({ statusCodes: [429, 500], maxRetries: 3, delays: [2, 5, 10] })
 * async function createOrder() {
 *   return await orderClient.createOrder(...);
 * }
 *
 * // Wrapper approach
 * const retryConfig = new RetryConfig({ statusCodes: [429, 500], maxRetries: 3 });
 * const retryableClient = new RetryableClient(httpClient, retryConfig);
 * const markets = await retryableClient.get('/markets');
 * ```
 *
 * @module api/retry
 * @public
 */

/**
 * Configuration options for retry behavior.
 *
 * @public
 */
interface RetryConfigOptions {
    /**
     * HTTP status codes to retry on
     * @defaultValue [429, 500, 502, 503, 504]
     */
    statusCodes?: number[];
    /**
     * Maximum number of retry attempts
     * @defaultValue 3
     */
    maxRetries?: number;
    /**
     * List of delays in seconds for each retry attempt.
     * If not provided, exponential backoff will be used.
     * @defaultValue undefined (use exponential backoff)
     */
    delays?: number[];
    /**
     * Base for exponential backoff calculation (delay = base^attempt)
     * @defaultValue 2
     */
    exponentialBase?: number;
    /**
     * Maximum delay in seconds for exponential backoff
     * @defaultValue 60
     */
    maxDelay?: number;
    /**
     * Optional callback called before each retry attempt
     * @param attempt - Retry attempt number (0-based)
     * @param error - The error that triggered the retry
     * @param delay - Delay in seconds before retry
     */
    onRetry?: (attempt: number, error: Error, delay: number) => void;
}
/**
 * Configuration class for retry behavior.
 *
 * @public
 */
declare class RetryConfig {
    /**
     * HTTP status codes to retry on
     */
    readonly statusCodes: Set<number>;
    /**
     * Maximum number of retry attempts
     */
    readonly maxRetries: number;
    /**
     * List of delays in seconds for each retry
     */
    readonly delays?: number[];
    /**
     * Base for exponential backoff
     */
    readonly exponentialBase: number;
    /**
     * Maximum delay in seconds
     */
    readonly maxDelay: number;
    /**
     * Optional retry callback
     */
    readonly onRetry?: (attempt: number, error: Error, delay: number) => void;
    /**
     * Creates a new retry configuration.
     *
     * @param options - Configuration options
     */
    constructor(options?: RetryConfigOptions);
    /**
     * Calculates delay for a given retry attempt.
     *
     * @param attempt - Retry attempt number (0-based)
     * @returns Delay in seconds
     */
    getDelay(attempt: number): number;
}
/**
 * Decorator to add retry logic to async functions.
 *
 * @remarks
 * This decorator automatically retries failed API calls based on HTTP status codes.
 * Useful for handling transient errors like rate limits (429) or server errors (500, 502, 503).
 *
 * @param options - Retry configuration options
 * @returns Method decorator
 *
 * @example
 * ```typescript
 * class MyService {
 *   @retryOnErrors({ statusCodes: [429, 500], maxRetries: 3, delays: [2, 5, 10] })
 *   async createOrder() {
 *     return await this.orderClient.createOrder(...);
 *   }
 * }
 * ```
 *
 * @public
 */
declare function retryOnErrors(options?: RetryConfigOptions): (_target: any, _propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
/**
 * Standalone retry function for wrapping async operations.
 *
 * @remarks
 * This function wraps any async operation with retry logic.
 * More flexible than the decorator approach for one-off retries.
 *
 * @param fn - Async function to execute with retry
 * @param options - Retry configuration options
 * @param logger - Optional logger for retry information
 * @returns Promise resolving to the function result
 *
 * @example
 * ```typescript
 * const result = await withRetry(
 *   async () => await orderClient.createOrder(...),
 *   { statusCodes: [429, 500], maxRetries: 3, delays: [2, 5, 10] }
 * );
 * ```
 *
 * @public
 */
declare function withRetry<T>(fn: () => Promise<T>, options?: RetryConfigOptions, logger?: ILogger): Promise<T>;
/**
 * HTTP client wrapper that adds retry logic to all requests.
 *
 * @remarks
 * This class wraps an HttpClient and automatically retries failed requests
 * based on configured retry settings.
 *
 * @example
 * ```typescript
 * const httpClient = new HttpClient({ logger });
 * const retryConfig = new RetryConfig({ statusCodes: [429, 500], maxRetries: 3 });
 * const retryableClient = new RetryableClient(httpClient, retryConfig);
 *
 * // All requests automatically retry on 429, 500
 * const markets = await retryableClient.get('/markets');
 * ```
 *
 * @public
 */
declare class RetryableClient {
    private httpClient;
    private retryConfig;
    private logger;
    /**
     * Creates a new retryable client wrapper.
     *
     * @param httpClient - HTTP client to wrap
     * @param retryConfig - Retry configuration
     * @param logger - Optional logger
     */
    constructor(httpClient: any, retryConfig?: RetryConfig, logger?: ILogger);
    /**
     * Performs a GET request with retry logic.
     *
     * @param url - Request URL
     * @param config - Additional request configuration
     * @returns Promise resolving to the response data
     */
    get<T = any>(url: string, config?: any): Promise<T>;
    /**
     * Performs a POST request with retry logic.
     *
     * @param url - Request URL
     * @param data - Request body data
     * @param config - Additional request configuration
     * @returns Promise resolving to the response data
     */
    post<T = any>(url: string, data?: any, config?: any): Promise<T>;
    /**
     * Performs a DELETE request with retry logic.
     *
     * @param url - Request URL
     * @param config - Additional request configuration
     * @returns Promise resolving to the response data
     */
    delete<T = any>(url: string, config?: any): Promise<T>;
    /**
     * Forwards any other method calls to the wrapped HTTP client.
     *
     * @param method - Method name
     */
    [key: string]: any;
}

/**
 * Default API endpoints and configuration constants.
 * @public
 */
/**
 * Default Limitless Exchange API URL.
 * @public
 */
declare const DEFAULT_API_URL = "https://api.limitless.exchange";
/**
 * Default WebSocket URL for real-time data.
 * @public
 */
declare const DEFAULT_WS_URL = "wss://ws.limitless.exchange";
/**
 * Default chain ID (Base mainnet).
 * @public
 */
declare const DEFAULT_CHAIN_ID = 8453;
/**
 * Base Sepolia testnet chain ID.
 * @public
 */
declare const BASE_SEPOLIA_CHAIN_ID = 84532;
/**
 * Signing message template used by the API.
 * @internal
 */
declare const SIGNING_MESSAGE_TEMPLATE = "Welcome to Limitless.exchange! Please sign this message to verify your identity.\n\nNonce: {NONCE}";
/**
 * Zero address constant.
 * @public
 */
declare const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
/**
 * Contract addresses by network
 *
 * @remarks
 * Note: CLOB and NegRisk exchange addresses are provided dynamically via the venue system
 * (market.venue.exchange and market.venue.adapter). These addresses vary per market and
 * should be fetched from the API rather than hardcoded.
 *
 * @public
 */
declare const CONTRACT_ADDRESSES: {
    readonly 8453: {
        readonly USDC: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913";
        readonly CTF: "0xC9c98965297Bc527861c898329Ee280632B76e18";
    };
    readonly 84532: {
        readonly USDC: "0x...";
        readonly CTF: "0x...";
    };
};
/**
 * Get contract address for tokens (USDC or CTF)
 *
 * @remarks
 * For CLOB and NegRisk exchange addresses, use the venue system instead:
 * - Fetch market via `marketFetcher.getMarket(slug)`
 * - Use `market.venue.exchange` for signing and approvals
 * - Use `market.venue.adapter` for NegRisk adapter approvals
 *
 * @param contractType - Contract type (USDC or CTF)
 * @param chainId - Chain ID (default: 8453 for Base mainnet)
 * @returns Contract address
 *
 * @throws Error if contract address not found for chain
 *
 * @public
 */
declare function getContractAddress(contractType: 'USDC' | 'CTF', chainId?: number): string;

/**
 * Order builder for constructing unsigned order payloads.
 * @module orders/builder
 */

/**
 * Order builder for constructing unsigned order payloads.
 *
 * @remarks
 * This class handles the construction of unsigned orders matching the
 * Limitless Exchange API format. It generates unique salts, calculates
 * maker/taker amounts with proper tick alignment, and validates inputs.
 *
 * **Tick Alignment Requirements**:
 * - Prices must align to tick size (default: 0.001 = 3 decimals)
 * - Size must produce takerAmount divisible by sharesStep (priceScale / tickInt = 1000 for 0.001 tick)
 * - SDK validates inputs and throws clear errors rather than auto-rounding
 * - This ensures `price * contracts` yields whole number collateral
 *
 * **Validation Strategy**:
 * - FAILS FAST: Invalid inputs throw errors with helpful suggestions
 * - NO AUTO-ROUNDING: Users maintain full control over order amounts
 * - TRANSPARENCY: Error messages show valid alternatives
 * - Example: size=22.123896  Error: "Try 22.123 (rounded down) or 22.124 (rounded up) instead"
 *
 * @public
 */
declare class OrderBuilder {
    private makerAddress;
    private feeRateBps;
    private priceTick;
    /**
     * Creates a new order builder instance.
     *
     * @param makerAddress - Ethereum address of the order maker
     * @param feeRateBps - Fee rate in basis points (e.g., 100 = 1%)
     * @param priceTick - Price tick size (default: 0.001 for 3 decimals)
     *
     * @example
     * ```typescript
     * const builder = new OrderBuilder(
     *   '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb',
     *   300, // 3% fee
     *   0.001 // 3 decimal price precision
     * );
     * ```
     */
    constructor(makerAddress: string, feeRateBps: number, priceTick?: number);
    /**
     * Builds an unsigned order payload.
     *
     * @param args - Order arguments (FOK or GTC)
     * @returns Unsigned order ready for signing
     *
     * @throws Error if validation fails or tick alignment fails
     *
     * @example
     * ```typescript
     * // FOK order (market order)
     * const fokOrder = builder.buildOrder({
     *   tokenId: '123456',
     *   makerAmount: 50,  // 50 USDC to spend
     *   side: Side.BUY
     * });
     *
     * // GTC order (price + size)
     * const gtcOrder = builder.buildOrder({
     *   tokenId: '123456',
     *   price: 0.38,
     *   size: 22.123,  // Will be rounded to tick-aligned: 22.123 shares
     *   side: Side.BUY
     * });
     * ```
     */
    buildOrder(args: OrderArgs): UnsignedOrder;
    /**
     * Type guard to check if order arguments are for FOK order.
     *
     * @param args - Order arguments
     * @returns True if FOK order arguments
     *
     * @internal
     */
    private isFOKOrder;
    /**
     * Generates a unique salt using timestamp + nano-offset pattern.
     *
     * @remarks
     * This follows the reference implementation pattern:
     * salt = timestamp * 1000 + nanoOffset + 24h
     *
     * This ensures uniqueness even when creating orders rapidly.
     *
     * @returns Unique salt value
     *
     * @internal
     */
    private generateSalt;
    /**
     * Parses decimal string to scaled BigInt.
     *
     * @param value - Decimal string (e.g., "0.38")
     * @param scale - Scale factor (e.g., 1_000_000n for 6 decimals)
     * @returns Scaled BigInt value
     *
     * @internal
     */
    private parseDecToInt;
    /**
     * Ceiling division for BigInt.
     *
     * @param numerator - Numerator
     * @param denominator - Denominator
     * @returns Ceiling of numerator / denominator
     *
     * @internal
     */
    private divCeil;
    /**
     * Calculates maker and taker amounts for GTC orders with tick alignment validation.
     *
     * @remarks
     * Validates and calculates amounts to ensure:
     * 1. Price aligns to tick size (e.g., 0.001 for 3 decimals)
     * 2. Size produces takerAmount divisible by sharesStep
     * 3. No auto-rounding - fails fast if values are invalid
     * 4. Transparent error messages guide users to valid values
     *
     * **Algorithm**:
     * - sharesStep = priceScale / tickInt (e.g., 1000 for 0.001 tick)
     * - Validates shares are divisible by sharesStep
     * - Calculates collateral from shares  price (ceil for BUY, floor for SELL)
     * - Assigns maker/taker based on side:
     *   - BUY: maker = collateral, taker = shares
     *   - SELL: maker = shares, taker = collateral
     * - Throws clear error if size is not tick-aligned
     *
     * @param price - Price per share (0.0 to 1.0, max 3 decimals)
     * @param size - Number of shares (must be tick-aligned)
     * @param side - Order side (BUY or SELL)
     * @returns Object with validated makerAmount, takerAmount, and price
     *
     * @throws Error if price or size not tick-aligned
     *
     * @internal
     */
    private calculateGTCAmountsTickAligned;
    /**
     * Calculates maker and taker amounts for FOK (market) orders.
     *
     * @remarks
     * FOK orders use makerAmount for both BUY and SELL:
     * - BUY: makerAmount = USDC amount to spend (e.g., 50 = $50 USDC)
     * - SELL: makerAmount = number of shares to sell (e.g., 18.64 shares)
     *
     * takerAmount is always 1 (constant for FOK orders)
     *
     * @param makerAmount - Amount in human-readable format (max 6 decimals)
     * @returns Object with makerAmount (scaled), takerAmount (always 1), and undefined price
     *
     * @internal
     */
    private calculateFOKAmounts;
    /**
     * Validates order arguments.
     *
     * @param args - Order arguments to validate
     * @throws Error if validation fails
     *
     * @internal
     */
    private validateOrderArgs;
}

/**
 * EIP-712 order signer for Limitless Exchange.
 * @module orders/signer
 */

/**
 * EIP-712 order signer.
 *
 * @remarks
 * This class handles EIP-712 signing for Limitless Exchange orders.
 * It creates signatures that match the API's verification requirements.
 *
 * Domain: "Limitless CTF Exchange"
 * Version: "1"
 *
 * @public
 */
declare class OrderSigner {
    private wallet;
    private logger;
    /**
     * Creates a new order signer instance.
     *
     * @param wallet - Ethers wallet for signing
     * @param logger - Optional logger for debugging (default: no logging)
     *
     * @example
     * ```typescript
     * import { ethers } from 'ethers';
     * import { OrderSigner } from '@limitless-exchange/sdk';
     *
     * const wallet = new ethers.Wallet(privateKey);
     * const signer = new OrderSigner(wallet);
     * ```
     */
    constructor(wallet: ethers.Wallet, logger?: ILogger);
    /**
     * Signs an order with EIP-712.
     *
     * @param order - Unsigned order to sign
     * @param config - Signing configuration (chainId, contract address, market type)
     * @returns Promise resolving to EIP-712 signature
     *
     * @throws Error if wallet address doesn't match order signer
     * @throws Error if signing fails
     *
     * @example
     * ```typescript
     * const signature = await signer.signOrder(unsignedOrder, {
     *   chainId: 8453,
     *   contractAddress: '0x...'
     * });
     * ```
     */
    signOrder(order: UnsignedOrder, config: OrderSigningConfig): Promise<string>;
    /**
     * Gets the EIP-712 domain for signing.
     *
     * @param config - Signing configuration
     * @returns EIP-712 domain object
     *
     * @internal
     */
    private getDomain;
    /**
     * Gets the EIP-712 type definitions.
     *
     * @remarks
     * This matches the order structure expected by the Limitless Exchange
     * smart contracts.
     *
     * @returns EIP-712 types definition
     *
     * @internal
     */
    private getTypes;
}

/**
 * Order validation utilities.
 * @module orders/validator
 */

/**
 * Order validation error class for client-side validation.
 * @public
 */
declare class OrderValidationError extends Error {
    constructor(message: string);
}
/**
 * Validates order arguments before building.
 *
 * @param args - Order arguments to validate (FOK or GTC)
 * @throws OrderValidationError if validation fails
 *
 * @public
 *
 * @example
 * ```typescript
 * try {
 *   validateOrderArgs(orderArgs);
 * } catch (error) {
 *   console.error('Validation failed:', error.message);
 * }
 * ```
 */
declare function validateOrderArgs(args: OrderArgs): void;
/**
 * Validates an unsigned order.
 *
 * @param order - Unsigned order to validate
 * @throws OrderValidationError if validation fails
 *
 * @public
 *
 * @example
 * ```typescript
 * validateUnsignedOrder(unsignedOrder);
 * ```
 */
declare function validateUnsignedOrder(order: UnsignedOrder): void;
/**
 * Validates a signed order.
 *
 * @param order - Signed order to validate
 * @throws OrderValidationError if validation fails
 *
 * @public
 *
 * @example
 * ```typescript
 * validateSignedOrder(signedOrder);
 * ```
 */
declare function validateSignedOrder(order: SignedOrder): void;

/**
 * Market data fetcher for Limitless Exchange.
 * @module markets/fetcher
 */

/**
 * Market data fetcher for retrieving market information and orderbooks.
 *
 * @remarks
 * This class provides methods to fetch market data, orderbooks, and prices
 * from the Limitless Exchange API.
 *
 * Venue caching: When fetching market data, venue information is automatically
 * cached for efficient order signing. This eliminates redundant API calls when
 * creating orders for the same market.
 *
 * @public
 */
declare class MarketFetcher {
    private httpClient;
    private logger;
    private venueCache;
    /**
     * Creates a new market fetcher instance.
     *
     * @param httpClient - HTTP client for API requests
     * @param logger - Optional logger for debugging (default: no logging)
     *
     * @example
     * ```typescript
     * const fetcher = new MarketFetcher(httpClient);
     * ```
     */
    constructor(httpClient: HttpClient, logger?: ILogger);
    /**
     * Gets active markets with query parameters and pagination support.
     *
     * @param params - Query parameters for filtering and pagination
     * @returns Promise resolving to active markets response
     * @throws Error if API request fails
     *
     * @example
     * ```typescript
     * // Get 8 markets sorted by LP rewards
     * const response = await fetcher.getActiveMarkets({
     *   limit: 8,
     *   sortBy: 'lp_rewards'
     * });
     * console.log(`Found ${response.data.length} of ${response.totalMarketsCount} markets`);
     *
     * // Get page 2
     * const page2 = await fetcher.getActiveMarkets({
     *   limit: 8,
     *   page: 2,
     *   sortBy: 'ending_soon'
     * });
     * ```
     */
    getActiveMarkets(params?: ActiveMarketsParams): Promise<ActiveMarketsResponse>;
    /**
     * Gets a single market by slug.
     *
     * @remarks
     * Automatically caches venue information for efficient order signing.
     * Always call this method before creating orders to ensure venue data
     * is available and avoid additional API requests.
     *
     * @param slug - Market slug identifier
     * @returns Promise resolving to market details
     * @throws Error if API request fails or market not found
     *
     * @example
     * ```typescript
     * // Get market
     * const market = await fetcher.getMarket('bitcoin-price-2024');
     * console.log(`Market: ${market.title}`);
     *
     * // Fluent API - get user orders for this market (clean!)
     * const orders = await market.getUserOrders();
     * console.log(`You have ${orders.length} orders`);
     *
     * // Venue is now cached for order signing
     * await orderClient.createOrder({
     *   marketSlug: 'bitcoin-price-2024',
     *   ...
     * });
     * ```
     */
    getMarket(slug: string): Promise<Market>;
    /**
     * Gets cached venue information for a market.
     *
     * @remarks
     * Returns venue data previously cached by getMarket() call.
     * Used internally by OrderClient for efficient order signing.
     *
     * @param slug - Market slug identifier
     * @returns Cached venue information, or undefined if not in cache
     *
     * @example
     * ```typescript
     * const venue = fetcher.getVenue('bitcoin-price-2024');
     * if (venue) {
     *   console.log(`Exchange: ${venue.exchange}`);
     * }
     * ```
     */
    getVenue(slug: string): Venue | undefined;
    /**
     * Gets the orderbook for a CLOB market.
     *
     * @param slug - Market slug identifier
     * @returns Promise resolving to orderbook data
     * @throws Error if API request fails
     *
     * @example
     * ```typescript
     * const orderbook = await fetcher.getOrderBook('bitcoin-price-2024');
     * console.log(`Bids: ${orderbook.bids.length}, Asks: ${orderbook.asks.length}`);
     * ```
     */
    getOrderBook(slug: string): Promise<OrderBook>;
}

/**
 * Order client for managing orders on Limitless Exchange.
 * @module orders/client
 */

/**
 * Configuration for the order client.
 *
 * @remarks
 * The order client auto-configures signing based on venue data from the API.
 * User data (userId, feeRateBps) is automatically fetched from the profile API
 * on first order creation and cached for subsequent orders.
 *
 * Performance tip: Provide a shared marketFetcher instance to enable venue caching
 * across market fetches and order creation, avoiding redundant API calls.
 *
 * @public
 */
interface OrderClientConfig {
    /**
     * HTTP client for API requests (must have API key configured)
     */
    httpClient: HttpClient;
    /**
     * Wallet for signing orders with EIP-712
     */
    wallet: ethers.Wallet;
    /**
     * Custom signing configuration (optional)
     *
     * @remarks
     * If not provided, SDK will auto-configure from venue data.
     * Useful for custom deployments or testing.
     */
    signingConfig?: OrderSigningConfig;
    /**
     * Shared MarketFetcher instance for venue caching (optional)
     *
     * @remarks
     * When provided, enables efficient venue caching across market fetches and order creation.
     * If not provided, OrderClient creates its own internal MarketFetcher instance.
     *
     * Best practice: Share the same MarketFetcher instance between market operations
     * and order creation for optimal performance.
     *
     * @example
     * ```typescript
     * const marketFetcher = new MarketFetcher(httpClient);
     * const orderClient = new OrderClient({
     *   httpClient,
     *   wallet,
     *   marketFetcher  // Shared instance
     * });
     *
     * // Venue is cached
     * await marketFetcher.getMarket('bitcoin-2024');
     *
     * // Uses cached venue, no extra API call
     * await orderClient.createOrder({ marketSlug: 'bitcoin-2024', ... });
     * ```
     */
    marketFetcher?: MarketFetcher;
    /**
     * Optional logger
     */
    logger?: ILogger;
}
/**
 * Order client for creating and managing orders.
 *
 * @remarks
 * This class provides high-level methods for order operations,
 * abstracting away HTTP details and order signing complexity.
 *
 * User data (userId, feeRateBps) is automatically fetched from profile API
 * on first order creation and cached for subsequent orders.
 *
 * Uses dynamic venue addressing for EIP-712 order signing. For best performance,
 * always call marketFetcher.getMarket() before creating orders to cache venue data.
 *
 * @example
 * ```typescript
 * import { ethers } from 'ethers';
 *
 * const wallet = new ethers.Wallet(process.env.PRIVATE_KEY!);
 * const orderClient = new OrderClient({
 *   httpClient,  // Must have API key configured
 *   wallet,      // For EIP-712 signing
 * });
 *
 * // User data automatically fetched on first order
 * const order = await orderClient.createOrder({
 *   tokenId: '123...',
 *   price: 0.65,
 *   size: 100,
 *   side: Side.BUY,
 *   orderType: OrderType.GTC,
 *   marketSlug: 'market-slug'
 * });
 * ```
 *
 * @public
 */
declare class OrderClient {
    private httpClient;
    private wallet;
    private orderBuilder?;
    private orderSigner;
    private marketFetcher;
    private cachedUserData?;
    private signingConfig;
    private logger;
    /**
     * Creates a new order client instance.
     *
     * @param config - Order client configuration
     */
    constructor(config: OrderClientConfig);
    /**
     * Ensures user data is loaded and cached.
     * Fetches from profile API on first call, then caches for subsequent calls.
     *
     * @returns Promise resolving to cached user data
     * @internal
     */
    private ensureUserData;
    /**
     * Creates and submits a new order.
     *
     * @remarks
     * This method handles the complete order creation flow:
     * 1. Resolve venue address (from cache or API)
     * 2. Build unsigned order
     * 3. Sign with EIP-712 using venue.exchange as verifyingContract
     * 4. Submit to API
     *
     * Performance best practice: Always call marketFetcher.getMarket(marketSlug)
     * before createOrder() to cache venue data and avoid additional API requests.
     *
     * @param params - Order parameters
     * @returns Promise resolving to order response
     *
     * @throws Error if order creation fails or venue not found
     *
     * @example
     * ```typescript
     * // Best practice: fetch market first to cache venue
     * const market = await marketFetcher.getMarket('bitcoin-2024');
     *
     * const order = await orderClient.createOrder({
     *   tokenId: market.tokens.yes,
     *   price: 0.65,
     *   size: 100,
     *   side: Side.BUY,
     *   orderType: OrderType.GTC,
     *   marketSlug: 'bitcoin-2024'
     * });
     *
     * console.log(`Order created: ${order.order.id}`);
     * ```
     */
    createOrder(params: OrderArgs & {
        orderType: OrderType;
        marketSlug: string;
    }): Promise<OrderResponse>;
    /**
     * Transforms raw API response to clean OrderResponse DTO.
     *
     * @param apiResponse - Raw API response with nested objects
     * @returns Clean OrderResponse with only essential fields
     *
     * @internal
     */
    private transformOrderResponse;
    /**
     * Cancels an existing order by ID.
     *
     * @param orderId - Order ID to cancel
     * @returns Promise resolving to cancellation message
     *
     * @throws Error if cancellation fails
     *
     * @example
     * ```typescript
     * const result = await orderClient.cancel('order-id-123');
     * console.log(result.message); // "Order canceled successfully"
     * ```
     */
    cancel(orderId: string): Promise<{
        message: string;
    }>;
    /**
     * Cancels all orders for a specific market.
     *
     * @param marketSlug - Market slug to cancel all orders for
     * @returns Promise resolving to cancellation message
     *
     * @throws Error if cancellation fails
     *
     * @example
     * ```typescript
     * const result = await orderClient.cancelAll('market-slug-123');
     * console.log(result.message); // "Orders canceled successfully"
     * ```
     */
    cancelAll(marketSlug: string): Promise<{
        message: string;
    }>;
    /**
     * Builds an unsigned order without submitting.
     *
     * @remarks
     * Useful for advanced use cases where you need the unsigned order
     * before signing and submission.
     *
     * @param params - Order parameters
     * @returns Promise resolving to unsigned order
     *
     * @example
     * ```typescript
     * const unsignedOrder = await orderClient.buildUnsignedOrder({
     *   tokenId: '123456',
     *   price: 0.65,
     *   size: 100,
     *   side: Side.BUY
     * });
     * ```
     */
    buildUnsignedOrder(params: OrderArgs): Promise<UnsignedOrder>;
    /**
     * Signs an unsigned order without submitting.
     *
     * @remarks
     * Useful for advanced use cases where you need to inspect
     * the signature before submission.
     *
     * @param order - Unsigned order to sign
     * @returns Promise resolving to signature
     *
     * @example
     * ```typescript
     * const signature = await orderClient.signOrder(unsignedOrder);
     * ```
     */
    signOrder(order: UnsignedOrder): Promise<string>;
    /**
     * Gets the wallet address.
     *
     * @returns Ethereum address of the wallet
     *
     * @example
     * ```typescript
     * const address = orderClient.walletAddress;
     * console.log(`Wallet: ${address}`);
     * ```
     */
    get walletAddress(): string;
    /**
     * Gets the owner ID (user ID from profile).
     *
     * @returns Owner ID from user profile, or undefined if not yet loaded
     *
     * @example
     * ```typescript
     * const ownerId = orderClient.ownerId;
     * if (ownerId) {
     *   console.log(`Owner ID: ${ownerId}`);
     * }
     * ```
     */
    get ownerId(): number | undefined;
}

/**
 * Portfolio data fetcher for Limitless Exchange.
 * @module portfolio/fetcher
 */

/**
 * Portfolio data fetcher for retrieving user positions and portfolio information.
 *
 * @remarks
 * This class provides methods to fetch user positions and calculate portfolio statistics
 * from the Limitless Exchange API. Requires an authenticated HttpClient.
 *
 * @public
 */
declare class PortfolioFetcher {
    private httpClient;
    private logger;
    /**
     * Creates a new portfolio fetcher instance.
     *
     * @param httpClient - Authenticated HTTP client for API requests
     * @param logger - Optional logger for debugging (default: no logging)
     *
     * @example
     * ```typescript
     * // Create authenticated client
     * const httpClient = new HttpClient({ baseURL: API_URL });
     * await authenticator.authenticate({ client: 'eoa' });
     *
     * // Create portfolio fetcher
     * const portfolioFetcher = new PortfolioFetcher(httpClient);
     * ```
     */
    constructor(httpClient: HttpClient, logger?: ILogger);
    /**
     * Gets user profile for a specific wallet address.
     *
     * @remarks
     * Returns user profile data including user ID and fee rate.
     * Used internally by OrderClient to fetch user data.
     *
     * @param address - Wallet address to fetch profile for
     * @returns Promise resolving to user profile data
     * @throws Error if API request fails or user is not authenticated
     *
     * @example
     * ```typescript
     * const profile = await portfolioFetcher.getProfile('0x1234...');
     * console.log(`User ID: ${profile.id}`);
     * console.log(`Account: ${profile.account}`);
     * console.log(`Fee Rate: ${profile.rank?.feeRateBps}`);
     * ```
     */
    getProfile(address: string): Promise<any>;
    /**
     * Gets raw portfolio positions response from API.
     *
     * @returns Promise resolving to portfolio positions response with CLOB and AMM positions
     * @throws Error if API request fails or user is not authenticated
     *
     * @example
     * ```typescript
     * const response = await portfolioFetcher.getPositions();
     * console.log(`CLOB positions: ${response.clob.length}`);
     * console.log(`AMM positions: ${response.amm.length}`);
     * console.log(`Total points: ${response.accumulativePoints}`);
     * ```
     */
    getPositions(): Promise<PortfolioPositionsResponse>;
    /**
     * Gets CLOB positions only.
     *
     * @returns Promise resolving to array of CLOB positions
     * @throws Error if API request fails
     *
     * @example
     * ```typescript
     * const clobPositions = await portfolioFetcher.getCLOBPositions();
     * clobPositions.forEach(pos => {
     *   console.log(`${pos.market.title}: YES ${pos.positions.yes.unrealizedPnl} P&L`);
     * });
     * ```
     */
    getCLOBPositions(): Promise<CLOBPosition[]>;
    /**
     * Gets AMM positions only.
     *
     * @returns Promise resolving to array of AMM positions
     * @throws Error if API request fails
     *
     * @example
     * ```typescript
     * const ammPositions = await portfolioFetcher.getAMMPositions();
     * ammPositions.forEach(pos => {
     *   console.log(`${pos.market.title}: ${pos.unrealizedPnl} P&L`);
     * });
     * ```
     */
    getAMMPositions(): Promise<AMMPosition[]>;
    /**
     * Gets paginated history of user actions.
     *
     *  Includes AMM trades, CLOB trades, Negrisk trades & conversions.
     *
     * @param page - Page number (starts at 1)
     * @param limit - Number of items per page
     * @returns Promise resolving to paginated history response
     * @throws Error if API request fails or user is not authenticated
     *
     * @example
     * ```typescript
     * // Get first page
     * const response = await portfolioFetcher.getUserHistory(1, 20);
     * console.log(`Found ${response.data.length} of ${response.totalCount} entries`);
     *
     * // Process history entries
     * for (const entry of response.data) {
     *   console.log(`Type: ${entry.type}`);
     *   console.log(`Market: ${entry.marketSlug}`);
     * }
     *
     * // Get next page
     * const page2 = await portfolioFetcher.getUserHistory(2, 20);
     * ```
     */
    getUserHistory(page?: number, limit?: number): Promise<HistoryResponse>;
}

/**
 * WebSocket client for real-time data streaming.
 * @module websocket/client
 */

/**
 * WebSocket client for real-time data streaming from Limitless Exchange.
 *
 * @remarks
 * This client uses Socket.IO to connect to the WebSocket server and provides
 * typed event subscriptions for orderbook, trades, orders, and market data.
 *
 * **Public Subscriptions** (no authentication required):
 * - Market prices (AMM)
 * - Orderbook updates (CLOB)
 *
 * **Authenticated Subscriptions** (require API key):
 * - User positions
 * - User transactions
 *
 * @example
 * ```typescript
 * // Public subscription (no API key needed)
 * const wsClient = new WebSocketClient({
 *   autoReconnect: true,
 * });
 *
 * await wsClient.connect();
 * await wsClient.subscribe('subscribe_market_prices', {
 *   marketSlugs: ['market-123']
 * });
 *
 * // Authenticated subscription (API key required)
 * const wsClientAuth = new WebSocketClient({
 *   apiKey: process.env.LIMITLESS_API_KEY,
 *   autoReconnect: true,
 * });
 *
 * await wsClientAuth.connect();
 * await wsClientAuth.subscribe('subscribe_positions', {
 *   marketSlugs: ['market-123']
 * });
 * ```
 *
 * @public
 */
declare class WebSocketClient {
    private socket;
    private config;
    private logger;
    private state;
    private reconnectAttempts;
    private subscriptions;
    private pendingListeners;
    /**
     * Creates a new WebSocket client.
     *
     * @param config - WebSocket configuration
     * @param logger - Optional logger for debugging
     */
    constructor(config?: WebSocketConfig, logger?: ILogger);
    /**
     * Gets current connection state.
     *
     * @returns Current WebSocket state
     */
    getState(): WebSocketState;
    /**
     * Checks if client is connected.
     *
     * @returns True if connected
     */
    isConnected(): boolean;
    /**
     * Sets the API key for authentication.
     *
     * @param apiKey - API key value
     *
     * @remarks
     * API key is required for authenticated subscriptions (positions, transactions).
     * If already connected, this will trigger a reconnection with the new API key.
     */
    setApiKey(apiKey: string): void;
    /**
     * Reconnects with new authentication credentials.
     * @internal
     */
    private reconnectWithNewAuth;
    /**
     * Connects to the WebSocket server.
     *
     * @returns Promise that resolves when connected
     * @throws Error if connection fails
     *
     * @example
     * ```typescript
     * await wsClient.connect();
     * console.log('Connected!');
     * ```
     */
    connect(): Promise<void>;
    /**
     * Disconnects from the WebSocket server.
     *
     * @returns Promise that resolves when disconnected
     *
     * @example
     * ```typescript
     * await wsClient.disconnect();
     * ```
     */
    disconnect(): Promise<void>;
    /**
     * Subscribes to a channel.
     *
     * @param channel - Channel to subscribe to
     * @param options - Subscription options
     * @returns Promise that resolves immediately (kept async for API compatibility)
     * @throws Error if not connected
     *
     * @example
     * ```typescript
     * // Subscribe to orderbook for a specific market
     * await wsClient.subscribe('orderbook', { marketSlugs: ['market-123'] });
     *
     * // Subscribe to all trades
     * await wsClient.subscribe('trades');
     *
     * // Subscribe to your orders
     * await wsClient.subscribe('orders');
     * ```
     */
    subscribe(channel: SubscriptionChannel, options?: SubscriptionOptions): Promise<void>;
    /**
     * Unsubscribes from a channel.
     *
     * @param channel - Channel to unsubscribe from
     * @param options - Subscription options (must match subscribe call)
     * @returns Promise that resolves when unsubscribed
     * @throws Error if not connected or unsubscribe fails
     *
     * @example
     * ```typescript
     * await wsClient.unsubscribe('orderbook', { marketSlugs: ['market-123'] });
     * ```
     */
    unsubscribe(channel: SubscriptionChannel, options?: SubscriptionOptions): Promise<void>;
    /**
     * Registers an event listener.
     *
     * @param event - Event name
     * @param handler - Event handler
     * @returns This client for chaining
     *
     * @example
     * ```typescript
     * wsClient
     *   .on('orderbook', (data) => console.log('Orderbook:', data))
     *   .on('trade', (data) => console.log('Trade:', data))
     *   .on('error', (error) => console.error('Error:', error));
     * ```
     */
    on<K extends keyof WebSocketEvents>(event: K, handler: WebSocketEvents[K]): this;
    /**
     * Registers a one-time event listener.
     *
     * @param event - Event name
     * @param handler - Event handler
     * @returns This client for chaining
     */
    once<K extends keyof WebSocketEvents>(event: K, handler: WebSocketEvents[K]): this;
    /**
     * Removes an event listener.
     *
     * @param event - Event name
     * @param handler - Event handler to remove (if undefined, removes all handlers for event)
     * @returns This client for chaining
     *
     * @example
     * ```typescript
     * // Remove specific handler
     * wsClient.off('orderbookUpdate', myHandler);
     *
     * // Remove all handlers for event
     * wsClient.off('orderbookUpdate');
     * ```
     */
    off<K extends keyof WebSocketEvents>(event: K, handler?: WebSocketEvents[K]): this;
    /**
     * Attach any pending event listeners that were added before connect().
     * @internal
     */
    private attachPendingListeners;
    /**
     * Setup internal event handlers for connection management.
     * @internal
     */
    private setupEventHandlers;
    /**
     * Re-subscribes to all previous subscriptions after reconnection.
     * @internal
     */
    private resubscribeAll;
    /**
     * Creates a unique subscription key.
     * @internal
     */
    private getSubscriptionKey;
    /**
     * Extracts channel from subscription key.
     * @internal
     */
    private getChannelFromKey;
}

export { type AMMPosition, APIError, type ActiveMarketsParams, type ActiveMarketsResponse, type ActiveMarketsSortBy, type AmmPriceEntry, AuthenticationError, BASE_SEPOLIA_CHAIN_ID, type BaseOrderArgs, type CLOBPosition, CONTRACT_ADDRESSES, type CollateralToken, ConsoleLogger, type CreatedOrder, DEFAULT_API_URL, DEFAULT_CHAIN_ID, DEFAULT_WS_URL, type FOKOrderArgs, type FillEvent, type GTCOrderArgs, type HistoryEntry, type HistoryResponse, HttpClient, type HttpClientConfig, type ILogger, type LatestTrade, Market, type MarketCreator, MarketFetcher, type Market$1 as MarketInterface, type MarketMetadata, type MarketOutcome, type MarketSettings, type MarketTokens, type MarketUpdate, type MarketsResponse, type ModeInfo, type NewOrderPayload, type NewPriceData, NoOpLogger, type OrderArgs, type OrderBook, OrderBuilder, OrderClient, type OrderClientConfig, type OrderMatch, type OrderResponse, OrderSigner, type OrderSigningConfig, OrderType, type OrderUpdate, OrderValidationError, type OrderbookData, type OrderbookEntry, type OrderbookUpdate, PortfolioFetcher, type PortfolioPositionsResponse, type PortfolioSummary, type Position, type PositionMarket, type PositionSide, type PriceOracleMetadata, type PriceUpdate, RateLimitError, type ReferralData, RetryConfig, type RetryConfigOptions, RetryableClient, SIGNING_MESSAGE_TEMPLATE, Side, SignatureType, type SignedOrder, type SubscriptionChannel, type SubscriptionOptions, type TokenBalance, type TradeEvent, type TradePrices, type TradingMode, type TransactionEvent, type UnsignedOrder, type UserData, type UserProfile, type UserRank, ValidationError, type Venue, WebSocketClient, type WebSocketConfig, type WebSocketEvents, WebSocketState, ZERO_ADDRESS, getContractAddress, retryOnErrors, validateOrderArgs, validateSignedOrder, validateUnsignedOrder, withRetry };
