{
  "version": 3,
  "sources": ["../src/index.ts", "../src/actions/swap.ts", "../src/constants.ts", "../src/keypairUtils.ts", "../src/actions/transfer.ts", "../src/providers/wallet.ts", "../src/service.ts"],
  "sourcesContent": [
    "import type { IAgentRuntime, Plugin, ServiceTypeName } from '@elizaos/core';\nimport { parseBooleanFromText } from '@elizaos/core';\n\n// actions\nimport { executeSwap } from './actions/swap';\nimport transferToken from './actions/transfer';\n\n// providers\nimport { walletProvider } from './providers/wallet';\n\n// service\nimport { SolanaService, SolanaWalletService } from './service';\n\nimport { SOLANA_SERVICE_NAME } from './constants';\n\nexport const solanaPlugin: Plugin = {\n  name: SOLANA_SERVICE_NAME,\n  description: 'Solana blockchain plugin',\n  services: [SolanaService, SolanaWalletService],\n  init: async (_, runtime: IAgentRuntime) => {\n\n    // Validation\n    if (!runtime.getSetting('SOLANA_RPC_URL')) {\n      runtime.logger.log('no SOLANA_RPC_URL, skipping plugin-solana init')\n      return\n    }\n\n    const noActions = parseBooleanFromText(runtime.getSetting(\"SOLANA_NO_ACTIONS\"));\n    if (!noActions) {\n      runtime.registerAction(transferToken)\n      runtime.registerAction(executeSwap)\n    } else {\n      runtime.logger.log('SOLANA_NO_ACTIONS is set, skipping solana actions')\n    }\n\n    runtime.registerProvider(walletProvider)\n\n    // extensions\n    runtime.getServiceLoadPromise('INTEL_CHAIN' as ServiceTypeName).then( () => {\n      //runtime.logger.log('solana INTEL_CHAIN LOADED')\n      const traderChainService = runtime.getService('INTEL_CHAIN') as any;\n      const me = {\n        name: 'Solana services',\n        chain: 'solana',\n        service: SOLANA_SERVICE_NAME,\n      };\n      traderChainService.registerChain(me);\n    }).catch(error => {\n      runtime.logger.error({ error },'Failed to register with INTEL_CHAIN');\n    });\n\n  },\n};\nexport default solanaPlugin;\n\n// Export additional items for use by other plugins\nexport { SOLANA_SERVICE_NAME } from './constants';\nexport { SolanaService, SolanaWalletService } from './service';\nexport type { SolanaService as ISolanaService } from './service';",
    "import {\n  type Action,\n  type ActionExample,\n  type ActionResult,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelType,\n  type State,\n  composePromptFromState,\n  logger,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { Connection, PublicKey, VersionedTransaction } from '@solana/web3.js';\nimport BigNumber from 'bignumber.js';\nimport { SOLANA_SERVICE_NAME } from '../constants';\nimport { getWalletKey } from '../keypairUtils';\nimport type { SolanaService } from '../service';\n\nimport type { Item } from '../types';\n/**\n * Fetches the number of decimals for a given token mint address.\n *\n * @param {Connection} connection - Solana connection object.\n * @param {string} mintAddress - Address of the token mint.\n * @returns {Promise<number>} - Number of decimals for the token.\n * @throws {Error} - If unable to fetch token decimals.\n */\nasync function getTokenDecimals(connection: Connection, mintAddress: string): Promise<number> {\n  const mintPublicKey = new PublicKey(mintAddress);\n  const tokenAccountInfo = await connection.getParsedAccountInfo(mintPublicKey);\n\n  if (\n    tokenAccountInfo.value &&\n    typeof tokenAccountInfo.value.data === 'object' &&\n    'parsed' in tokenAccountInfo.value.data\n  ) {\n    const parsedInfo = tokenAccountInfo.value.data.parsed?.info;\n    if (parsedInfo && typeof parsedInfo.decimals === 'number') {\n      return parsedInfo.decimals;\n    }\n  }\n\n  throw new Error('Unable to fetch token decimals');\n}\n\n/**\n * Swaps tokens using the specified connection, wallet public key, input and output token contract addresses,\n * and amount. Returns a Promise that resolves to the swap data.\n *\n * @param {Connection} connection The connection object to use for interacting with the blockchain.\n * @param {PublicKey} walletPublicKey The public key of the wallet initiating the swap.\n * @param {string} inputTokenCA The contract address of the input token.\n * @param {string} outputTokenCA The contract address of the output token.\n * @param {number} amount The amount of tokens to swap.\n * @returns {Promise<unknown>} A Promise that resolves to the swap data object.\n */\nasync function swapToken(\n  connection: Connection,\n  walletPublicKey: PublicKey,\n  inputTokenCA: string,\n  outputTokenCA: string,\n  amount: number\n): Promise<unknown> {\n  try {\n    const decimals =\n      inputTokenCA === process.env.SOL_ADDRESS\n        ? new BigNumber(9)\n        : new BigNumber(await getTokenDecimals(connection, inputTokenCA));\n\n    logger.log('Decimals:', decimals.toString());\n\n    const amountBN = new BigNumber(amount);\n    const adjustedAmount = amountBN.multipliedBy(new BigNumber(10).pow(decimals));\n\n    logger.log({\n      inputMint: inputTokenCA,\n      outputMint: outputTokenCA,\n      amount: adjustedAmount,\n    }, 'Fetching quote with params:');\n\n    const quoteResponse = await fetch(\n      `https://quote-api.jup.ag/v6/quote?inputMint=${inputTokenCA}&outputMint=${outputTokenCA}&amount=${adjustedAmount}&dynamicSlippage=true&maxAccounts=64`\n    );\n    const quoteData = (await quoteResponse.json()) as {\n      error?: string;\n    };\n\n    if (!quoteData || quoteData.error) {\n      logger.error({ quoteData },'Quote error');\n      throw new Error(`Failed to get quote: ${quoteData?.error || 'Unknown error'}`);\n    }\n\n    const swapRequestBody = {\n      quoteResponse: quoteData,\n      userPublicKey: walletPublicKey.toBase58(),\n      dynamicComputeUnitLimit: true,\n      dynamicSlippage: true,\n      priorityLevelWithMaxLamports: {\n        maxLamports: 4000000,\n        priorityLevel: 'veryHigh',\n      },\n    };\n\n    const swapResponse = await fetch('https://quote-api.jup.ag/v6/swap', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(swapRequestBody),\n    });\n\n    const swapData = (await swapResponse.json()) as {\n      error?: string;\n      swapTransaction?: string;\n    };\n\n    if (!swapData || !swapData.swapTransaction) {\n      logger.error({ swapData }, 'Swap error');\n      throw new Error(\n        `Failed to get swap transaction: ${swapData?.error || 'No swap transaction returned'}`\n      );\n    }\n\n    return swapData;\n  } catch (error) {\n    logger.error({ error }, 'Error in swapToken:');\n    throw error;\n  }\n}\n\n// Get token from wallet data using SolanaService\n/**\n * Retrieves the token address from the wallet for the specified token symbol.\n *\n * @param {IAgentRuntime} runtime - The agent runtime.\n * @param {string} tokenSymbol - The token symbol to retrieve the address for.\n * @returns {Promise<string|null>} The token address if found, null otherwise.\n */\nasync function getTokenFromWallet(\n  runtime: IAgentRuntime,\n  tokenSymbol: string\n): Promise<string | null> {\n  try {\n    const solanaService = runtime.getService(SOLANA_SERVICE_NAME) as SolanaService;\n    if (!solanaService) {\n      throw new Error('SolanaService not initialized');\n    }\n\n    const walletData = await solanaService.getCachedData();\n    if (!walletData) {\n      return null;\n    }\n\n    const token = walletData.items.find(\n      (item: Item) => item.symbol.toLowerCase() === tokenSymbol.toLowerCase()\n    );\n\n    return token ? token.address : null;\n  } catch (error) {\n    logger.error({ error }, 'Error checking token in wallet');\n    return null;\n  }\n}\n\n/**\n * Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n *\n * Example response:\n * ```json\n * {\n *     \"inputTokenSymbol\": \"SOL\",\n *     \"outputTokenSymbol\": \"USDC\",\n *     \"inputTokenCA\": \"So11111111111111111111111111111111111111112\",\n *     \"outputTokenCA\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n *     \"amount\": 1.5\n * }\n * ```\n *\n * {{recentMessages}}\n *\n * Given the recent messages and wallet information below:\n *\n * {{walletInfo}}\n *\n * Extract the following information about the requested token swap:\n * - Input token symbol (the token being sold)\n * - Output token symbol (the token being bought)\n * - Input token contract address if provided\n * - Output token contract address if provided\n * - Amount to swap\n *\n * Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n */\nconst swapTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n\nExample response:\n\\`\\`\\`json\n{\n    \"inputTokenSymbol\": \"SOL\",\n    \"outputTokenSymbol\": \"USDC\",\n    \"inputTokenCA\": \"So11111111111111111111111111111111111111112\",\n    \"outputTokenCA\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n    \"amount\": 1.5\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nGiven the recent messages and wallet information below:\n\n{{walletInfo}}\n\nExtract the following information about the requested token swap:\n- Input token symbol (the token being sold)\n- Output token symbol (the token being bought)\n- Input token contract address if provided\n- Output token contract address if provided\n- Amount to swap\n\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.`;\n\n/**\n * Action for executing a token swap from one token to another on Solana.\n *\n * @type {Action}\n * @property {string} name - The name of the action (\"SWAP_SOLANA\").\n * @property {string[]} similes - Alternative names for the action.\n * @property {Function} validate - Asynchronous function to validate if Solana service is available.\n * @property {string} description - Description of the action.\n * @property {Function} handler - Asynchronous function to handle the token swap process.\n * @property {ActionExample[][]} examples - Examples demonstrating how to use the action.\n */\n\nexport const executeSwap: Action = {\n  name: 'SWAP_SOLANA',\n  similes: [\n    'SWAP_SOL',\n    'SWAP_TOKENS_SOLANA',\n    'TOKEN_SWAP_SOLANA',\n    'TRADE_TOKENS_SOLANA',\n    'EXCHANGE_TOKENS_SOLANA',\n  ],\n  validate: async (runtime: IAgentRuntime, _message: Memory) => {\n    const solanaService = runtime.getService(SOLANA_SERVICE_NAME);\n    return !!solanaService;\n  },\n  description:\n    'Perform a token swap from one token to another on Solana. Works with SOL and SPL tokens.',\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: { [key: string]: unknown } | undefined,\n    callback?: HandlerCallback\n  ): Promise<void | ActionResult | undefined> => {\n    state = await runtime.composeState(message, ['RECENT_MESSAGES']);\n\n    try {\n      const solanaService = runtime.getService(SOLANA_SERVICE_NAME) as SolanaService;\n      if (!solanaService) {\n        throw new Error('SolanaService not initialized');\n      }\n\n      const walletData = await solanaService.getCachedData();\n      state.values.walletInfo = walletData;\n\n      const swapPrompt = composePromptFromState({\n        state,\n        template: swapTemplate,\n      });\n\n      const result = await runtime.useModel(ModelType.TEXT_LARGE, {\n        prompt: swapPrompt,\n      });\n\n      const response = parseJSONObjectFromText(result) as {\n        inputTokenSymbol?: string;\n        outputTokenSymbol?: string;\n        inputTokenCA?: string;\n        outputTokenCA?: string;\n        amount?: number;\n      };\n\n      // Handle SOL addresses\n      if (response.inputTokenSymbol?.toUpperCase() === 'SOL') {\n        response.inputTokenCA = process.env.SOL_ADDRESS;\n      }\n      if (response.outputTokenSymbol?.toUpperCase() === 'SOL') {\n        response.outputTokenCA = process.env.SOL_ADDRESS;\n      }\n\n      // Resolve token addresses if needed\n      if (!response.inputTokenCA && response.inputTokenSymbol) {\n        response.inputTokenCA =\n          (await getTokenFromWallet(runtime, response.inputTokenSymbol)) || undefined;\n        if (!response.inputTokenCA) {\n          callback?.({ text: 'Could not find the input token in your wallet' });\n          return;\n        }\n      }\n\n      if (!response.outputTokenCA && response.outputTokenSymbol) {\n        response.outputTokenCA =\n          (await getTokenFromWallet(runtime, response.outputTokenSymbol)) || undefined;\n        if (!response.outputTokenCA) {\n          callback?.({\n            text: 'Could not find the output token in your wallet',\n          });\n          return;\n        }\n      }\n\n      if (!response.amount) {\n        callback?.({ text: 'Please specify the amount you want to swap' });\n        return;\n      }\n\n      const connection = new Connection(\n        runtime.getSetting('SOLANA_RPC_URL') || 'https://api.mainnet-beta.solana.com'\n      );\n      const { publicKey: walletPublicKey } = await getWalletKey(runtime, false);\n\n      const swapResult = (await swapToken(\n        connection,\n        walletPublicKey as PublicKey,\n        response.inputTokenCA as string,\n        response.outputTokenCA as string,\n        response.amount as number\n      )) as { swapTransaction: string };\n\n      const transactionBuf = Buffer.from(swapResult.swapTransaction, 'base64');\n      const transaction = VersionedTransaction.deserialize(transactionBuf);\n\n      const { keypair } = await getWalletKey(runtime, true);\n      if (keypair?.publicKey.toBase58() !== walletPublicKey?.toBase58()) {\n        throw new Error(\"Generated public key doesn't match expected public key\");\n      }\n\n      if (keypair) {\n        transaction.sign([keypair]);\n      } else {\n        throw new Error('Keypair not found');\n      }\n\n      const latestBlockhash = await connection.getLatestBlockhash();\n      const txid = await connection.sendTransaction(transaction, {\n        skipPreflight: false,\n        maxRetries: 3,\n        preflightCommitment: 'confirmed',\n      });\n\n      const confirmation = await connection.confirmTransaction(\n        {\n          signature: txid,\n          blockhash: latestBlockhash.blockhash,\n          lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,\n        },\n        'confirmed'\n      );\n\n      if (confirmation.value.err) {\n        throw new Error(`Transaction failed: ${confirmation.value.err}`);\n      }\n\n      callback?.({\n        text: `Swap completed successfully! Transaction ID: ${txid}`,\n        content: { success: true, txid },\n      });\n\n      return;\n    } catch (error) {\n      if (error instanceof Error) {\n        logger.error({ error }, 'Error during token swap');\n        callback?.({\n          text: `Swap failed: ${error.message}`,\n          content: { error: error.message },\n        });\n        return;\n      }\n      throw error;\n    }\n  },\n  examples: [\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Swap 0.1 SOL for USDC',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: \"I'll help you swap 0.1 SOL for USDC\",\n          actions: ['SWAP_SOLANA'],\n        },\n      },\n    ],\n  ] as ActionExample[][],\n};\n",
    "export const SOLANA_SERVICE_NAME = 'chain_solana';\nexport const SOLANA_WALLET_DATA_CACHE_KEY = 'solana/walletData';\n",
    "import { type IAgentRuntime, logger } from '@elizaos/core';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport bs58 from 'bs58';\n\n/**\n * Interface representing the result of a keypair generation.\n * @typedef {Object} KeypairResult\n * @property {Keypair} [keypair] - The generated keypair.\n * @property {PublicKey} [publicKey] - The public key corresponding to the generated keypair.\n */\nexport interface KeypairResult {\n  keypair?: Keypair;\n  publicKey?: PublicKey;\n}\n\n/**\n * Gets either a keypair or public key based on TEE mode and runtime settings\n * @param runtime The agent runtime\n * @param requirePrivateKey Whether to return a full keypair (true) or just public key (false)\n * @returns KeypairResult containing either keypair or public key\n */\n/**\n * Retrieves the wallet keypair or public key based on the specified runtime settings.\n *\n * @param {IAgentRuntime} runtime - The IAgentRuntime instance to retrieve settings from.\n * @param {boolean} [requirePrivateKey=true] - Specify whether the private key is required. Default is true.\n * @returns {Promise<KeypairResult>} The keypair result object containing the keypair or public key.\n */\nexport async function getWalletKey(\n  runtime: IAgentRuntime,\n  requirePrivateKey = true\n): Promise<KeypairResult> {\n  // TEE mode is OFF\n  if (requirePrivateKey) {\n    const privateKeyString =\n      runtime.getSetting('SOLANA_PRIVATE_KEY') ?? runtime.getSetting('WALLET_PRIVATE_KEY');\n\n    if (!privateKeyString) {\n      throw new Error('Private key not found in settings');\n    }\n\n    try {\n      // First try base58\n      const secretKey = bs58.decode(privateKeyString);\n      return { keypair: Keypair.fromSecretKey(secretKey) };\n    } catch (e) {\n      logger.log({ e }, 'Error decoding base58 private key:');\n      try {\n        // Then try base64\n        logger.log('Try decoding base64 instead');\n        const secretKey = Uint8Array.from(Buffer.from(privateKeyString, 'base64'));\n        return { keypair: Keypair.fromSecretKey(secretKey) };\n      } catch (e2) {\n        logger.error({ e: e2 }, 'Error decoding private key: ');\n        throw new Error('Invalid private key format');\n      }\n    }\n  } else {\n    const publicKeyString =\n      runtime.getSetting('SOLANA_PUBLIC_KEY') ?? runtime.getSetting('WALLET_PUBLIC_KEY');\n\n    if (!publicKeyString) {\n      throw new Error(\n        'Solana Public key not found in settings, but plugin was loaded, please set SOLANA_PUBLIC_KEY'\n      );\n    }\n\n    return { publicKey: new PublicKey(publicKeyString) };\n  }\n}\n",
    "import {\n  type Action,\n  type ActionExample,\n  type ActionResult,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelType,\n  type State,\n  composePromptFromState,\n  logger,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\nimport {\n  createAssociatedTokenAccountInstruction,\n  createTransferInstruction,\n  getAssociatedTokenAddressSync,\n} from '@solana/spl-token';\nimport {\n  Connection,\n  PublicKey,\n  SystemProgram,\n  TransactionMessage,\n  VersionedTransaction,\n} from '@solana/web3.js';\nimport { getWalletKey } from '../keypairUtils';\n\n/**\n * Interface representing the content of a transfer.\n *\n * @interface TransferContent\n * @extends Content\n * @property {string | null} tokenAddress - The address of the token being transferred, or null for SOL transfers\n * @property {string} recipient - The address of the recipient of the transfer\n * @property {string | number} amount - The amount of the transfer, represented as a string or number\n */\ninterface TransferContent extends Content {\n  tokenAddress: string | null; // null for SOL transfers\n  recipient: string;\n  amount: string | number;\n}\n\n/**\n * Checks if the given transfer content is valid based on the type of transfer.\n * @param {TransferContent} content - The content to be validated for transfer.\n * @returns {boolean} Returns true if the content is valid for transfer, and false otherwise.\n */\nfunction isTransferContent(content: unknown): content is TransferContent {\n  if (!content || typeof content !== 'object') return false;\n\n  const c = content as Partial<Record<keyof TransferContent, unknown>>;\n  // Base validation\n  if (typeof c.recipient !== 'string') return false;\n  if (!(typeof c.amount === 'string' || typeof c.amount === 'number')) return false;\n\n  // Donâ€™t mutate here; just validate. Treat 'null' as valid string; normalize later.\n  if (c.tokenAddress !== null && typeof c.tokenAddress !== 'string') return false;\n\n  return true;\n}\n\n/**\n * Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n *\n * Example responses:\n * For SPL tokens:\n * ```json\n * {\n *    \"tokenAddress\": \"BieefG47jAHCGZBxi2q87RDuHyGZyYC3vAzxpyu8pump\",\n *    \"recipient\": \"9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa\",\n *    \"amount\": \"1000\"\n * }\n * ```\n *\n * For SOL:\n * ```json\n * {\n *    \"tokenAddress\": null,\n *    \"recipient\": \"9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa\",\n *    \"amount\": 1.5\n * }\n * ```\n *\n * {{recentMessages}}\n *\n * Extract the following information about the requested transfer:\n * - Token contract address (use null for SOL transfers)\n * - Recipient wallet address\n * - Amount to transfer\n */\nconst transferTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n\nExample responses:\nFor SPL tokens:\n\\`\\`\\`json\n{\n    \"tokenAddress\": \"BieefG47jAHCGZBxi2q87RDuHyGZyYC3vAzxpyu8pump\",\n    \"recipient\": \"9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa\",\n    \"amount\": \"1000\"\n}\n\\`\\`\\`\n\nFor SOL:\n\\`\\`\\`json\n{\n    \"tokenAddress\": null,\n    \"recipient\": \"9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa\",\n    \"amount\": 1.5\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nExtract the following information about the requested transfer:\n- Token contract address (use null for SOL transfers)\n- Recipient wallet address\n- Amount to transfer\n`;\n\nexport default {\n  name: 'TRANSFER_SOLANA',\n  similes: [\n    'TRANSFER_SOL',\n    'SEND_TOKEN_SOLANA',\n    'TRANSFER_TOKEN_SOLANA',\n    'SEND_TOKENS_SOLANA',\n    'TRANSFER_TOKENS_SOLANA',\n    'SEND_SOL',\n    'SEND_TOKEN_SOL',\n    'PAY_SOL',\n    'PAY_TOKEN_SOL',\n    'PAY_TOKENS_SOL',\n    'PAY_TOKENS_SOLANA',\n    'PAY_SOLANA',\n  ],\n  validate: async (runtime: IAgentRuntime, message: Memory) => {\n    runtime.logger.log('Validating transfer from entity:', message.entityId);\n    return true;\n  },\n  description: 'Transfer SOL or SPL tokens to another address on Solana.',\n  handler: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    state: State,\n    _options: { [key: string]: unknown },\n    callback?: HandlerCallback\n  ): Promise<void | ActionResult | undefined> => {\n    logger.log('Starting TRANSFER handler...');\n\n    const transferPrompt = composePromptFromState({\n      state: state,\n      template: transferTemplate,\n    });\n\n    const result = await runtime.useModel(ModelType.TEXT_LARGE, {\n      prompt: transferPrompt,\n    });\n\n    const content = parseJSONObjectFromText(result);\n\n    if (!content) {\n      if (callback) {\n        callback({\n          text: 'Need a valid recipient address and amount to transfer.',\n          content: { error: 'Invalid transfer content' },\n        });\n      }\n      return;\n    }\n\n    if (!isTransferContent(content)) {\n      if (callback) {\n        callback({\n          text: 'Need a valid recipient address and amount to transfer.',\n          content: { error: 'Invalid transfer content' },\n        });\n      }\n      return;\n    }\n\n    try {\n      const { keypair: senderKeypair } = await getWalletKey(runtime, true);\n      if (!senderKeypair) {\n        if (callback) {\n          callback({\n            text: 'Need a valid agent address.',\n            content: { error: 'Invalid transfer content' },\n          });\n        }\n        return;\n      }\n      const connection = new Connection(\n        runtime.getSetting('SOLANA_RPC_URL') || 'https://api.mainnet-beta.solana.com'\n      );\n      const recipientPubkey = new PublicKey(content.recipient);\n\n      let signature: string;\n\n      // Handle SOL transfer\n      if (content.tokenAddress === null) {\n        const lamports = Number(content.amount) * 1e9;\n\n        const instruction = SystemProgram.transfer({\n          fromPubkey: senderKeypair.publicKey,\n          toPubkey: recipientPubkey,\n          lamports,\n        });\n\n        const messageV0 = new TransactionMessage({\n          payerKey: senderKeypair.publicKey,\n          recentBlockhash: (await connection.getLatestBlockhash()).blockhash,\n          instructions: [instruction],\n        }).compileToV0Message();\n\n        const transaction = new VersionedTransaction(messageV0);\n        transaction.sign([senderKeypair]);\n\n        signature = await connection.sendTransaction(transaction);\n\n        if (callback) {\n          callback({\n            text: `Sent ${content.amount} SOL. Transaction hash: ${signature}`,\n            content: {\n              success: true,\n              signature,\n              amount: content.amount,\n              recipient: content.recipient,\n            },\n          });\n        }\n      }\n      // Handle SPL token transfer\n      else {\n        const mintPubkey = new PublicKey(content.tokenAddress);\n        const mintInfo = await connection.getParsedAccountInfo(mintPubkey);\n        const decimals =\n          (mintInfo.value?.data as { parsed: { info: { decimals: number } } })?.parsed?.info\n            ?.decimals ?? 9;\n        const adjustedAmount = BigInt(Number(content.amount) * 10 ** decimals);\n\n        const senderATA = getAssociatedTokenAddressSync(mintPubkey, senderKeypair.publicKey);\n        const recipientATA = getAssociatedTokenAddressSync(mintPubkey, recipientPubkey);\n\n        const instructions = [];\n\n        const recipientATAInfo = await connection.getAccountInfo(recipientATA);\n        if (!recipientATAInfo) {\n          instructions.push(\n            createAssociatedTokenAccountInstruction(\n              senderKeypair.publicKey,\n              recipientATA,\n              recipientPubkey,\n              mintPubkey\n            )\n          );\n        }\n\n        instructions.push(\n          createTransferInstruction(\n            senderATA,\n            recipientATA,\n            senderKeypair.publicKey,\n            adjustedAmount\n          )\n        );\n\n        const messageV0 = new TransactionMessage({\n          payerKey: senderKeypair.publicKey,\n          recentBlockhash: (await connection.getLatestBlockhash()).blockhash,\n          instructions,\n        }).compileToV0Message();\n\n        const transaction = new VersionedTransaction(messageV0);\n        transaction.sign([senderKeypair]);\n\n        signature = await connection.sendTransaction(transaction);\n\n        if (callback) {\n          callback({\n            text: `Sent ${content.amount} tokens to ${content.recipient}\\nTransaction hash: ${signature}`,\n            content: {\n              success: true,\n              signature,\n              amount: content.amount,\n              recipient: content.recipient,\n            },\n          });\n        }\n      }\n\n      return;\n    } catch (error) {\n      logger.error({ error },'Error during transfer');\n      if (callback) {\n        const message =\n          error instanceof Error\n            ? error.message\n            : typeof error === 'string'\n            ? error\n            : JSON.stringify(error);\n        callback({\n          text: `Transfer failed: ${message}`,\n          content: { error: message },\n        });\n      }\n      return;\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Send 1.5 SOL to 9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'Sending SOL now...',\n          actions: ['TRANSFER_SOLANA'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Send 69 $DEGENAI BieefG47jAHCGZBxi2q87RDuHyGZyYC3vAzxpyu8pump to 9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'Sending the tokens now...',\n          actions: ['TRANSFER_SOLANA'],\n        },\n      },\n    ],\n  ] as ActionExample[][],\n} as Action;\n",
    "import type { IAgentRuntime, Memory, Provider, State } from '@elizaos/core';\nimport { logger } from '@elizaos/core';\nimport BigNumber from 'bignumber.js';\nimport { SOLANA_WALLET_DATA_CACHE_KEY } from '../constants';\nimport { getWalletKey } from '../keypairUtils';\nimport type { WalletPortfolio } from '../types';\n\n// Define the ProviderResult interface if not already imported\n/**\n * Represents the result returned by a provider.\n * @typedef {Object} ProviderResult\n * @property {any} [data] - The data associated with the result.\n * @property {Record<string, string>} [values] - The values stored in key-value pairs.\n * @property {string} [text] - The text content of the result.\n */\ninterface ProviderResult {\n  data?: any;\n  values?: Record<string, string>;\n  text?: string;\n}\n\n/**\n * Wallet provider for Solana.\n * @param {IAgentRuntime} runtime - The agent runtime.\n * @param {Memory} _message - The memory message.\n * @param {State} [state] - Optional state parameter.\n * @returns {Promise<ProviderResult>} The result of the wallet provider.\n */\nexport const walletProvider: Provider = {\n  name: 'solana-wallet',\n  description: 'your solana wallet information',\n  // it's not slow we always have this data\n  // but we don't always need this data, let's free up the context\n  dynamic: true,\n  get: async (runtime: IAgentRuntime, _message: Memory, state?: State): Promise<ProviderResult> => {\n    try {\n      const portfolioCache = await runtime.getCache<WalletPortfolio>(SOLANA_WALLET_DATA_CACHE_KEY);\n      //console.log('portfolioCache', portfolioCache)\n      if (!portfolioCache) {\n        logger.info('solana::wallet provider - portfolioCache is not ready');\n        return { data: null, values: {}, text: '' };\n      }\n\n      // hard coding service name, ugh\n      const solanaService = runtime.getService('solana');\n      let pubkeyStr = '';\n\n      const { publicKey } = await getWalletKey(runtime, false);\n\n      // why wouldn't this exist? it's in the same plugin...\n      if (solanaService) {\n        pubkeyStr = ' (' + publicKey?.toBase58() + ')';\n      }\n\n      const portfolio = portfolioCache as WalletPortfolio;\n      const agentName = state?.agentName || runtime.character.name || 'The agent';\n\n      // Values that can be injected into templates\n      const values: Record<string, string> = {\n        total_usd: new BigNumber(portfolio.totalUsd).toFixed(2),\n        total_sol: portfolio.totalSol?.toString() || '0',\n      };\n\n      // Add token balances to values\n      portfolio.items.forEach((item, index) => {\n        if (new BigNumber(item.uiAmount).isGreaterThan(0)) {\n          values[`token_${index}_name`] = item.name;\n          values[`token_${index}_symbol`] = item.symbol;\n          values[`token_${index}_amount`] = new BigNumber(item.uiAmount).toFixed(6);\n          values[`token_${index}_usd`] = new BigNumber(item.valueUsd).toFixed(2);\n          values[`token_${index}_sol`] = item.valueSol?.toString() || '0';\n        }\n      });\n\n      // Add market prices to values\n      if (portfolio.prices) {\n        values.sol_price = new BigNumber(portfolio.prices.solana.usd).toFixed(2);\n        values.btc_price = new BigNumber(portfolio.prices.bitcoin.usd).toFixed(2);\n        values.eth_price = new BigNumber(portfolio.prices.ethereum.usd).toFixed(2);\n      }\n\n      // Format the text output\n      let text = `\\n\\n${agentName}'s Main Solana Wallet${pubkeyStr}\\n`;\n      text += `Total Value: $${values.total_usd} (${values.total_sol} SOL)\\n\\n`;\n\n      // Token Balances\n      text += 'Token Balances:\\n';\n      const nonZeroItems = portfolio.items.filter((item) =>\n        new BigNumber(item.uiAmount).isGreaterThan(0)\n      );\n\n      if (nonZeroItems.length === 0) {\n        text += 'No tokens found with non-zero balance\\n';\n      } else {\n        for (const item of nonZeroItems) {\n          const valueUsd = new BigNumber(item.valueUsd).toFixed(2);\n          text += `${item.name} (${item.symbol}): ${new BigNumber(item.uiAmount).toFixed(\n            6\n          )} ($${valueUsd} | ${item.valueSol} SOL)\\n`;\n        }\n      }\n\n      // Market Prices\n      if (portfolio.prices) {\n        text += '\\nMarket Prices:\\n';\n        text += `SOL: $${values.sol_price}\\n`;\n        text += `BTC: $${values.btc_price}\\n`;\n        text += `ETH: $${values.eth_price}\\n`;\n      }\n\n      return {\n        data: portfolio,\n        values: values,\n        text: text,\n      };\n    } catch (error) {\n      logger.error(`Error in Solana wallet provider: ${error instanceof Error ? error.message : String(error)}`);\n      return { data: null, values: {}, text: '' };\n    }\n  },\n};\n",
    "import { type IAgentRuntime, ServiceTypeName, Service, ServiceType, logger } from '@elizaos/core';\nimport { IWalletService, WalletPortfolio as siWalletPortfolio } from '@elizaos/service-interfaces';\nimport {\n  Connection,\n  Keypair,\n  PublicKey,\n  VersionedTransaction,\n  SendTransactionError,\n  LAMPORTS_PER_SOL,\n  type AccountInfo,\n  SystemProgram,\n  Transaction,\n  TransactionMessage,\n  type RpcResponseAndContext,\n  type ParsedAccountData,\n} from '@solana/web3.js';\nimport {\n  MintLayout, getMint, TOKEN_PROGRAM_ID, TOKEN_2022_PROGRAM_ID, unpackAccount,\n  getAssociatedTokenAddressSync, ExtensionType, getExtensionData, getExtensionTypes,\n  unpackMint, AccountLayout\n} from \"@solana/spl-token\";\n// parses the raw Token-2022 metadata struct\nimport { unpack as unpackToken2022Metadata } from '@solana/spl-token-metadata';\nimport BigNumber from 'bignumber.js';\nimport { SOLANA_SERVICE_NAME, SOLANA_WALLET_DATA_CACHE_KEY } from './constants';\nimport { getWalletKey, KeypairResult } from './keypairUtils';\nimport type { Item, Prices, WalletPortfolio } from './types';\nimport bs58 from 'bs58';\nimport nacl from \"tweetnacl\";\n\nconst PROVIDER_CONFIG = {\n  BIRDEYE_API: 'https://public-api.birdeye.so',\n  MAX_RETRIES: 3,\n  RETRY_DELAY: 2000,\n  DEFAULT_RPC: 'https://api.mainnet-beta.solana.com',\n  TOKEN_ADDRESSES: {\n    SOL: 'So11111111111111111111111111111111111111112',\n    BTC: '3NZ9JMVBmGAqocybic2c7LQCJScmgsAZ6vQqTDzcqmJh',\n    ETH: '7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs',\n  },\n};\n\nexport type MintBalance = {\n  amount: string;\n  decimals: number;\n  uiAmount: number;\n};\n\ntype KeyedParsedTokenAccount = {\n  pubkey: PublicKey;\n  account: AccountInfo<ParsedAccountData>;\n};\n\ntype ParsedTokenAccountsResponse = Awaited<ReturnType<Connection['getParsedTokenAccountsByOwner']>>;\n/*\ntype ParsedTokenAccountsResponse = Promise<RpcResponseAndContext<\n    Array<{\n      pubkey: PublicKey;\n      account: AccountInfo<ParsedAccountData>;\n    }>\n  >>\n*/\n\nconst METADATA_PROGRAM_ID = new PublicKey(\n  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' // Metaplex Token Metadata Program ID\n);\n\n// CA: { }\n\n// hack these in here\nasync function getCacheExp(runtime: IAgentRuntime, key: string) {\n  const wrapper = await runtime.getCache<any>(key);\n  if (!wrapper) return false\n  // if exp is in the past\n  if (wrapper.exp < Date.now()) {\n    // no data\n    return false\n  }\n  return wrapper.data\n}\nasync function setCacheExp(runtime: IAgentRuntime, key: string, val: any, ttlInSecs: number) {\n  const exp = Date.now() + ttlInSecs * 1_000\n  return runtime.setCache<any>(key, {\n    exp,\n    data: val,\n  });\n}\n\nexport interface ISolanaPluginServiceAPI extends Service {\n  executeSwap: (\n    wallets: Array<{ keypair: any; amount: number }>, signal: any\n  ) => Promise<Record<string, unknown>>;\n  /*\n  executeSwap: (params: {\n    inputMint: string;\n    outputMint: string;\n    amount: string; // Amount in base units of input token\n    slippageBps: number;\n    payerAddress: string; // Public key of the payer (must match service's configured wallet)\n    priorityFeeMicroLamports?: number;\n  }) => Promise<{\n    success: boolean;\n    signature?: string;\n    error?: string;\n    outAmount?: string;\n    inAmount?: string;\n    swapUsdValue?: string;\n  }>;\n  */\n  //getSolBalance: (publicKey: string) => Promise<number>; // Returns SOL balance (not lamports)\n  /*\n  getTokenBalance: (\n    publicKey: string,\n    mintAddress: string\n  ) => Promise<{ amount: string; decimals: number; uiAmount: number } | null>;\n  */\n  getPublicKey: () => PublicKey | null; // Returns base58 public key\n}\n\n// split out off to keep this wrapper simple, so we can move it out of here\n// it's a single unit focused on one thing (reduce scope of main service)\nexport class SolanaWalletService extends IWalletService {\n  private _solanaService: SolanaService | null = null;\n\n  constructor(runtime?: IAgentRuntime) {\n    if (!runtime) throw new Error('runtime is required for solana service')\n    super(runtime);\n  }\n\n  private get solanaService(): SolanaService {\n    if (!this._solanaService) {\n      this._solanaService = this.runtime.getService('chain_solana') as SolanaService;\n      if (!this._solanaService) {\n        throw new Error('Solana Service is required for Solana Wallet Service');\n      }\n    }\n    return this._solanaService;\n  }\n\n  /**\n   * Retrieves the entire portfolio of assets held by the wallet.\n   * @param owner - Optional: The specific wallet address/owner to query.\n   * @returns A promise that resolves to the wallet's portfolio.\n   */\n  public async getPortfolio(owner?: string): Promise<siWalletPortfolio> {\n    if (owner && owner !== this.solanaService.getPublicKey()?.toBase58()) {\n      throw new Error(\n        `This SolanaService instance can only get the portfolio for its configured wallet: ${this.solanaService.getPublicKey()?.toBase58()}`\n      );\n    }\n    const wp: WalletPortfolio = await this.solanaService.updateWalletData(true)\n    const out: siWalletPortfolio = {\n      totalValueUsd: parseFloat(wp.totalUsd),\n      assets: wp.items.map(i => ({\n        address: i.address,\n        symbol: i.symbol,\n        balance:  Number(i.uiAmount ?? 0).toString(),\n        decimals: i.decimals,\n        valueUsd: Number(i.valueUsd ?? 0),\n      })),\n    }\n    return out;\n  }\n\n  /**\n   * Retrieves the balance of a specific asset in the wallet.\n   * @param assetAddress - The mint address or native identifier ('SOL') of the asset.\n   * @param owner - Optional: The specific wallet address/owner to query.\n   * @returns A promise that resolves to the user-friendly (decimal-adjusted) balance of the asset held.\n   */\n  public async getBalance(assetAddress: string, owner?: string): Promise<number> {\n    const ownerAddress: string | undefined = owner || (this.solanaService.getPublicKey()?.toBase58());\n    if (!ownerAddress) {\n      return -1\n    }\n    if (\n      assetAddress.toUpperCase() === 'SOL' ||\n      assetAddress === PROVIDER_CONFIG.TOKEN_ADDRESSES.SOL\n    ) {\n      //return this.getSolBalance(ownerAddress);\n      const balances = await this.solanaService.getBalancesByAddrs([ownerAddress])\n      const balance = balances[ownerAddress] ?? 0\n      return balance\n    }\n    //const tokenBalance = await this.getTokenBalance(ownerAddress, assetAddress);\n    //return tokenBalance?.uiAmount || 0;\n    const tokensBalances: Record<string, KeyedParsedTokenAccount[]> = await this.solanaService.getTokenAccountsByKeypairs([ownerAddress])\n    const heldTokens = tokensBalances[ownerAddress] || []\n    for(const t of heldTokens) {\n      //const decimals = t.account.data.parsed.info.tokenAmount.decimals;\n      //const balance = Number(amountRaw) / (10 ** decimals);\n      //const ca = new PublicKey(t.account.data.parsed.info.mint);\n      if (t.account.data.parsed.info.mint === assetAddress) {\n        return t.account.data.parsed.info.tokenAmount.uiAmount;\n      }\n    }\n    this.runtime.logger.log('could not find', assetAddress, 'in', heldTokens)\n    return -1\n  }\n\n  /**\n   * Transfers SOL from a specified keypair to a public key.\n   * The service's own wallet is used to pay transaction fees.\n   * @param {Keypair} from - The keypair of the account to send SOL from.\n   * @param {PublicKey} to - The public key of the account to send SOL to.\n   * @param {number} lamports - The amount of SOL to send, in lamports.\n   * @returns {Promise<string>} The transaction signature.\n   * @throws {Error} If the transfer fails.\n   */\n  public async transferSol(from: Keypair, to: PublicKey, lamports: number): Promise<string> {\n    try {\n      const payerKey = this.solanaService.getPublicKey()\n      if (!payerKey || payerKey === null) {\n        throw new Error(\n          'SolanaService is not initialized with a fee payer key, cannot send transaction.'\n        );\n      }\n      const connection = this.solanaService.getConnection()\n\n      const transaction = new TransactionMessage({\n        payerKey,\n        recentBlockhash: (await connection.getLatestBlockhash()).blockhash,\n        instructions: [\n          SystemProgram.transfer({\n            fromPubkey: from.publicKey,\n            toPubkey: to,\n            lamports: lamports,\n          }),\n        ],\n      }).compileToV0Message();\n\n      const versionedTransaction = new VersionedTransaction(transaction);\n\n      const serviceKeypair = await this.solanaService.getWalletKeypair()\n      versionedTransaction.sign([from, serviceKeypair]);\n\n      const signature = await connection.sendTransaction(versionedTransaction, {\n        skipPreflight: false,\n      });\n\n      const confirmation = await connection.confirmTransaction(signature, 'confirmed');\n      if (confirmation.value.err) {\n        throw new Error(\n          `Transaction confirmation failed: ${JSON.stringify(confirmation.value.err)}`\n        );\n      }\n\n      return signature;\n    } catch (error: unknown) {\n      this.runtime.logger.error({ error },'SolanaService: transferSol failed');\n      throw error;\n    }\n  }\n\n  /**\n   * Starts the Solana wallet service with the given agent runtime.\n   *\n   * @param {IAgentRuntime} runtime - The agent runtime to use for the Solana service.\n   * @returns {Promise<SolanaService>} The initialized Solana service.\n   */\n  static async start(runtime: IAgentRuntime): Promise<Service> {\n    runtime.logger.log(`SolanaWalletService start for ${runtime.character.name}`);\n\n    const solanaWalletService = new SolanaWalletService(runtime);\n    return solanaWalletService;\n  }\n\n  /**\n   * Stops the Solana wallet service.\n   *\n   * @param {IAgentRuntime} runtime - The agent runtime.\n   * @returns {Promise<void>} - A promise that resolves once the Solana service has stopped.\n   */\n  static async stop(runtime: IAgentRuntime): Promise<unknown> {\n    const client = runtime.getService(ServiceType.WALLET) as SolanaService | null;\n    if (!client) {\n      logger.error('SolanaWalletService not found during static stop');\n      return;\n    }\n    await client.stop();\n  }\n\n  /**\n   * @returns {Promise<void>} A Promise that resolves when the update interval is stopped.\n   */\n  async stop(): Promise<void> {\n  }\n}\n\n/**\n * Service class for interacting with the Solana blockchain and accessing wallet data.\n * @extends Service\n */\n// implements ISolanaPluginServiceAPI\nexport class SolanaService extends Service {\n  static override readonly serviceType: string = SOLANA_SERVICE_NAME;\n  public readonly capabilityDescription =\n    ('The agent is able to interact with the Solana blockchain, and has access to the wallet data' as unknown as typeof IWalletService.prototype.capabilityDescription);\n\n  private lastUpdate = 0;\n  private readonly UPDATE_INTERVAL = 2 * 60_000; // 2 minutes\n  private connection: Connection;\n  private publicKey: PublicKey | null = null;\n  private keypair: Keypair | null = null;\n  private exchangeRegistry: Record<number, any> = {};\n  // probably should be an array of numbers?\n  private subscriptions: Map<string, number> = new Map();\n\n  jupiterService: any;\n\n  // always multiple these\n  static readonly LAMPORTS2SOL = 1 / LAMPORTS_PER_SOL;\n  static readonly SOL2LAMPORTS = LAMPORTS_PER_SOL;\n\n  // Token decimals cache\n  private decimalsCache = new Map<string, number>([\n    ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', 6], // USDC\n    ['Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', 6], // USDT\n    ['So11111111111111111111111111111111111111112', 9], // SOL\n  ]);\n\n  /**\n   * Constructor for creating an instance of the class.\n   * @param {IAgentRuntime} runtime - The runtime object that provides access to agent-specific functionality.\n   */\n  constructor(runtime?: IAgentRuntime) {\n    if (!runtime) throw new Error('runtime is required for solana service')\n    super(runtime);\n    this.exchangeRegistry = {};\n    this.connection = new Connection(\n      runtime.getSetting('SOLANA_RPC_URL') || PROVIDER_CONFIG.DEFAULT_RPC\n    );\n\n    // jupiter support detection\n    // shouldn't even be here...\n    runtime.getServiceLoadPromise('JUPITER_SERVICE' as ServiceTypeName).then(async s => {\n      // now we have jupiter lets register our services\n      this.jupiterService = runtime.getService('JUPITER_SERVICE' as ServiceTypeName) as any;\n    })\n\n    getWalletKey(runtime, true)\n      .then(({ keypair }) => {\n        if (keypair) {\n          this.keypair = keypair\n        }\n      }).catch(e => {\n        // no private key\n        // not the end of the world, just somethings should be disabled...\n        runtime.logger.log('no useable solana private key')\n      })\n    // Initialize publicKey using getWalletKey\n    // FIXME: promise for this to be ready?\n    getWalletKey(runtime, false)\n      .then(({ publicKey }) => {\n        if (!publicKey) {\n          throw new Error('Failed to initialize public key');\n        }\n        this.publicKey = publicKey;\n\n        // get initial read\n        this.updateWalletData();\n        // only need to update wallet if it changes\n        // FIXME store this subscriptions somewhere...\n        this.subscribeToAccount(this.publicKey.toBase58(), async (accountAddress: string, accountInfo: unknown, context: unknown) => {\n          runtime.logger.log('Updating wallet data');\n          await this.updateWalletData(); // non-forced (respect: UPDATE_INTERVAL)\n        }).catch((error) => {\n          logger.error('Error subscribing to agent wallet updates:', error);\n        });\n      })\n      .catch((error) => {\n        logger.error(`Error initializing public key: ${error}`);\n      });\n    this.subscriptions = new Map();\n  }\n\n  /**\n   * Retrieves the connection object.\n   *\n   * @returns {Connection} The connection object.\n   */\n  public getConnection(): Connection {\n    return this.connection;\n  }\n\n  /**\n   * Registers a swap provider to execute swaps\n   * @param {any} provider - The provider to register\n   * @returns {Promise<number>} The ID assigned to the registered provider\n   */\n  async registerExchange(provider: any) {\n    const id = Object.values(this.exchangeRegistry).length + 1;\n    this.runtime.logger.success(`Registered ${provider.name} as Solana provider #${id}`);\n    this.exchangeRegistry[id] = provider;\n    return id;\n  }\n\n  /**\n   * Fetches data from the provided URL with retry logic.\n   * @param {string} url - The URL to fetch data from.\n   * @param {Record<string, any>} [options={}] - The options for the fetch request.\n   * @returns {Promise<unknown>} - A promise that resolves to the fetched data.\n   */\n  private async birdeyeFetchWithRetry(url: string, options: Record<string, any> = {}): Promise<unknown> {\n    let lastError: Error | undefined;\n\n    for (let i = 0; i < PROVIDER_CONFIG.MAX_RETRIES; i++) {\n      try {\n        const response = await (globalThis as any).fetch(url, {\n          ...options,\n          headers: {\n            Accept: 'application/json',\n            'x-chain': 'solana',\n            'X-API-KEY': this.runtime.getSetting('BIRDEYE_API_KEY'),\n            ...options.headers,\n          },\n        });\n\n        if (!response.ok) {\n          const errorText = await response.text();\n          throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);\n        }\n\n        return await response.json();\n      } catch (error) {\n        logger.error(`Attempt ${i + 1} failed: ${error}`);\n        logger.error({ error }, `Attempt ${i + 1} failed`);\n        lastError = error as Error;\n        if (i < PROVIDER_CONFIG.MAX_RETRIES - 1) {\n          await new Promise((resolve) => setTimeout(resolve, PROVIDER_CONFIG.RETRY_DELAY * 2 ** i));\n        }\n      }\n    }\n\n    if (lastError) throw lastError;\n  }\n\n  async batchGetMultipleAccountsInfo(pubkeys: PublicKey[], label: string): Promise<(AccountInfo<Buffer> | null)[]> {\n    const results: (AccountInfo<Buffer> | null)[] = [];\n    // do it in serial, why?\n    for (let i = 0; i < pubkeys.length; i += 100) {\n      const slice = pubkeys.slice(i, i + 100);\n      console.log('batchGetMultipleAccountsInfo(' + label + ') - getMultipleAccountsInfo', slice.length + '/' + pubkeys.length)\n      const infos = await this.connection.getMultipleAccountsInfo(slice);\n      results.push(...infos);\n    }\n    return results;\n  }\n\n  verifySignature({\n    publicKeyBase58, message, signatureBase64\n  }: {\n    message: string; signatureBase64: string; publicKeyBase58: string;\n  }): boolean {\n    const signature = Uint8Array.from(Buffer.from(signatureBase64, \"base64\"));\n    const messageUint8 = Uint8Array.from(Buffer.from(message, 'utf-8'));\n    const publicKeyBytes = bs58.decode(publicKeyBase58);\n\n    return nacl.sign.detached.verify(messageUint8, signature, publicKeyBytes);\n  }\n\n  // Solana should be here, it's already in the class/service name\n  // deprecate\n  verifySolanaSignature({\n    message, signatureBase64, publicKeyBase58\n  }: {\n    message: string; signatureBase64: string; publicKeyBase58: string;\n  }): boolean {\n    this.runtime.logger.warn('verifySolanaSignature is deprecated, use verifySignature')\n    return this.verifySignature({ message, signatureBase64, publicKeyBase58 })\n  }\n\n  //\n  // MARK: Addresses\n  //\n\n  public isValidAddress(address: string, onCurveOnly = false): boolean {\n    try {\n      const pubkey = new PublicKey(address);\n      if (onCurveOnly) {\n        return PublicKey.isOnCurve(pubkey.toBuffer());\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  // Solana should be here, it's already in the class/service name\n  // deprecate\n  public isValidSolanaAddress(address: string, onCurveOnly = false): boolean {\n    this.runtime.logger.warn('isValidSolanaAddress is deprecated, use isValidAddress')\n    return this.isValidAddress(address, onCurveOnly)\n  }\n\n  /**\n   * Validates a Solana address.\n   * @param {string | undefined} address - The address to validate.\n   * @returns {boolean} True if the address is valid, false otherwise.\n   */\n  public validateAddress(address: string | undefined): boolean {\n    if (!address) return false;\n    try {\n      // Handle Solana addresses\n      if (!/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address)) {\n        this.runtime.logger.warn(`Invalid Solana address format: ${address}`);\n        return false;\n      }\n\n      const pubKey = new PublicKey(address);\n      const isValid = Boolean(pubKey.toBase58());\n      //logger.log(`Solana address validation: ${address}`, { isValid });\n      return isValid;\n    } catch (error) {\n      //logger.error(`Address validation error: ${address} - ${error}`);\n      this.runtime.logger.error({ error }, `Address validation error: ${address}`);\n      return false;\n    }\n  }\n\n  // getParsedAccountInfo\n  private static readonly TOKEN_ACCOUNT_DATA_LENGTH = 165;\n  private static readonly TOKEN_MINT_DATA_LENGTH   = 82;\n\n  // deprecate\n  async getAddressType(address: string): Promise<string> {\n    const types = await this.getAddressesTypes([address])\n    return types[address]\n  }\n\n  async getAddressesTypes(addresses: string[]): Promise<Record<string, string>> {\n    const pubkeys = addresses.map(a => new PublicKey(a));\n    const infos = await this.batchGetMultipleAccountsInfo(pubkeys, 'getAddressesTypes');\n\n    const resultList: string[] = addresses.map((addr, i) => {\n      const info = infos[i];\n      if (!info) return 'Account does not exist';\n      const dataLength = info.data.length;\n      if (dataLength === 0) return 'Wallet';\n      if (dataLength === SolanaService.TOKEN_ACCOUNT_DATA_LENGTH) return 'Token Account';\n      if (dataLength === SolanaService.TOKEN_MINT_DATA_LENGTH) return 'Token';\n      return `Unknown (Data length: ${dataLength})`;\n    });\n\n    const out: Record<string, string> = {}\n    for(const i in addresses) {\n      const addr = addresses[i]\n      out[addr] = resultList[i]\n    }\n\n    return out\n  }\n\n  /**\n   * Detect Solana public keys (Base58) in a string\n   * @param input arbitrary text\n   * @param checkCurve whether to verify the key is on the Ed25519 curve via @solana/web3.js\n   * @returns list of detected public key strings\n   */\n  public detectPubkeysFromString(input: string, checkCurve = false): Array<string> {\n    const results = new Set<string>();\n    const regex = /\\b[1-9A-HJ-NP-Za-km-z]{32,44}\\b/g;\n    let match: RegExpExecArray | null;\n\n    while ((match = regex.exec(input)) !== null) {\n      const s = match[0];\n      try {\n        const buf = bs58.decode(s);\n        if (buf.length === 32) {\n          if (checkCurve) {\n            if (PublicKey.isOnCurve(buf)) {\n              results.add(s);\n            }\n          } else {\n            results.add(s);\n          }\n        }\n      } catch {\n        // Not valid Base58\n      }\n    }\n\n    return Array.from(results);\n  }\n\n  /**\n   * Detect Solana private keys in a string.\n   *\n   * âš ï¸ SECURITY WARNING: This method handles sensitive private key material.\n   * - Never log or expose the returned bytes\n   * - Clear sensitive data from memory after use\n   * - Consider if this method should be public\n   *\n   * Supports:\n   * - Base58 (â‰ˆ88 chars, representing 64 bytes â†’ 512 bits)\n   * - Hexadecimal (128 hex chars â†’ 64 bytes)\n   *\n   * Returns an array of objects with the original match and decoded bytes.\n   */\n  public detectPrivateKeysFromString(input: string): Array<{\n    format: 'base58' | 'hex',\n    match: string,\n    bytes: Uint8Array\n  }> {\n    const results: Array<{\n      format: 'base58' | 'hex';\n      match: string;\n      bytes: Uint8Array;\n    }> = [];\n\n    // Base58 regex (no 0,O,I,l)\n    const base58Regex = /\\b[1-9A-HJ-NP-Za-km-z]{86,90}\\b/g;\n    // Hex regex: 128 hex chars\n    const hexRegex = /\\b[a-fA-F0-9]{128}\\b/g;\n\n    let m: RegExpExecArray | null;\n\n    // Check Base58 matches\n    while ((m = base58Regex.exec(input)) !== null) {\n      const s = m[0];\n      try {\n        const buf = bs58.decode(s);\n        if (buf.length === 64) {\n          results.push({ format: 'base58', match: s, bytes: Uint8Array.from(buf) });\n        }\n      } catch {\n        // invalid base58 â€” ignore\n      }\n    }\n\n    // Check hex matches\n    while ((m = hexRegex.exec(input)) !== null) {\n      const s = m[0];\n      const buf = Buffer.from(s, 'hex');\n      if (buf.length === 64) {\n        results.push({ format: 'hex', match: s, bytes: Uint8Array.from(buf) });\n      }\n    }\n\n    return results;\n  }\n\n  //\n  // MARK: tokens\n  //\n\n  // deprecate\n  async getCirculatingSupply(mint: string) {\n\n   //const mintPublicKey = new PublicKey(mint);\n    // 1. Fetch all token accounts holding this token\n    const accounts = await this.connection.getParsedProgramAccounts(\n      TOKEN_PROGRAM_ID,\n      {\n        filters: [\n          { dataSize: 165 }, // size of token account\n          { memcmp: { offset: 0, bytes: mint } } // filter by mint\n        ]\n      }\n    );\n\n    const KNOWN_EXCLUDED_ACCOUNTS = [\n      \"MINT_AUTHORITY_WALLET\",\n      \"TREASURY_WALLET\",\n      \"BURN_ADDRESS\"\n    ];\n\n    // 2. Sum balances\n    let circulating = 0;\n    for (const acc of accounts) {\n      const info = (acc.account.data as any).parsed.info;\n      const owner = info.owner;\n\n      // Optional: exclude burn address or known treasury/mint holding\n      if (owner === \"11111111111111111111111111111111\") continue;\n      if (KNOWN_EXCLUDED_ACCOUNTS.includes(owner)) continue;\n\n      const amount = Number(info.tokenAmount.amount);\n      const decimals = info.tokenAmount.decimals;\n      circulating += amount / 10 ** decimals;\n    }\n\n    return circulating;\n  }\n\n  async getCirculatingSupplies(mints: string[]) {\n    // FIXME: use batchGetMultipleAccountsInfo? to efficiently check multiple\n    return Promise.all(mints.map(m => this.getCirculatingSupply(m)))\n  }\n\n  /**\n   * Asynchronously fetches the prices of SOL, BTC, and ETH tokens.\n   * Uses cache to store and retrieve prices if available.\n   * @returns A Promise that resolves to an object containing the prices of SOL, BTC, and ETH tokens.\n   */\n  private async fetchPrices(): Promise<Prices> {\n    const cacheKey = 'prices_sol_btc_eth';\n    const cachedValue = await this.runtime.getCache<Prices>(cacheKey);\n\n    // if cachedValue is JSON, parse it\n    // FIXME: how long do we cache this for?!?\n    if (cachedValue) {\n      logger.log('Cache hit for fetchPrices');\n      return cachedValue;\n    }\n\n    logger.log('Cache miss for fetchPrices');\n    const { SOL, BTC, ETH } = PROVIDER_CONFIG.TOKEN_ADDRESSES;\n    const tokens = [SOL, BTC, ETH];\n    const prices: Prices = {\n      solana: { usd: '0' },\n      bitcoin: { usd: '0' },\n      ethereum: { usd: '0' },\n    };\n\n    for (const token of tokens) {\n      const response = await this.birdeyeFetchWithRetry(\n        `${PROVIDER_CONFIG.BIRDEYE_API}/defi/price?address=${token}`\n      ) as any;\n\n      if (response?.data?.value) {\n        const price = response.data.value.toString();\n        prices[token === SOL ? 'solana' : token === BTC ? 'bitcoin' : 'ethereum'].usd = price;\n      }\n    }\n\n    await this.runtime.setCache<Prices>(cacheKey, prices);\n    return prices;\n  }\n\n   public async getDecimal(mintPublicKey: PublicKey): Promise<number> {\n     try {\n      const key = mintPublicKey.toString()\n      if (this.decimalsCache.has(key)) {\n        console.log('getDecimal - HIT', key)\n        return this.decimalsCache.get(key)!;\n      }\n\n      console.log('getDecimal - MISS getParsedAccountInfo', key)\n      const acc = await this.connection.getParsedAccountInfo(mintPublicKey);\n      const owner = acc.value?.owner.toString();\n\n      if (owner === TOKEN_PROGRAM_ID.toString()) {\n        //const mintPublicKey = new PublicKey(mintAddress);\n        console.log('getDecimal - MISS getMint', key)\n        const mintInfo = await getMint(this.connection, mintPublicKey);\n        //console.log('getDecimal - mintInfo', mintInfo)\n        this.decimalsCache.set(key, mintInfo.decimals);\n        return mintInfo.decimals;\n      } else if (owner === TOKEN_2022_PROGRAM_ID.toString()) {\n        const mintInfo = await getMint(\n          this.connection,\n          mintPublicKey,\n          undefined,                // optional commitment\n          TOKEN_2022_PROGRAM_ID     // specify the extensions token program\n        );\n        // address, mintAuthority, supply, decimals, isInitialized, freezeAuthority, tlvData\n        //console.log('getDecimal - mintInfo2022', mintInfo)\n        this.decimalsCache.set(key, mintInfo.decimals);\n        return mintInfo.decimals;\n      }\n      console.error(`Unknown owner type ${owner}`, acc)\n      return -1\n    } catch (error) {\n      // this will fail on a token2022 token\n      console.error(`Failed to fetch token decimals: ${error}`);\n      //throw error;\n      return -1;\n    }\n  }\n\n  public async getDecimals(mints: string[]): Promise<number[]> {\n    const mintPublicKeys = mints.map(a => new PublicKey(a))\n    return Promise.all(mintPublicKeys.map(a => this.getDecimal(a)))\n  }\n\n  public async getMetadataAddress(mint: PublicKey): Promise<PublicKey> {\n    // not an rpc call\n    const [metadataPDA] = await PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"metadata\"),\n        METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      METADATA_PROGRAM_ID\n    );\n    return metadataPDA;\n  }\n\n  // FIXME: cache me...\n  public async getTokenSymbol(mint: PublicKey): Promise<string | null> {\n    const metadataAddress = await this.getMetadataAddress(mint);\n    console.log('getTokenSymbol - getAccountInfo')\n    const accountInfo = await this.connection.getAccountInfo(metadataAddress);\n\n    if (!accountInfo || !accountInfo.data) return null;\n\n    const data = accountInfo.data;\n    //console.log('data', data)\n\n    // Skip the 1-byte key and 32+32+4+len name fields (you can parse these if needed)\n    let offset = 1 + 32 + 32;\n\n    // Name (length-prefixed string)\n    const nameLen = data.readUInt32LE(offset);\n    offset += 4 + nameLen;\n    //console.log('nameLen', nameLen)\n\n    // Symbol (length-prefixed string)\n    const symbolLen = data.readUInt32LE(offset);\n    offset += 4;\n    //console.log('symbolLen', symbolLen)\n\n    const symbol = data.slice(offset, offset + symbolLen).toString(\"utf8\").replace(/\\0/g, '');\n    //console.log('symbol', symbol)\n    return symbol;\n  }\n\n  // this is all local\n  private parseToken2022SymbolFromMintOrPtr = (mintData: Buffer): { symbol: string | null, ptr?: PublicKey } => {\n    // Try inline TokenMetadata extension first\n    const inline = getExtensionData(ExtensionType.TokenMetadata, mintData);\n    if (inline) {\n      try {\n        const md = unpackToken2022Metadata(inline);\n        const symbol = md?.symbol?.replace(/\\0/g, '').trim() || null;\n        return { symbol };\n      } catch {\n        // fall through to pointer\n      }\n    }\n\n    // Try MetadataPointer extension\n    const ptrExt = getExtensionData(ExtensionType.MetadataPointer, mintData) as\n      | { authority: Uint8Array; metadataAddress: Uint8Array }\n      | null;\n\n    if (ptrExt?.metadataAddress) {\n      return { symbol: null, ptr: new PublicKey(ptrExt.metadataAddress) };\n    }\n\n    return { symbol: null };\n  };\n\n  // cache me\n  public async getTokensSymbols(\n    mints: string[]\n  ): Promise<Record<string, string | null>> {\n    console.log('getTokensSymbols');\n    const mintKeys: PublicKey[] = mints.map(k => new PublicKey(k));\n\n    // Phase 1: Metaplex PDAs (your existing flow)\n    const metadataAddresses: PublicKey[] = await Promise.all(\n      mintKeys.map(mk => this.getMetadataAddress(mk))\n    );\n    const accountInfos = await this.batchGetMultipleAccountsInfo(\n      metadataAddresses,\n      'getTokensSymbols/Metaplex'\n    );\n\n    const out: Record<string, string | null> = {};\n    const needs2022: PublicKey[] = [];\n\n    mintKeys.forEach((token, i) => {\n      const accountInfo = accountInfos[i]; // AccountInfo<Buffer> | null\n\n      if (!accountInfo || !accountInfo.data) {\n        out[token.toBase58()] = null;\n        console.log('getTokensSymbols - adding', token.toBase58(), 'to token2022 list')\n        needs2022.push(token);\n        return;\n      }\n\n      try {\n        const data = accountInfo.data as Buffer;\n\n        // @metaplex-foundation/mpl-token-metadata\n        // Minimal Metaplex parse:\n        // key(1) + updateAuth(32) + mint(32)\n        let offset = 1 + 32 + 32;\n\n        // name\n        const nameLen = data.readUInt32LE(offset);\n        offset += 4 + nameLen;\n\n        // symbol\n        const symbolLen = data.readUInt32LE(offset);\n        offset += 4;\n        const symbol =\n          data.slice(offset, offset + symbolLen).toString('utf8').replace(/\\0/g, '').trim() || null;\n\n        out[token.toBase58()] = symbol;\n        if (!symbol) needs2022.push(token);\n      } catch (e) {\n        console.log('Metaplex parse failed; will try Token-2022:', e);\n        out[token.toBase58()] = null;\n        needs2022.push(token);\n      }\n    });\n\n    // Phase 2: Batch fetch *mint accounts* via your batch helper, then parse Token-2022 TLV\n    if (needs2022.length) {\n      const mintInfos = await this.batchGetMultipleAccountsInfo(\n        needs2022,\n        'getTokensSymbols/Token2022'\n      );\n\n      // First pass: parse inline metadata or collect pointer addresses\n      const ptrsToFetch: PublicKey[] = [];\n      const ptrOwnerByKey = new Map<string, string>(); // mint base58 -> owner key (for logging)\n\n      needs2022.forEach((mint, idx) => {\n        const info = mintInfos[idx] as AccountInfo<Buffer> | null;\n        if (!info || !info.data) {\n          console.log('getTokensSymbols - token2022 failed', mint.toBase58());\n          return;\n        }\n        if (!info.owner.equals(TOKEN_2022_PROGRAM_ID)) {\n          console.log('getTokensSymbols - not a token2022', mint.toBase58());\n          return;\n        }\n\n        const { symbol, ptr } = this.parseToken2022SymbolFromMintOrPtr(info.data);\n        if (symbol) {\n          out[mint.toBase58()] = symbol;\n        } else if (ptr) {\n          ptrsToFetch.push(ptr);\n          ptrOwnerByKey.set(ptr.toBase58(), mint.toBase58());\n        } else {\n          console.log('getTokensSymbols - no TokenMetadata or pointer', mint.toBase58());\n        }\n      });\n\n      // Second pass: fetch and parse pointer accounts (batch)\n      if (ptrsToFetch.length) {\n        const pointerInfos = await this.batchGetMultipleAccountsInfo(\n          ptrsToFetch,\n          'getTokensSymbols/Token2022Pointer'\n        );\n\n        ptrsToFetch.forEach((ptrPk, idx) => {\n          const pinfo = pointerInfos[idx] as AccountInfo<Buffer> | null;\n          const mintB58 = ptrOwnerByKey.get(ptrPk.toBase58())!;\n          if (!pinfo?.data) {\n            console.log('getTokensSymbols - pointer account missing', ptrPk.toBase58(), 'for mint', mintB58);\n            return;\n          }\n          try {\n            const md = unpackToken2022Metadata(pinfo.data);\n            const symbol = md?.symbol?.replace(/\\0/g, '').trim() || null;\n            if (symbol) {\n              out[mintB58] = symbol;\n            } else {\n              console.log('getTokensSymbols - pointer metadata has no symbol', ptrPk.toBase58(), 'for mint', mintB58);\n            }\n          } catch (e) {\n            console.log('getTokensSymbols - failed to unpack pointer metadata', ptrPk.toBase58(), e);\n          }\n        });\n      }\n    }\n\n    return out;\n  }\n\n  public async getSupply(CAs: string[]) {\n    //console.log('getSupply CAs', CAs.length)\n    const mintKeys: PublicKey[] = CAs.map((ca: string) => new PublicKey(ca));\n    const mintInfos = await this.batchGetMultipleAccountsInfo(mintKeys, 'getSupply')\n\n    const results = mintInfos.map((accountInfo, idx) => {\n      if (!accountInfo) {\n        return { address: CAs[idx], error: 'Account not found' };\n      }\n\n      // accountInfo.data is a Node Buffer; make a Uint8Array *view* (no copy)\n      const buf = accountInfo.data as Buffer;\n      const u8 = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n\n      // MintLayout.decode accepts Uint8Array (and Buffer). Use u8 to avoid type fuss.\n      const mint = MintLayout.decode(u8);\n\n      // Normalize types\n      const decimals: number = mint.decimals;\n      const supply: bigint = BigInt(mint.supply.toString()); // ensure bigint\n\n      // bigint-safe 10^decimals\n      let denom = 1n;\n      for (let i = 0; i < decimals; i++) denom *= 10n;\n\n      return {\n        address: CAs[idx],\n        biSupply: supply, // keep as bigint for exactness\n        // Human-readable (use BigNumber to avoid float issues for large values)\n        human: new BigNumber(supply.toString()).dividedBy(10 ** decimals),\n        decimals,\n      };\n    });\n\n    // then convert to object\n    const out = Object.fromEntries(results.map(r => [r.address, {\n      supply: r.biSupply,\n      decimals: r.decimals,\n      human: r.human\n    }]));\n    // realSupply = supply / Math.pow(10, decimals)\n    return out\n  }\n\n  public async parseTokenAccounts(heldTokens: any [], options: { notOlderThan?: number } = {}) {\n    // decimalsCache means we don't need all I think\n    // we need structure token cache\n    // stil need them for symbol\n\n    // ATAs?\n    /*\n    for(const t of heldTokens) {\n      //pubkey / account\n      // account: data, owner, space, lamports, rentEpoch, executables\n      console.log('held', t.pubkey.toBase58(), t.account.data.program, t.account.data.parsed)\n      // data: program, parsed, ??\n      // parsed: type: \"account\", info\n      // t22 info: extensions, isNative, mint, owner, state, tokenAmount (amount, decimals, uiAmount, uiAmountString)\n      // spl info: isNative, mint, owner, state, tokenAmount (amount, decimals, uiAmount, uiAmountString)\n    }\n    */\n\n    const nowInMs = Date.now()\n\n    //console.log('cache', cache)\n\n    //const mintKeys: PublicKey[] = []\n    const acceptableInMs = options.notOlderThan ?? 60 * 60_000 // 1 hour default\n    let cache = []\n    // what about immutable?\n    if (acceptableInMs !== 0) {\n      console.time('cacheCheck')\n      cache = await Promise.all(heldTokens.map(t => this.runtime.getCache<any>('solana_token_meta_' + t.account.data.parsed.info.mint)));\n      console.timeEnd('cacheCheck')\n    }\n\n    let misses = 0\n    const fetchTokens = []\n    const goodCache: Record<string, { isMutable: boolean } & Record<string, unknown> & { balanceUi: number }> = {}\n    for(const i in heldTokens) {\n      const t = heldTokens[i]\n      if (cache[i]) {\n        const c = cache[i]\n        let useCache = false\n        if (c.data.isMutable === false) {\n          // immutable data is always good\n          useCache = true\n        } else //otherwise\n        if (acceptableInMs !== 0) {\n          const diff = nowInMs - c.setAt\n          //console.log('cache for', t.account.data.parsed.info.mint, 'is', diff.toLocaleString() + 'ms old')\n          // freshness check\n          if (diff < acceptableInMs) {\n            useCache = true\n          //} else {\n            //console.log('parseTokenAccounts - MISS', mint)\n          }\n        }\n        //useCache = false\n        if (useCache) {\n          // HIT\n          //console.log('parseTokenAccounts - HIT', mint)\n          const mint = t.account.data.parsed.info.mint\n          //console.log('info', t.account.data.parsed.info)\n          const { amount: raw, decimals } = t.account.data.parsed.info.tokenAmount;\n          const balanceUi = Number(raw) / 10 ** decimals;\n\n          goodCache[mint] = { ...c.data, balanceUi }\n          continue\n        }\n      }\n      fetchTokens.push(heldTokens[i])\n      misses++\n    }\n    this.runtime.logger.debug('parseTokenAccounts havs', heldTokens.length - misses + '/' + heldTokens.length, 'in cache (1hr default)')\n\n    //const mintKeys: PublicKey[] = heldTokens.map(t => new PublicKey(t.account.data.parsed.info.mint))\n\n    // --- build unique mint sets by program ---\n    const toB58 = (pk: string | PublicKey) => typeof pk === \"string\" ? pk : pk.toBase58()\n\n    const TOKEN_ID_B58  = TOKEN_PROGRAM_ID.toBase58()\n    const TOKEN2022_B58 = TOKEN_2022_PROGRAM_ID.toBase58()\n\n    const t22MintKeys: PublicKey[] = Array.from(new Set(\n      fetchTokens\n        .filter(t => toB58(t.account.owner) === TOKEN2022_B58)\n        .map(t => t.account.data.parsed.info.mint as string)\n    )).map(s => new PublicKey(s))\n\n    const classicMintKeys: PublicKey[] = Array.from(new Set(\n      fetchTokens\n        .filter(t => toB58(t.account.owner) === TOKEN_ID_B58)\n        .map(t => t.account.data.parsed.info.mint as string)\n    )).map(s => new PublicKey(s))\n\n    // --- phase 1: batch fetch Token-2022 mint *only* ---\n\n    // we might want to get all keys here so we can get the supply\n    const allMintKeys: PublicKey[] = Array.from(new Set(\n      fetchTokens.map((t: any) => t.account.data.parsed.info.mint as string)\n    )).map(s => new PublicKey(s))\n\n    //\n    const mintInfos = await this.batchGetMultipleAccountsInfo(allMintKeys, \"t22-mints\")\n\n    /*\n    const t22MintInfos = t22MintKeys.length\n      ? await this.batchGetMultipleAccountsInfo(t22MintKeys, \"t22-mints\")\n      : [];\n    */\n\n    // detect who has the TLV TokenMetadata extension\n    const hasT22Meta = new Set<string>();\n    // detect TLV + compute \"isMutable\" from updateAuthority (Some/None)\n    const t22IsMutable = new Map<string, boolean>();         // mint -> isMutable\n\n    /*\n    function readT22IsMutable(ext: Buffer): { isMutable: boolean } {\n      // Token-2022 TokenMetadata starts with Option<Pubkey>:\n      // tag (u8: 0=None, 1=Some) + pubkey (32 bytes if Some), then name(32), symbol(10), uri(200)...\n      const tag = ext.readUInt8(0);\n      if (tag === 0) return { isMutable: false };            // no update authority â†’ immutable\n      if (tag === 1) return { isMutable: true };             // has update authority â†’ mutable\n      // defensive fallback if layout/version differs:\n      return { isMutable: true };\n    }\n    */\n\n    // top of the function (near other maps/sets)\n    const t22Symbols = new Map<string, string>(); // mint -> symbol (Token-2022 TLV)\n    const mpSymbols  = new Map<string, string>(); // mint -> symbol (Metaplex PDA)\n    // metadata-pointer map (mint -> pointer address)\n    const t22PtrAddrByMint = new Map<string, PublicKey>();\n    const mpSupply = new Map<string, string>();          // mint -> supply\n\n    // Trim trailing NULs and whitespace\n    const stripNulls = (s: string) => s.replace(/\\u0000+$/g, \"\").trim();\n    // helper to read fixed-size, null-padded utf8 strings (Token-2022 TLV)\n    /*\n    function readFixedCString(buf: Buffer, start: number, len: number): string {\n      const slice = buf.subarray(start, start + len);\n      const nul = slice.indexOf(0);\n      const end = nul >= 0 ? nul : slice.length;\n      return stripNulls(slice.subarray(0, end).toString(\"utf8\").trim());\n    }\n    */\n\n    // Borsh-encoded string: u32 LE length + bytes (Metaplex PDA)\n    function readBorshStringSafe(buf: Buffer, offObj: { off: number }): string {\n      if (offObj.off + 4 > buf.length) return \"\";               // truncated\n      const len = buf.readUInt32LE(offObj.off);\n      offObj.off += 4;\n      if (len < 0 || offObj.off + len > buf.length) {\n        // corrupted length; consume the remainder to avoid infinite loops\n        const bytes = buf.subarray(offObj.off, buf.length);\n        offObj.off = buf.length;\n        return stripNulls(bytes.toString(\"utf8\"));\n      }\n      const bytes = buf.subarray(offObj.off, offObj.off + len);\n      offObj.off += len;\n      return stripNulls(bytes.toString(\"utf8\"));\n    }\n\n    function readU32LE(buf: Buffer, offObj: { off: number }): number {\n      if (offObj.off + 4 > buf.length) throw new Error('oob u32');\n      const v = buf.readUInt32LE(offObj.off);\n      offObj.off += 4;\n      return v;\n    }\n\n    function readVecU8AsString(buf: Buffer, offObj: { off: number }): string {\n      const len = readU32LE(buf, offObj);\n      if (len < 0 || offObj.off + len > buf.length) throw new Error('oob str');\n      const s = buf.subarray(offObj.off, offObj.off + len).toString('utf8');\n      offObj.off += len;\n      return s.trim();\n    }\n    function allZero32(b: Buffer) { for (let i=0;i<32;i++) if (b[i]!==0) return false; return true; }\n\n    // Parse the Token-2022 TokenMetadata TLV (just the Value slice)\n    function parseToken2022MetadataTLV(ext: Buffer): {\n      isMutable: boolean; updateAuthority?: string; mint: string; name: string; symbol: string; uri: string; additional?: unknown;\n    } {\n      const o = { off: 0 };\n      // 32B updateAuthority (all-zero = None)\n      const uaBytes = ext.subarray(o.off, o.off + 32); o.off += 32;\n      const isMutable = !allZero32(uaBytes);\n      const updateAuthority = isMutable ? new PublicKey(uaBytes).toBase58() : undefined;\n\n      // 32B mint\n      const mint = new PublicKey(ext.subarray(o.off, o.off + 32)).toBase58(); o.off += 32;\n\n      // Strings\n      const name = readVecU8AsString(ext, o);\n      const symbol = readVecU8AsString(ext, o);\n      //console.log('t22 symbol', symbol)\n      const uri = readVecU8AsString(ext, o);\n\n      // Optional Vec<(String,String)>\n      const additional: Array<[string,string]> = [];\n      if (o.off + 4 <= ext.length) {\n        const n = readU32LE(ext, o);\n        for (let i = 0; i < n; i++) additional.push([readVecU8AsString(ext, o), readVecU8AsString(ext, o)]);\n      }\n      return { isMutable, updateAuthority, mint, name, symbol, uri, additional: additional.length ? additional : undefined };\n    }\n\n    function formatSupplyUiAmount(amount: bigint, decimals: number): string {\n      let denom = 1n;\n      for (let i = 0; i < decimals; i++) denom *= 10n;\n\n      const whole = amount / denom;\n      const frac = (amount % denom).toString().padStart(decimals, '0');\n      return decimals === 0 ? whole.toString() : `${whole}.${frac}`.replace(/\\.$/, '');\n    }\n\n    //console.log('t22MintKeys', t22MintKeys.length)\n    //t22MintKeys.forEach((mk, i) => {\n    allMintKeys.forEach((mk, i) => {\n      //const info = t22MintInfos[i];\n      const info = mintInfos[i];\n\n      if (!info?.data) return;\n      //console.log('token22 info', mk.toBase58(), info)\n      // lamports, data, owner, executable, rentEpoch, space\n\n      // 1) Sanity: owner must be TOKEN_2022_PROGRAM_ID\n      const isT22 = info.owner?.toBase58?.() === TOKEN_2022_PROGRAM_ID.toBase58()\n      //if (!isT22) {\n        //console.warn(\"mint not owned by TOKEN_2022\", mk.toBase58(), info.owner?.toBase58?.());\n      //}\n\n      // 2) List all extensions present\n      //const exts = getExtensionTypes(info.data); // returns ExtensionType[]\n      //console.log(mk.toBase58(), \"extensions:\", exts.map(x => ExtensionType[x] ?? x));\n      const mintKeyStr = mk.toBase58()\n\n      if (isT22) {\n        const parsedMint = unpackMint(mk, info, TOKEN_2022_PROGRAM_ID);\n        // parsedMint.address.toBase58(), is the same as mintKeyStr\n        const uiSupply = formatSupplyUiAmount(parsedMint.supply, parsedMint.decimals)\n        //console.log('t22', mintKeyStr, 'parsedMint', parsedMint.supply, parsedMint.decimals, '=>', uiSupply)\n        // address, mintAuthority, supply, decimals, isInitialized, freezeAuthority, tlvData\n\n        mpSupply.set(mintKeyStr, uiSupply) // as BigNumber\n        if (this.decimalsCache.get(mintKeyStr) !== parsedMint.decimals) {\n          console.log('decimalsCache', this.decimalsCache.get(mintKeyStr), '!== parsedMint.decimals', parsedMint.decimals)\n        }\n        this.decimalsCache.set(mintKeyStr, parsedMint.decimals)\n        // not sure this is right\n        // address, mintAuthority, supply, decimals, isInitialized, freezeAuthority, tlvData\n\n        const tlv = parsedMint.tlvData ?? Buffer.alloc(0);\n        //const exts2 = getExtensionTypes(tlv);\n        //console.log(mk.toBase58(), \"extensions:\", exts2.map(x => ExtensionType[x] ?? x));\n\n        // TokenMetadata TLV\n        const mdExt = getExtensionData(ExtensionType.TokenMetadata, tlv);\n        if (mdExt) {\n          //console.log('tlv mdExt', mdExt)\n          const res = parseToken2022MetadataTLV(mdExt)\n          //console.log('res', res)\n\n          hasT22Meta.add(mintKeyStr);\n          t22IsMutable.set(mintKeyStr, res.isMutable);\n          t22Symbols.set(mintKeyStr, res.symbol);\n\n          /*\n          //const res2 = parseToken2022MetadataTLV(tlv)\n          //console.log('res2', res2)\n          console.log('token22 has ext.TokenMetadata', mk.toBase58())\n\n          const tag = mdExt.readUInt8(0);       // 0=None, 1=Some(updateAuthority)\n          let off = 1 + (tag === 1 ? 32 : 0);\n          const name   = readFixedCString(mdExt, off, 32); off += 32;\n          const symbol = readFixedCString(mdExt, off, 10); off += 10;\n          console.log('t22', symbol)\n          hasT22Meta.add(mk.toBase58());\n          t22IsMutable.set(mk.toBase58(), tag === 1);\n          t22Symbols.set(mk.toBase58(), symbol);\n          */\n          return;\n        }\n      } else {\n        // spl token\n        const buf = info!.data as Buffer;\n        const u8  = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n\n        // slice the header as a Uint8Array, not Buffer\n        const header = u8.subarray(0, MintLayout.span);\n        const mintData = MintLayout.decode(header);\n        //console.log('spl mintData', mintData)\n        const uiSupply = formatSupplyUiAmount(mintData.supply, mintData.decimals)\n        //console.log('spl', mintKeyStr, 'mintData', mintData.supply, mintData.decimals, '=>', uiSupply.toLocaleString())\n        mpSupply.set(mintKeyStr, uiSupply) // as BigNumber\n        if (this.decimalsCache.get(mintKeyStr) !== mintData.decimals) {\n          console.log('decimalsCache', this.decimalsCache.get(mintKeyStr), '!== mintData.decimals', mintData.decimals)\n        }\n        this.decimalsCache.set(mintKeyStr, mintData.decimals)\n      }\n\n      /*\n      const ext = getExtensionData(ExtensionType.TokenMetadata, info.data);\n      if (ext) {\n        console.log('token22 has ext', mk.toBase58())\n\n        // mutable\n        hasT22Meta.add(mk.toBase58());\n        t22IsMutable.set(mk.toBase58(), readT22IsMutable(ext).isMutable);\n\n        // symbol\n        // decode fixed fields: name(32), symbol(10), uri(200)\n        let off = 1 + (tag === 1 ? 32 : 0); // skip tag + optional pubkey\n        const name   = readFixedCString(ext, off, 32); off += 32;\n        const symbol = readFixedCString(ext, off, 10); off += 10;\n        console.log('t22 name', name, 'symbol', symbol)\n        // (uri would be at off with length 200 if you need it)\n\n        t22Symbols.set(mk.toBase58(), symbol);\n        return;\n      }\n      // Fallback: check for Metadata Pointer extension\n      const ptrExt = getExtensionData(ExtensionType.MetadataPointer, info.data);\n      if (!ptrExt) {\n        console.log('token22 no metaplex info')\n        return;\n      }\n\n      // Layout: 32 bytes authority + 32 bytes metadataAddress\n      if (ptrExt.length < 64) {\n        console.warn(\"MetadataPointer too short\", mk.toBase58(), ptrExt.length);\n        return;\n      }\n      const metaAddr = new PublicKey(ptrExt.subarray(32, 64));\n      const mint58 = mk.toBase58();\n      t22PtrAddrByMint.set(mint58, metaAddr);\n      t22PtrMintByAddr.set(metaAddr.toBase58(), mint58);\n      */\n    });\n\n    // --- phase 2: fetch ONLY the Metaplex PDAs we actually need ---\n    // (classic mints + Token-2022 mints that DON'T have the TLV)\n    const missingT22s = t22MintKeys.filter(m => !hasT22Meta.has(m.toBase58()))\n    console.log('missingT22s', missingT22s.length)\n    const mpMintKeys = [...classicMintKeys, ...missingT22s];\n\n    //console.log('mpMintKeys', mpMintKeys.length)\n\n    const mpAddrs: PublicKey[] = await Promise.all(mpMintKeys.map(m => this.getMetadataAddress(m)));\n    const mpInfos = mpAddrs.length\n      ? await this.batchGetMultipleAccountsInfo(mpAddrs, \"metaplex-md\")\n      : [];\n\n    // parse Metaplex isMutable (u8) after primarySaleHappened\n    const mpIsMutable = new Map<string, boolean>();          // mint -> isMutable\n    mpMintKeys.forEach((mk, i) => {\n      const acc = mpInfos[i];\n      //console.log('acc', acc)\n      // metadata address\n      // lamports, data, owner, executable, rentEpoch, space\n      const data = acc?.data;\n      if (!data?.length) return;\n      //if (!data || data.length < MintLayout.span) return; // must be a mint account\n\n      const mintAddrStr = mk.toBase58()\n\n      /*\n      if (classicMintKeys.find(k => k.equals(mk))) {\n        const header = data.subarray(0, MintLayout.span);\n        const mintData = MintLayout.decode(header);\n        console.log('classic', mintData)\n      } else {\n        console.log('t22')\n      }\n      */\n\n      /*\n      const header = data.subarray(0, MintLayout.span);\n      const mintData = MintLayout.decode(header);\n\n      const rawSupply = BigInt(mintData.supply.toString()); // BN -> bigint\n      const decimals  = mintData.decimals as number;\n      const isInit    = !!mintData.isInitialized;\n      console.log('rawSupply', rawSupply2, 'decimals', decimals)\n\n      const uiSupply = Number(rawSupply) / 10 ** mintData.decimals;\n      console.log('mintData', mintData)\n      mpSupply.set(mintAddrStr, uiSupply)\n      */\n\n      const limit = data.length;\n      const need = (n: number) => n <= limit;\n\n      let off = 1 + 32 + 32; // key + updateAuthority + mint\n      if (!need(off)) return;\n\n      const offObj = { off };\n      const name   = readBorshStringSafe(data, offObj);\n      const symbol = readBorshStringSafe(data, offObj);\n      /* const uri    = */ readBorshStringSafe(data, offObj);\n\n      if (offObj.off + 2 > limit) return;\n      /* const sellerFee = */ data.readUInt16LE(offObj.off); offObj.off += 2;\n\n      if (offObj.off + 1 > limit) return;\n      const hasCreators = data.readUInt8(offObj.off); offObj.off += 1;\n\n      if (hasCreators) {\n        if (offObj.off + 4 > limit) return;\n        const n = data.readUInt32LE(offObj.off); offObj.off += 4;\n        const creatorSize = 32 + 1 + 1;\n        const bytesNeeded = n * creatorSize;\n        if (offObj.off + bytesNeeded > limit) return;\n        offObj.off += bytesNeeded;\n      }\n\n      if (offObj.off + 1 > limit) return; // primarySaleHappened (u8)\n      offObj.off += 1;\n\n      if (offObj.off + 1 > limit) return; // isMutable (u8)\n      const isMutable = data.readUInt8(offObj.off) === 1;\n\n      mpIsMutable.set(mintAddrStr, isMutable);\n      mpSymbols.set(mintAddrStr, symbol);\n    });\n\n    /*\n    // --- build the Metaplex PDA list we actually need ---\n    const mintsNeedingMP = [\n      ...classicMintKeys,\n      ...t22MintKeys.filter(mk => !hasT22Meta.has(mk.toBase58())),\n    ];\n    const mpAddrs = await Promise.all(mintsNeedingMP.map(m => this.getMetadataAddress(m)));\n\n    // --- one \"mega\" batch: t22 mints (already fetched) + needed PDAs ---\n    const allAddrs: PublicKey[] = [...mintsNeedingMP, ...t22MintKeys].map((pk, i) => pk); // just to show the idea\n    const allInfos = await this.batchGetMultipleAccountsInfo(\n      [...mpAddrs, ...t22MintKeys],                 // << one RPC call in your helper (it can chunk internally)\n      \"mega\"\n    );\n    // --- quick indexers by address ---\n    const infoByAddr = new Map<string, any>();\n    [...mpAddrs, ...t22MintKeys].forEach((pk, i) => infoByAddr.set(pk.toBase58(), allInfos[i]));\n\n    // helper getters\n    const getMpInfo   = (mint: PublicKey) => infoByAddr.get((await this.getMetadataAddress(mint)).toBase58()) ?? null;\n    const getT22Mint  = (mint: PublicKey) => infoByAddr.get(mint.toBase58()) ?? null;\n    */\n\n    const t22Set = new Set(t22MintKeys.map(k => k.toBase58()));\n\n    const results = heldTokens.map((t) => {\n      const mintStr: string = t.account.data.parsed.info.mint as string;\n      const mintKey: PublicKey = new PublicKey(mintStr);\n      const is2022: boolean = t22Set.has(mintStr);\n\n      // decimals / balance (unchanged)\n      const { amount: raw, decimals } = t.account.data.parsed.info.tokenAmount;\n      const balanceUi: number = Number(raw) / 10 ** decimals;\n\n      // pick the right source for isMutable\n      const isMutable: boolean | null =\n        (is2022 && hasT22Meta.has(mintStr))\n          ? (t22IsMutable.get(mintStr) ?? null)\n          : (mpIsMutable.get(mintStr) ?? null);\n\n      const symbol: string | null =\n        (is2022 && hasT22Meta.has(mintStr))\n          ? (t22Symbols.get(mintStr) ?? null)\n          : (mpSymbols.get(mintStr) ?? null);\n\n      let supply: string | number | null = mpSupply.get(mintStr) ?? null\n      if (supply) supply = parseFloat(supply)\n\n      return {\n        mint: mintKey.toBase58(),\n        symbol,\n        supply,\n        tokenProgram: is2022 ? \"Token-2022\" : \"Token\",\n        decimals,\n        balanceUi,\n        isMutable, // boolean | null\n      };\n    });\n\n    /*\n    //const mintInfos = await this.batchGetMultipleAccountsInfo(t22MintKeys, \"parseTokenAccounts-t22-mints\")\n    //const accountInfos = await this.batchGetMultipleAccountsInfo(metadataAddresses, 'parseTokenAccounts')\n\n    const [mintInfos, accountInfos] = await Promise.all([\n      this.batchGetMultipleAccountsInfo(t22MintKeys, \"parseTokenAccounts-t22-mints\"),\n      this.batchGetMultipleAccountsInfo(metadataAddresses, 'parseTokenAccounts'),\n    ])\n    const t22MetaByMint = new Map<string, { name: string; symbol: string; uri: string } | null>();\n    t22MintKeys.forEach((mintKey, i) => {\n      const info = mintInfos[i];\n      if (!info?.data) { t22MetaByMint.set(mintKey.toBase58(), null); return; }\n      const ext = getExtensionData(ExtensionType.TokenMetadata, info.data);\n      if (!ext) { t22MetaByMint.set(mintKey.toBase58(), null); return; }\n      t22MetaByMint.set(mintKey.toBase58(), decodeT22TokenMetadata(ext));\n    });\n    */\n\n\n    //console.log('parseTokenAccounts - getMultipleAccountsInfo')\n    //const accountInfos = await this.connection.getMultipleAccountsInfo(metadataAddresses);\n    //console.log('accountInfos', accountInfos) // works\n\n    /*\n    const results = heldTokens.map((token: any, i: number) => {\n      const metadataInfo = accountInfos[i];      // raw AccountInfo | null\n      //console.log('metadataInfo', metadataInfo)\n      const mintKey      = mintKeys[i];\n\n      const mintOwner = metadataInfo?.owner; // PublicKey | undefined\n      const isToken2022 = !!mintOwner && mintOwner.equals(TOKEN_2022_PROGRAM_ID);\n      const isClassic   = !!mintOwner && mintOwner.equals(TOKEN_PROGRAM_ID);\n\n      if (metadataInfo === null) {\n        // what's going on with these? atas?\n        // NFTs and token2022\n        console.log('mdInfo null for', mintKey.toBase58())\n      }\n\n      // ----- Metaplex metadata deserialisation -----\n      let symbol: string | null = null;\n      let updateAuthority: PublicKey | null = null;\n      let isMutable: boolean | null = null;\n\n      function readString(data: Buffer, offset: number) {\n        const len = data.readUInt32LE(offset);\n        const start = offset + 4;\n        const end = start + len;\n        const value = data.slice(start, end).toString(\"utf8\").replace(/\\0/g, \"\");\n        return { value, offset: end };\n      }\n\n      if (metadataInfo?.data?.length) {\n        const data = metadataInfo.data;\n\n        // key (1) + updateAuthority (32) + mint (32)\n        updateAuthority = new PublicKey(data.slice(1, 33));\n        let offset = 1 + 32 + 32;\n\n        // name\n        ({ offset } = readString(data, offset));\n\n        // symbol\n        const sym = readString(data, offset);\n        symbol = sym.value;\n        offset = sym.offset;\n\n        // uri\n        ({ offset } = readString(data, offset));\n\n        // sellerFeeBasisPoints (u16)\n        offset += 2;\n\n        // creators: Option<Vec<Creator>>\n        const hasCreators = data.readUInt8(offset); offset += 1;\n        if (hasCreators) {\n          const n = data.readUInt32LE(offset); offset += 4;\n          // each creator: 32 (pubkey) + 1 (verified) + 1 (share)\n          offset += n * (32 + 1 + 1);\n        }\n\n        // primarySaleHappened (u8)\n        const primarySaleHappened = data.readUInt8(offset) === 1; offset += 1;\n\n        // isMutable (u8)\n        isMutable = data.readUInt8(offset) === 1; offset += 1;\n\n        // (Optional fields may follow; no need to parse them to get isMutable)\n      }\n\n      // ----- Token-account figures (already parsed) -----\n      //console.log('accountdata', token.account.data.parsed)\n      const { amount: raw, decimals } = token.account.data.parsed.info.tokenAmount;\n      this.decimalsCache.set(mintKey, decimals);\n\n      //if (mintKey.toBase58() !== token.account.data.parsed.info.mint) {\n        //console.log('NOT_EQUAL', mintKey, token.account.data.parsed.info.mint)\n      //}\n\n      if (!isMutable) {\n        //console.log('hard caching', mintKey)\n      }\n\n      const balanceUi = Number(raw) / 10 ** decimals;\n\n\n      return {\n        mint: mintKey.toBase58(),\n        symbol,\n        decimals,\n        balanceUi,\n      };\n    });\n    */\n    // an array\n    //console.log('results', results[0]) // sample result\n\n    // background slow save\n    (async () => {\n      console.time('saveCache')\n      for(const t of results) {\n        const copy: any = {...t}\n        delete copy.balanceUi\n        delete copy.mint\n        const key = 'solana_token_meta_' + t.mint\n        // we're just caching them all\n        //console.log('need to cache', key)\n\n        // one at a time because we'll get dead locks otherwise\n        await this.runtime.setCache<any>(key, {\n          setAt: nowInMs,\n          data: copy,\n        });\n        /*\n        if (t.isMutable === false) {\n          delete copy.isMutable\n          const key = 'solana_token_meta_' + t.mint\n          console.log('need to hard cache', key)\n          // could be a disk cache... to avoid db locking issues\n          this.runtime.setCache<any>(key, {\n            setAt: tsInMs,\n            data: copy,\n          });\n        } else {\n          const key = 'solana_token_muta_meta_' + t.mint\n          console.log('need to soft cache', key)\n          // could be a disk cache... to avoid db locking issues\n          this.runtime.setCache<any>(key, {\n            setAt: tsInMs,\n            data: copy,\n          });\n        }\n        */\n      }\n      console.timeEnd('saveCache')\n    })().catch(err => console.error('solana:parseTokenAccounts - cache save failed:', err))\n\n    // then convert array to keyed object\n    const out = Object.fromEntries(results.map((r: any) => [r.mint, {\n      symbol: r.symbol,\n      supply: r.supply,\n      tokenProgram: r.tokenProgram,\n      decimals: r.decimals,\n      balanceUi: r.balanceUi,\n      isMutable: r.isMutable,\n    }]));\n\n    /*\n    for(const i in heldTokens) {\n      if (goodCache[i]) {\n        const t = heldTokens[i]\n        const mint = t.account.data.parsed.info.mint\n        console.log('loading', mint, 'from cache', t)\n        out[mint] = goodCache[i]\n        out[mint].balanceUi = t.balanceUi\n        out[mint].isMutable = false\n      }\n    }\n    */\n    for(const mint in goodCache) {\n      out[mint] = goodCache[mint]\n    }\n\n    //console.log('out', out)\n    return out\n  }\n\n  //\n  // MARK: wallets\n  //\n\n    //\n    // MARK: agent wallet\n    //\n\n    /**\n     * Asynchronously fetches token accounts for a specific owner.\n     *\n     * @returns {Promise<any[]>} A promise that resolves to an array of token accounts.\n     */\n    private async getTokenAccounts() {\n      if (!this.publicKey) return null\n      return this.getTokenAccountsByKeypair(this.publicKey)\n    }\n\n    /**\n     * Gets the wallet keypair for operations requiring private key access\n     * @returns {Promise<Keypair>} The wallet keypair\n     * @throws {Error} If private key is not available\n     */\n    public async getWalletKeypair(): Promise<Keypair> {\n      const keypair = this.keypair;\n      if (!keypair) {\n        throw new Error('Failed to get wallet keypair');\n      }\n      return keypair;\n    }\n\n    /**\n     * Retrieves the public key of the instance.\n     *\n     * @returns {PublicKey} The public key of the instance.\n     */\n    public getPublicKey(): PublicKey | null {\n      return this.publicKey;\n    }\n\n    /**\n     * Update wallet data including fetching wallet portfolio information, prices, and caching the data.\n     * @param {boolean} [force=false] - Whether to force update the wallet data even if the update interval has not passed\n     * @returns {Promise<WalletPortfolio>} The updated wallet portfolio information\n     */\n    public async updateWalletData(force = false): Promise<WalletPortfolio> {\n      //console.log('updateWalletData - start')\n      const now = Date.now();\n\n      if (!this.publicKey) {\n        // can't be warn if we fire every start up\n        // maybe we just get the pubkey here proper\n        // or fall back to SOLANA_PUBLIC_KEY\n        logger.log('solana::updateWalletData - no Public Key yet');\n        return { totalUsd: '0', items: [] };\n      }\n\n      //console.log('updateWalletData - force', force, 'last', this.lastUpdate, 'UPDATE_INTERVAL', this.UPDATE_INTERVAL)\n      // Don't update if less than interval has passed, unless forced\n      if (!force && now - this.lastUpdate < this.UPDATE_INTERVAL) {\n        const cached = await this.getCachedData();\n        if (cached) return cached;\n      }\n      //console.log('updateWalletData - fetch')\n\n      try {\n        // Try Birdeye API first\n        const birdeyeApiKey = this.runtime.getSetting('BIRDEYE_API_KEY');\n        if (birdeyeApiKey) {\n          try {\n            const walletData = await this.birdeyeFetchWithRetry(\n              `${PROVIDER_CONFIG.BIRDEYE_API}/v1/wallet/token_list?wallet=${this.publicKey.toBase58()}`\n            ) as any;\n            // only good for checking envelope\n            //console.log('walletData', walletData)\n\n            if (walletData?.success && walletData?.data) {\n              const data = walletData.data;\n              const totalUsd = new BigNumber(data.totalUsd.toString());\n              const prices = await this.fetchPrices();\n              const solPriceInUSD = new BigNumber(prices.solana.usd);\n\n\n              const missingSymbols = data.items.filter((i: any) => !i.symbol)\n\n              //console.log('data.items', data.items)\n              if (missingSymbols.length) {\n                const symbols: Record<string, string | null> = await this.getTokensSymbols(missingSymbols.map((i: any) => i.address))\n                let missing = false\n                for(const i in data.items) {\n                  const item = data.items[i]\n                  if (symbols[item.address]) {\n                    data.items[i].symbol = symbols[item.address]\n                  } else {\n                    console.log('solana::updateWalletData - no symbol for', item.address, symbols[item.address])\n                    missing = true\n                  }\n                }\n                if (missing) {\n                  console.log('symbols', symbols)\n                }\n              }\n\n              const portfolio: WalletPortfolio = {\n                totalUsd: totalUsd.toString(),\n                totalSol: totalUsd.div(solPriceInUSD).toFixed(6),\n                prices,\n                lastUpdated: now,\n                items: data.items.map((item: Item) => ({\n                  ...item,\n                  valueSol: new BigNumber(item.valueUsd || 0).div(solPriceInUSD).toFixed(6),\n                  name: item.name || 'Unknown',\n                  symbol: item.symbol || 'Unknown',\n                  priceUsd: item.priceUsd || '0',\n                  valueUsd: item.valueUsd || '0',\n                })),\n              };\n\n              //console.log('saving portfolio', portfolio.items.length, 'tokens')\n\n              // maybe should be keyed by public key\n              await this.runtime.setCache<WalletPortfolio>(SOLANA_WALLET_DATA_CACHE_KEY, portfolio);\n              this.lastUpdate = now;\n              return portfolio;\n            }\n          } catch (e) {\n            console.log('solana::updateWalletData - exception err', e);\n          }\n        }\n\n        // Fallback to basic token account info (without Birdeye)\n        logger.log('Using RPC fallback for wallet data (no Birdeye)');\n        const accounts = await this.getTokenAccounts();\n        if (!accounts || accounts.length === 0) {\n          logger.log('No token accounts found');\n          const emptyPortfolio: WalletPortfolio = {\n            totalUsd: '0',\n            totalSol: '0',\n            items: [],\n          };\n          await this.runtime.setCache<WalletPortfolio>(SOLANA_WALLET_DATA_CACHE_KEY, emptyPortfolio);\n          this.lastUpdate = now;\n          return emptyPortfolio;\n        }\n\n        // Get token metadata (symbols) using parseTokenAccounts\n        const tokenMetadata = await this.parseTokenAccounts(accounts);\n\n        const items: Item[] = accounts.map((acc: any) => {\n          const mint = acc.account.data.parsed.info.mint;\n          const metadata = tokenMetadata[mint];\n\n          this.decimalsCache.set(mint, acc.account.data.parsed.info.tokenAmount.decimals);\n\n          return {\n            name: metadata?.symbol || 'Unknown',\n            address: mint,\n            symbol: metadata?.symbol || 'Unknown',\n            decimals: acc.account.data.parsed.info.tokenAmount.decimals,\n            balance: acc.account.data.parsed.info.tokenAmount.amount,\n            uiAmount: acc.account.data.parsed.info.tokenAmount.uiAmount.toString(),\n            priceUsd: '0',\n            valueUsd: '0',\n            valueSol: '0',\n          };\n        });\n\n        logger.log(`Fallback mode: Found ${items.length} tokens in wallet`);\n\n        const portfolio: WalletPortfolio = {\n          totalUsd: '0',\n          totalSol: '0',\n          items,\n        };\n\n        await this.runtime.setCache<WalletPortfolio>(SOLANA_WALLET_DATA_CACHE_KEY, portfolio);\n        this.lastUpdate = now;\n        return portfolio;\n      } catch (error) {\n        logger.error(`Error updating wallet data: ${error}`);\n        throw error;\n      }\n    }\n\n    /**\n     * Retrieves cached wallet portfolio data from the database adapter.\n     * @returns A promise that resolves with the cached WalletPortfolio data if available, otherwise resolves with null.\n     */\n    public async getCachedData(): Promise<WalletPortfolio | null> {\n      const cachedValue = await this.runtime.getCache<WalletPortfolio>(SOLANA_WALLET_DATA_CACHE_KEY);\n      if (cachedValue) {\n        return cachedValue;\n      }\n      return null;\n    }\n\n    /**\n     * Forces an update of the wallet data and returns the updated WalletPortfolio object.\n     * @returns A promise that resolves with the updated WalletPortfolio object.\n     */\n    public async forceUpdate(): Promise<WalletPortfolio> {\n      return await this.updateWalletData(true);\n    }\n\n    //\n    // MARK: any wallet\n    //\n\n    /**\n     * Creates a new Solana wallet by generating a keypair\n     * @returns {Promise<{publicKey: string, privateKey: string}>} Object containing base58-encoded public and private keys\n     */\n    public async createWallet(): Promise<{ publicKey: string; privateKey: string }> {\n      try {\n        // Generate new keypair\n        const newKeypair = Keypair.generate();\n\n        // Convert to base58 strings for secure storage\n        const publicKey = newKeypair.publicKey.toBase58();\n        const privateKey = bs58.encode(newKeypair.secretKey);\n\n        // Clear the keypair from memory\n        newKeypair.secretKey.fill(0);\n\n        return {\n          publicKey,\n          privateKey,\n        };\n      } catch (error) {\n        logger.error(`Error creating wallet: ${error}`);\n        throw new Error('Failed to create new wallet');\n      }\n    }\n\n/*\n  for (const t of haveTokens) {\n      const amountRaw = t.account.data.parsed.info.tokenAmount.amount;\n      const ca = new PublicKey(t.account.data.parsed.info.mint);\n      const decimals = t.account.data.parsed.info.tokenAmount.decimals;\n      const balance = Number(amountRaw) / (10 ** decimals);\n      const symbol = await solanaService.getTokenSymbol(ca);\n*/\n  public async getTokenAccountsByKeypair(walletAddress: PublicKey, options: { notOlderThan?: number; includeZeroBalances?: boolean; } = {}): Promise<KeyedParsedTokenAccount[]> {\n    //console.log('getTokenAccountsByKeypair', walletAddress.toString())\n    //console.log('publicKey', this.publicKey, 'vs', walletAddress)\n    const key = 'solana_' + walletAddress.toString() + '_tokens'\n    //console.trace('whos checking jj')\n    try {\n      const now = Date.now()\n      let check = false\n      // default is undefined, which will run thecheck\n      if ((options as any).notOlderThan !== 0) {\n        check = await this.runtime.getCache<any>(key)\n        if (check) {\n          // how old is this data, do we care\n          const diff = now - (check as any).fetchedAt\n          // 1s - 5min cache?\n          // FIXME: options driven...\n          const acceptableInMs: number = options.notOlderThan ?? 60_000 // default\n          if (diff < acceptableInMs) {\n            console.log('getTokenAccountsByKeypair cache HIT, its', diff.toLocaleString() + 'ms old')\n            return (check as any).data\n          }\n          console.log('getTokenAccountsByKeypair cache MISS, its', diff.toLocaleString() + 'ms old')\n        }\n      }\n      console.log('getTokenAccountsByKeypair - getParsedTokenAccountsByOwner', walletAddress.toString())\n\n      const [accounts, token2022s]: [ParsedTokenAccountsResponse, ParsedTokenAccountsResponse] = await Promise.all([\n        this.connection.getParsedTokenAccountsByOwner(walletAddress, {\n          programId: TOKEN_PROGRAM_ID, // original SPL\n        }),\n        this.connection.getParsedTokenAccountsByOwner(walletAddress, {\n          programId: TOKEN_2022_PROGRAM_ID, // Token 2022\n        }),\n      ])\n      //console.log('token2022s', token2022s)\n      //const haveToken22s = token2022s.value.filter(account => account.account.data.parsed.info.tokenAmount.amount !== '0')\n      //console.log('haveToken22s', haveToken22s)\n      //for(const t of token2022s.value) { console.log('t2022 account.data', t.account.data) }\n      //const haveTokens = accounts.value.filter(account => account.account.data.parsed.info.tokenAmount.amount !== '0')\n      const allTokens: KeyedParsedTokenAccount[] = [...token2022s.value, ...accounts.value]\n\n      // update decimalCache\n      const haveAllTokens: KeyedParsedTokenAccount[] = []\n      for(const t of allTokens) {\n        const { amount, decimals } = t.account.data.parsed.info.tokenAmount;\n        this.decimalsCache.set(t.account.data.parsed.info.mint, decimals);\n        // filter out zero balances (if not includeZeroBalances)\n        if (options.includeZeroBalances || amount !== '0') {\n          haveAllTokens.push(t)\n        }\n      }\n\n      // do we have old data\n      if (check) {\n        // should we compare haveTokens with the old data we have\n        // and generate events?\n      }\n      await this.runtime.setCache<any>(key, {\n        fetchedAt: now,\n        data: haveAllTokens\n      })\n      return haveAllTokens\n    } catch (error) {\n      logger.error(`Error fetching token accounts: ${error}`);\n      return [];\n    }\n  }\n\n  public async getTokenAccountsByKeypairs(walletAddresses: string[], options = {}): Promise<Record<string, KeyedParsedTokenAccount[]>> {\n    const res = await Promise.all(walletAddresses.map(a => this.getTokenAccountsByKeypair(new PublicKey(a), options)))\n    const out: Record<string, KeyedParsedTokenAccount[]> = {}\n    for(const i in walletAddresses) {\n      out[walletAddresses[i]] = res[i]\n    }\n    return out\n  }\n\n  // deprecated\n  /*\n  public async getBalanceByAddr(walletAddressStr: string): Promise<number> {\n    try {\n      const publicKey = new PublicKey(walletAddressStr)\n      console.log('getBalanceByAddr - getBalance')\n      const lamports = await this.connection.getBalance(publicKey);\n      return lamports * SolanaService.LAMPORTS2SOL\n    } catch (error) {\n      this.runtime.logger.error('solSrv:getBalanceByAddr - Error fetching wallet balance:', error);\n      return -1;\n    }\n  }\n  */\n\n  // only get SOL balance\n  public async getBalancesByAddrs(walletAddressArr: string[]): Promise<Record<string, number>> {\n    try {\n      //console.log('walletAddressArr', walletAddressArr)\n      const publicKeyObjs = walletAddressArr.map(k => new PublicKey(k));\n      //console.log('getBalancesByAddrs - getMultipleAccountsInfo')\n      const accounts = await this.batchGetMultipleAccountsInfo(publicKeyObjs, 'getBalancesByAddrs');\n\n      //console.log('getBalancesByAddrs - accounts', accounts)\n      const out: Record<string, number> = {}\n      for(const i in accounts) {\n        const a = accounts[i]\n        // lamports, data, owner, executable, rentEpoch, space\n        //console.log('a', a)\n        const pk = walletAddressArr[i]\n        if (a?.lamports) {\n          out[pk] = a.lamports * SolanaService.LAMPORTS2SOL\n        } else {\n          console.log('no lamports? a', a)\n          // null means there is no balance or the account is closed\n          out[pk] = 0\n        }\n      }\n      return out\n    } catch (error) {\n      const msg = (error as any).message || '';\n      if (msg.includes('429')) {\n        this.runtime.logger.warn('RPC rate limit hit, pausing before retry');\n        // FIXME: retry counter, exponential backoff\n        await new Promise((waitResolve) => setTimeout(waitResolve, 1000));\n        return this.getBalancesByAddrs(walletAddressArr)\n      }\n      //this.runtime.logger.error('solSrv:getBalancesByAddrs - Error fetching wallet balances:', error);\n      this.runtime.logger.error(`solSrv:getBalancesByAddrs - unexpected error: ${error}`);\n      return {};\n    }\n  }\n\n  // we might want USD price and other info...\n  async walletAddressToHumanString(pubKey: string): Promise<string> {\n    let balanceStr = ''\n    // get wallet contents\n    const pubKeyObj = new PublicKey(pubKey)\n\n    const [balances, heldTokens] = await Promise.all([\n      this.getBalancesByAddrs([pubKey]),\n      this.getTokenAccountsByKeypair(pubKeyObj),\n    ]);\n    const solBal = balances[pubKey]\n\n    balanceStr += 'Wallet Address: ' + pubKey + '\\n'\n    balanceStr += '  Token Address (Symbol)\\n'\n    balanceStr += '  So11111111111111111111111111111111111111111 ($sol) balance: ' + (solBal ?? 'unknown') + '\\n'\n    const tokens = await this.parseTokenAccounts(heldTokens) // options\n    for (const ca in tokens) {\n      const t = tokens[ca]\n      balanceStr += '  ' + ca + ' ($' + t.symbol + ') balance: ' + t.balanceUi + '\\n'\n    }\n    balanceStr += '\\n'\n    return balanceStr\n  }\n\n  async walletAddressToLLMString(pubKey: string): Promise<string> {\n    let balanceStr = ''\n    // get wallet contents\n    const pubKeyObj = new PublicKey(pubKey)\n    const [balances, heldTokens] = await Promise.all([\n      this.getBalancesByAddrs([pubKey]),\n      this.getTokenAccountsByKeypair(pubKeyObj),\n    ]);\n    //console.log('balances', balances)\n    const solBal = balances[pubKey]\n    balanceStr += 'Wallet Address: ' + pubKey + '\\n'\n    balanceStr += 'Current wallet contents in csv format:\\n'\n    balanceStr += 'Token Address,Symbol,Balance\\n'\n    balanceStr += 'So11111111111111111111111111111111111111111,sol,' + (solBal ?? 'unknown') + '\\n'\n    const tokens = await this.parseTokenAccounts(heldTokens) // options\n    for (const ca in tokens) {\n      const t = tokens[ca]\n      balanceStr += ca + ',' + t.symbol + ',' + t.balanceUi + '\\n'\n    }\n    balanceStr += '\\n'\n    return balanceStr\n  }\n\n  //\n  // MARK: wallet Associated Token Account (ATA)\n  //\n\n  // single wallet, list of tokens\n  public async getWalletBalances(publicKeyStr: string, mintAddresses: string[]): Promise<Record<string, MintBalance | null>> {\n\n    const owner = new PublicKey(publicKeyStr);\n    const mints = mintAddresses.map(m => new PublicKey(m));\n\n    // 1) Derive ATAs for both programs\n    const ataPairs = mints.map(mint => {\n      const ataLegacy = getAssociatedTokenAddressSync(\n        mint, owner, false, TOKEN_PROGRAM_ID\n      );\n      const ata2022 = getAssociatedTokenAddressSync(\n        mint, owner, false, TOKEN_2022_PROGRAM_ID\n      );\n      return { mint, ataLegacy, ata2022 };\n    });\n\n    // 2) Batch fetch token accounts (both program ATAs)\n    const allAtaAddrs = ataPairs.flatMap(p => [p.ataLegacy, p.ata2022]);\n    const ataInfos = await this.batchGetMultipleAccountsInfo(allAtaAddrs, 'getWalletBalances');\n\n    // 3) Batch fetch mint accounts (for decimals)\n    //const mintInfos = await getMultiple(connection, mints, opts?.commitment);\n    const mintInfos = await this.batchGetMultipleAccountsInfo(mints, 'getWalletBalances');\n\n    // 4) Build quick lookups\n    const mintDecimals = new Map<string, number>();\n    mints.forEach((mintPk, i) => {\n      const acc = mintInfos[i];\n      if (!acc) return;\n      // MintLayout.decode expects acc.data to be a Buffer of correct length\n      const mintData = MintLayout.decode(acc.data);\n      mintDecimals.set(mintPk.toBase58(), mintData.decimals);\n    });\n\n    const byAddress = new Map<string, ReturnType<typeof AccountLayout.decode> | null>();\n    allAtaAddrs.forEach((ata, i) => {\n      const info = ataInfos[i];\n      if (!info) {\n        byAddress.set(ata.toBase58(), null);\n        return;\n      }\n      byAddress.set(ata.toBase58(), AccountLayout.decode(info.data));\n    });\n\n    // 5) Assemble balances; prefer legacy program over 2022 if both exist\n    const out: Record<string, MintBalance | null> = {};\n\n    for (const { mint, ataLegacy, ata2022 } of ataPairs) {\n      const mintStr = mint.toBase58();\n      const decimals = mintDecimals.get(mintStr);\n      // If we donâ€™t know decimals (mint account not found), we canâ€™t compute uiAmount\n      if (decimals === undefined) {\n        out[mintStr] = null;\n        continue;\n      }\n\n      const legacy = byAddress.get(ataLegacy.toBase58());\n      const tok2022 = byAddress.get(ata2022.toBase58());\n\n      // Choose which token account to use:\n      const chosen = legacy ?? tok2022;\n      if (!chosen) {\n        out[mintStr] = null; // ATA doesnâ€™t exist â†’ zero balance\n        continue;\n      }\n\n      // AccountLayout amount is a u64 in little-endian buffer\n      const rawAmount = BigInt(chosen.amount.toString()); // AccountLayout already gives a BN-like\n      const amountStr = rawAmount.toString();\n      const uiAmount = Number(rawAmount) / 10 ** decimals;\n\n      out[mintStr] = { amount: amountStr, decimals, uiAmount };\n    }\n\n    return out;\n  }\n\n  // 5 calls to get a balance for 500 wallets\n  public async getTokenBalanceForWallets(mint: PublicKey, walletAddresses: string[]): Promise<Record<string, number>> {\n    const walletPubkeys = walletAddresses.map(a => new PublicKey(a));\n    const atAs = walletPubkeys.map(w => getAssociatedTokenAddressSync(mint, w));\n    const balances: Record<string, number> = {};\n\n    // fetch mint decimals once\n    const decimals = await this.getDecimal(mint);\n\n    // fetch ATAs in batches\n    const infos = await this.batchGetMultipleAccountsInfo(atAs, 'getTokenBalanceForWallets');\n\n    infos.forEach((info, idx) => {\n      const walletKey = walletPubkeys[idx].toBase58();\n      let uiAmount = 0;\n\n      if (info?.data) {\n        const account = unpackAccount(atAs[idx], info);\n        // address, mint, owner, amount, delegate, delegatedAmount, isInitiailized, isFrozen, isNative\n        // rentExemptReserve, closeAuthority, tlvData\n        const raw = account.amount; // bigint\n        uiAmount = Number(raw) / 10 ** decimals;\n      }\n\n      balances[walletKey] = uiAmount;\n    });\n\n    return balances;\n  }\n\n  /**\n   * Subscribes to account changes for the given public key\n   * @param {string} accountAddress - The account address to subscribe to\n   * @returns {Promise<number>} Subscription ID\n   */\n  // needs to take a handler...\n  public async subscribeToAccount(accountAddress: string, handler: any): Promise<number> {\n    try {\n      if (!this.validateAddress(accountAddress)) {\n        throw new Error('Invalid account address');\n      }\n\n      // Check if already subscribed\n      if (this.subscriptions.has(accountAddress)) {\n        return this.subscriptions.get(accountAddress)!;\n      }\n\n      /*\n      // Create WebSocket connection if needed\n      const ws = (this.connection as any).connection._rpcWebSocket;\n\n      const subscriptionId = await ws.call('accountSubscribe', [\n        accountAddress,\n        {\n          encoding: 'jsonParsed',\n          commitment: 'finalized',\n        },\n      ]);\n\n      // Setup notification handler\n      ws.subscribe(subscriptionId, 'accountNotification', async (notification: any) => {\n        try {\n          const { result } = notification;\n          if (result?.value) {\n            // Force update wallet data to reflect changes\n            await this.updateWalletData(true);\n\n            // Emit an event that can be handled by the agent\n            this.runtime.emit('solana:account:update', {\n              address: accountAddress,\n              data: result.value,\n            });\n          }\n        } catch (error) {\n          logger.error('Error handling account notification:', error);\n        }\n      });\n      */\n      const accountPubkeyObj = new PublicKey(accountAddress);\n      const subscriptionId = this.connection.onAccountChange(accountPubkeyObj, (accountInfo, context) => {\n        handler(accountAddress, accountInfo, context)\n      }, 'finalized')\n\n\n      this.subscriptions.set(accountAddress, subscriptionId);\n      logger.log(`Subscribed to account ${accountAddress} with ID ${subscriptionId}`);\n      return subscriptionId;\n    } catch (error) {\n      logger.error(`Error subscribing to account: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Unsubscribes from account changes\n   * @param {string} accountAddress - The account address to unsubscribe from\n   * @returns {Promise<boolean>} Success status\n   */\n  public async unsubscribeFromAccount(accountAddress: string): Promise<boolean> {\n    try {\n      const subscriptionId = this.subscriptions.get(accountAddress);\n      if (!subscriptionId) {\n        logger.warn(`No subscription found for account ${accountAddress}`);\n        return false;\n      }\n\n      await this.connection.removeAccountChangeListener(subscriptionId);\n      this.subscriptions.delete(accountAddress);\n\n      return true;\n    } catch (error) {\n      logger.error(`Error unsubscribing from account: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Calculates the optimal buy amount and slippage based on market conditions\n   * @param {string} inputMint - Input token mint address\n   * @param {string} outputMint - Output token mint address\n   * @param {number} availableAmount - Available amount to trade\n   * @returns {Promise<{ amount: number; slippage: number }>} Optimal amount and slippage\n   */\n  public async calculateOptimalBuyAmount(\n    inputMint: string,\n    outputMint: string,\n    availableAmount: number\n  ): Promise<{ amount: number; slippage: number }> {\n    try {\n      // Get price impact for the trade\n\n      // quote.priceImpactPct\n      const priceImpact = await this.jupiterService.getPriceImpact({\n        inputMint,\n        outputMint,\n        amount: availableAmount,\n      });\n\n      // Find optimal slippage based on market conditions\n      const slippage = await this.jupiterService.findBestSlippage({\n        inputMint,\n        outputMint,\n        amount: availableAmount,\n      });\n\n      // FIXME: would be good to know how much volume in the last hour...\n\n      //console.log('calculateOptimalBuyAmount - optimal slippage', slippage)\n\n      // If price impact is too high, reduce the amount\n      let optimalAmount = availableAmount;\n      if (priceImpact > 5) {\n        // 5% price impact threshold\n        optimalAmount = availableAmount * 0.5; // Reduce amount by half\n        console.log('calculateOptimalBuyAmount - too much price impact halving', optimalAmount)\n      }\n\n      return { amount: optimalAmount, slippage };\n    } catch (error) {\n      logger.error(`Error calculating optimal buy amount: ${error}`);\n      throw error;\n    }\n  }\n\n  public async calculateOptimalBuyAmount2(quote: any, availableAmount: number): Promise<{ amount: number; slippage: number }> {\n    try {\n      // Get price impact for the trade\n\n      // quote.priceImpactPct\n      const priceImpact = Number(quote.priceImpactPct);\n\n      // If price impact is too high, reduce the amount\n      let optimalAmount = availableAmount;\n      if (priceImpact > 5) {\n        // 5% price impact threshold\n        optimalAmount = availableAmount * 0.5; // Reduce amount by half\n        console.log('calculateOptimalBuyAmount2 - too much price impact halving', optimalAmount)\n      }\n\n      let recommendedSlippage: number;\n      if (priceImpact < 0.5) {\n        recommendedSlippage = 50; // 0.5%\n      } else if (priceImpact < 1) {\n        recommendedSlippage = 100; // 1%\n      } else {\n        recommendedSlippage = 200; // 2%\n      }\n\n      //console.log('calculateOptimalBuyAmount - optimal slippage', slippage)\n      return { amount: optimalAmount, slippage: recommendedSlippage };\n    } catch (error) {\n      logger.error(`calculateOptimalBuyAmount2 - Error calculating optimal buy amount: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Executes buy/sell orders for multiple wallets\n   * @param {Array<{ keypair: any; amount: number }>} wallets - Array of buy information\n   * @param {any} signal - Trading signal information\n   * @returns {Promise<Array<{ success: boolean; outAmount?: number; fees?: any; swapResponse?: any }>>}\n   */\n  public async executeSwap(wallets: Array<{ keypair: any; amount: number }>, signal: any): Promise<Record<string, unknown>> {\n    // do it in serial to avoid hitting rate limits\n    const swapResponses = {}\n    for(const wallet of wallets) {\n      const pubKey = wallet.keypair.publicKey.toString()\n      try {\n\n        // validate amount\n        const intAmount: number = parseInt(wallet.amount.toString())\n        if (isNaN(intAmount) || intAmount <= 0) {\n          console.warn(`solana::executeSwap - Amount in ${wallet.amount} become ${intAmount}`);\n          (swapResponses as any)[pubKey] = {\n            success: false,\n            error: 'bad amount'\n          };\n          continue\n        }\n\n        // FIXME: pass in balance to avoid this check\n\n        // balance check to protect quote rate limit\n        const balances = await this.getBalancesByAddrs([pubKey])\n        const bal = balances[pubKey]\n        //console.log('executeSwap -', wallet.keypair.publicKey, 'bal', bal)\n\n        // 0.000748928\n        // might need to be 0.004\n\n        const baseLamports = this.jupiterService.estimateLamportsNeeded({ inputMint: signal.sourceTokenCA, inAmount: intAmount })\n        const ourLamports = bal * 1e9\n        //console.log('baseLamports', baseLamports.toLocaleString(), 'weHave', ourLamports.toLocaleString())\n        // avoid wasting jupiter quote rate limit\n        if (baseLamports > ourLamports) {\n          console.log(`executeSwap - wallet ${wallet.keypair.publicKey} SOL is too low to swap baseLamports ${baseLamports.toLocaleString()} weHave ${ourLamports.toLocaleString()}`);\n          (swapResponses as any)[pubKey] = {\n            success: false,\n            error: 'not enough SOL'\n          };\n          continue\n        }\n\n        /*\n        if (bal < 0.001) {\n          console.log('executeSwap - wallet', wallet.keypair.publicKey, 'SOL is too low to do anything', bal)\n          swapResponses[pubKey] = {\n            success: false,\n            error: 'not enough SOL'\n          };\n          continue\n        }\n        */\n\n        console.log('signal.sourceTokenCA', signal.sourceTokenCA, 'signal.targetTokenCA', signal.targetTokenCA, 'wallet.amount', wallet.amount.toLocaleString())\n\n        // is this reusable if there's a bunch of wallets with the same amount\n\n        // Get initial quote to determine input mint and other parameters\n        const initialQuote = await this.jupiterService.getQuote({\n          inputMint: signal.sourceTokenCA,\n          outputMint: signal.targetTokenCA,\n          slippageBps: 200,\n          amount: intAmount, // in atomic units of the token\n        });\n        // no decimals\n        console.log('initialQuote', initialQuote)\n        // a percentage over the requested...\n        if (initialQuote.totalLamportsNeeded > baseLamports) {\n          console.log('initialQuote fee over estimate: ', baseLamports.toLocaleString())\n          console.log('routes', initialQuote.routePlan)\n        }\n\n        const availableLamports = bal * 1e9\n        //console.log('availableLamports', availableLamports.toLocaleString())\n        if (initialQuote.totalLamportsNeeded > availableLamports) {\n          // we can't afford as is\n          console.log(`executeSwap - wallet ${wallet.keypair.publicKey} SOL is too low, has ${availableLamports.toLocaleString()} needs ${initialQuote.totalLamportsNeeded.toLocaleString()}`);\n          // lets make sure\n          (swapResponses as any)[pubKey] = {\n            success: false,\n            error: 'not enough SOL'\n          };\n          continue\n        }\n\n        /*\n        const fees = {\n          lamports: initialQuote.otherAmountThreshold,\n          sol: initialQuote.otherAmountThreshold * SolanaService.LAMPORTS2SOL\n        }\n        */\n\n        // outAmount, minOutAmount, priceImpactPct\n        const impliedSlippageBps: number = ((initialQuote.outAmount - initialQuote.otherAmountThreshold) / initialQuote.outAmount) * 10_000;\n        console.log('impliedSlippageBps', impliedSlippageBps, 'jupSlip', initialQuote.slippageBps)\n\n        // Calculate optimal buy amount using the input mint from quote\n        // slippage is drived by price impact\n        const { amount, slippage } = await this.calculateOptimalBuyAmount2(initialQuote, wallet.amount)\n        /*\n        const { amount, slippage } = await this.calculateOptimalBuyAmount(\n          initialQuote.inputMint,\n          initialQuote.outputMint,\n          wallet.amount\n        );\n        */\n        // amount is in atomic units (input token)\n        //\n        console.log('adjusted amount', Number(\"\" + amount).toLocaleString(), 'price impact slippage', slippage)\n        // adjust amount in initialQuote\n        initialQuote.inAmount = \"\" + amount // in input atomic units\n        delete initialQuote.swapUsdValue // invalidate\n\n        /*\n        // Get final quote with optimized amount\n        const quoteResponse = await this.jupiterService.getQuote({\n          inputMint: initialQuote.inputMint,\n          outputMint: initialQuote.outputMint,\n          amount,\n          slippageBps: slippage,\n        });\n        console.log('quoteResponse', quoteResponse)\n        const fees = {\n          lamports: quoteResponse.otherAmountThreshold,\n          sol: quoteResponse.otherAmountThreshold * SolanaService.LAMPORTS2SOL\n        }\n        */\n\n        // why were we doing this?\n        // partially to understand but we have docs now: https://dev.jup.ag/docs/api/swap-api/swap\n        /*\n        const quoteResponse = {\n          inputMint: initialQuote.inputMint,\n          inAmount: initialQuote.inAmount,\n          outputMint: initialQuote.outputMint,\n          outAmount: initialQuote.outAmount,\n          otherAmountThreshold: initialQuote.otherAmountThreshold, // minimum amount after slippage\n          swapMode: initialQuote.swapMode,\n          slippageBps: initialQuote.slippageBps,\n          platformFee: initialQuote.platformFee,\n          priceImpactPct: initialQuote.priceImpactPct,\n          routePlan: initialQuote.routePlan,\n          contextSlot: initialQuote.contextSlot,\n          timeTaken: initialQuote.timeTaken,\n        }\n        */\n\n        // Execute the swap\n        let swapResponse\n        const executeSwap = async (impliedSlippageBps: number) => {\n          console.log('executingSwap', pubKey, signal.sourceTokenCA, signal.targetTokenCA, 'with', impliedSlippageBps + 'bps slippage')\n          // convert quote into instructions\n          swapResponse = await this.jupiterService.executeSwap({\n            quoteResponse: initialQuote,\n            userPublicKey: pubKey,\n            slippageBps: parseInt(impliedSlippageBps.toString()),\n          });\n          //console.log('swapResponse', swapResponse)\n          //console.log('keypair', wallet.keypair)\n\n          const secretKey = bs58.decode(wallet.keypair.privateKey as string);\n          const keypair = Keypair.fromSecretKey(secretKey);\n          //const signature = await this.executeSwap(keypair, swapResponse)\n          //console.log('keypair', keypair)\n\n          // Deserialize, sign, and send\n          const txBuffer = Buffer.from(swapResponse.swapTransaction as string, 'base64');\n          const transaction = VersionedTransaction.deserialize(Uint8Array.from(txBuffer));\n          transaction.sign([keypair]);\n          //transaction.sign(...keypairs); not [keypairs]\n\n          // Getting recent blockhash too slow for Solana/Jupiter\n          /*\n          const { blockhash } = await this.connection.getLatestBlockhash('finalized');\n          console.log('blockhash', blockhash)\n          transaction.message.recentBlockhash = blockhash;\n          */\n\n          /*\n          // just verify the quote is matching up\n          const inner = transaction.meta.innerInstructions || [];\n          let totalReceived = 0;\n          inner.forEach(({ instructions }) => {\n            instructions.forEach((ix: any) => {\n              if (ix.program === 'spl-token' && ix.parsed.type === 'transfer') {\n                const info = ix.parsed.info;\n                if (info.destination === YOUR_TOKEN_ACCOUNT) {\n                  totalReceived += Number(info.amount) / (10 ** DECIMALS);\n                }\n              }\n            });\n          });\n          */\n\n          // Send and confirm\n          let txid = ''\n          try {\n            txid = await this.connection.sendRawTransaction(transaction.serialize());\n          } catch (err) {\n            if (err instanceof SendTransactionError) {\n              // getLogs expects param?\n              const logs = err.logs || await err.getLogs(this.connection);\n\n              let showLogs = true\n\n              if (logs) {\n                if (logs.some(l => l.includes('custom program error: 0x1771'))) {\n                  console.log(`Swap failed: slippage tolerance exceeded. ${impliedSlippageBps}`);\n                  // handle slippage\n                  // ðŸŽ¯ You could retry with higher slippage or log for the user\n\n                  // increment the slippage? and try again?\n                  if (signal.targetTokenCA === 'So11111111111111111111111111111111111111112') {\n                    // sell parameters\n                    if (impliedSlippageBps < 3000) {\n                      // let jupiter swap api rest\n                      await new Promise((resolve) => setTimeout(resolve, 1000));\n                      // double and try again\n                      return executeSwap(impliedSlippageBps * 2)\n                    }\n                    // just fail\n                  } else {\n                    // buy parameters\n                    // we don't need to pay more\n                    // but we can retry\n                    showLogs = false\n                  }\n                }\n\n                if (logs.some(l => l.includes('insufficient lamports'))) {\n                  console.log('Transaction failed: insufficient lamports in the account.');\n                  // optionally prompt user to top up SOL\n                }\n\n                if (logs.some(l => l.includes('Program X failed: custom program error'))) {\n                  console.log('Custom program failure detected.');\n                  // further custom program handling\n                }\n\n                if (showLogs) {\n                  console.log('logs', logs)\n                }\n              }\n\n            }\n            throw err;\n          }\n          console.log(pubKey, signal.sourceTokenCA, signal.targetTokenCA, 'txid', txid) // should probably always log this\n          // swapResponse is of value\n          return txid\n        }\n\n        const txid = await executeSwap(impliedSlippageBps)\n\n        // only adding this back to slow down quoting\n        await this.connection.confirmTransaction(txid, 'finalized');\n        //console.log('finalized')\n\n        // Get transaction details including fees\n        const txDetails = await this.connection.getTransaction(txid, {\n          commitment: 'confirmed',\n          maxSupportedTransactionVersion: 0\n        });\n        //console.log('txDetails', txDetails)\n\n        //const JUPITER_AGGREGATOR_V6 = new PublicKey(\"JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4\");\n        /*\n        const swapIxIndex = txDetails.transaction.message.instructions\n          .findIndex(ix => txDetails.transaction.message.accountKeys[ix.programIdIndex] === \"JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4\");\n        */\n        /*\n        const swapIxIndex = txDetails.transaction.message.instructions.findIndex(ix =>\n          txDetails.transaction.message.accountKeys[ix.programIdIndex].equals(JUPITER_AGGREGATOR_V6)\n        );\n\n        const inner = txDetails.meta.innerInstructions?.find(i => i.index === swapIxIndex);\n        let totalReceivedRaw = 0;\n\n        inner?.instructions.forEach(ix => {\n          if (ix.program === 'spl-token' && ix.parsed.type === 'transfer') {\n            const info = ix.parsed.info;\n            if (info.destination === YOUR_TOKEN_ACCOUNT) {\n              totalReceivedRaw += Number(info.amount);\n            }\n          }\n        });\n        const decimals = DECIMALS; // fetch or store elsewhere\n        const totalReceived = totalReceivedRaw / (10 ** decimals);\n        console.log('Total tokens received:', totalReceived);\n        */\n        let outAmount = initialQuote.outAmount\n        console.log('going to report', initialQuote.outAmount)\n        //console.log('postTokenBalances', txDetails.meta.postTokenBalances)\n\n        if (txDetails?.meta?.preTokenBalances && txDetails?.meta?.postTokenBalances) {\n\n          // if selling\n          let tokenCA = signal.targetTokenCA\n\n          // probably shouldn't flip it because\n          // outBal becomes the sell amount, so the labels are just wrong\n          // we only care about the targetCAamount\n          // if it's not flipped is it not found?\n          /*\n          if (signal.targetTokenCA === 'So11111111111111111111111111111111111111112') {\n            tokenCA = signal.sourceTokenCA\n          }\n          */\n\n          // find only returns the first match\n          const inBal = txDetails.meta.preTokenBalances.find(tb => tb.owner === pubKey && tb.mint === tokenCA)\n          const outBal = txDetails.meta.postTokenBalances.find(tb => tb.owner === pubKey && tb.mint === tokenCA)\n          console.log('inBal', inBal?.uiTokenAmount?.uiAmount, 'outBal', outBal?.uiTokenAmount?.uiAmount)\n\n          // if selling to SOL, there won't be an account change\n\n          if (outBal?.uiTokenAmount.decimals) {\n            this.decimalsCache.set(tokenCA, outBal.uiTokenAmount.decimals)\n          }\n\n          if (signal.targetTokenCA === 'So11111111111111111111111111111111111111112') {\n            // swap to SOL\n\n            // outAmount is how much sol we're getting...\n            console.log('selling, how much sol we getting from meta', pubKey, txDetails.meta.postTokenBalances)\n            // So11111111111111111111111111111111111111112 in in amounts tbh\n            // feel like inBal/outBal is still off/wrong here...\n\n            if (inBal && outBal) {\n              // in will be high than out in this scenario?\n              const lamDiff = (inBal.uiTokenAmount.uiAmount ?? 0) - (outBal.uiTokenAmount.uiAmount ?? 0)\n              const diff = Number(inBal.uiTokenAmount.amount ?? 0) - Number(outBal.uiTokenAmount.amount ?? 0)\n              // we definitely didn't swap for nothing\n              if (diff) {\n                outAmount = diff\n                console.log('changing report to', outAmount, '(', lamDiff, ')')\n              }\n            } else if (outBal) {\n              // just means we weren't already holding the token\n              const amt = Number(outBal.uiTokenAmount.amount)\n              // we definitely didn't swap for nothing\n              if (amt) {\n                outAmount = amt\n                console.log('changing report to', outAmount)\n              }\n            } else {\n              console.log('no balances? wallet', pubKey, 'token', tokenCA)\n              //console.log('preTokenBalances', txDetails.meta.preTokenBalances, '=>', txDetails.meta.postTokenBalances)\n              console.log('wallet', txDetails.meta.preTokenBalances.find(tb => tb.owner === pubKey), '=>', txDetails.meta.postTokenBalances.find(tb => tb.owner === pubKey))\n            }\n\n\n          } else {\n            if (inBal && outBal) {\n              const lamDiff = (outBal.uiTokenAmount.uiAmount ?? 0) - (inBal.uiTokenAmount.uiAmount ?? 0)\n              const diff = Number(outBal.uiTokenAmount.amount ?? 0) - Number(inBal.uiTokenAmount.amount ?? 0)\n              // we definitely didn't swap for nothing\n              if (diff) {\n                outAmount = diff\n                console.log('changing report to', outAmount, '(', lamDiff, ')')\n              }\n            } else if (outBal) {\n              // just means we weren't already holding the token\n              const amt = Number(outBal.uiTokenAmount.amount)\n              // we definitely didn't swap for nothing\n              if (amt) {\n                outAmount = amt\n                console.log('changing report to', outAmount)\n              }\n            } else {\n              console.log('no balances? wallet', pubKey, 'token', tokenCA)\n              //console.log('preTokenBalances', txDetails.meta.preTokenBalances, '=>', txDetails.meta.postTokenBalances)\n              console.log('wallet', txDetails?.meta?.preTokenBalances?.find(tb => tb.owner === pubKey), '=>', txDetails?.meta?.postTokenBalances?.find(tb => tb.owner === pubKey))\n            }\n          }\n        }\n\n        const fee = txDetails?.meta?.fee;\n        console.log(`Transaction fee: ${fee?.toLocaleString()} lamports`);\n        const fees = {\n          /*\n          quote: {\n            lamports: initialQuote.platformFee.amount,\n            bps: initialQuote.platformFee.feeBps,\n          },\n          */\n          lamports: fee,\n          sol: fee ? fee * SolanaService.LAMPORTS2SOL : 0\n        };\n\n        /*\n        // Calculate final amounts including fees\n        const fees = await this.jupiterService.estimateGasFees({\n          inputMint: initialQuote.inputMint,\n          outputMint: initialQuote.outputMint,\n          amount,\n        });\n        */\n\n        (swapResponses as any)[pubKey] = {\n          success: true,\n          outAmount,\n          outDecimal: await this.getDecimal(new PublicKey(signal.targetTokenCA)),\n          signature: txid,\n          fees,\n          swapResponse,\n        };\n      } catch (error) {\n        logger.error(`Error in swap execution: ${error}`);\n        (swapResponses as any)[pubKey] = { success: false };\n      }\n    }\n\n    return swapResponses;\n  }\n\n  /**\n   * Starts the Solana service with the given agent runtime.\n   *\n   * @param {IAgentRuntime} runtime - The agent runtime to use for the Solana service.\n   * @returns {Promise<SolanaService>} The initialized Solana service.\n   */\n  static async start(runtime: IAgentRuntime): Promise<Service> {\n    runtime.logger.log(`SolanaService start for ${runtime.character.name}`);\n\n    const solanaService = new SolanaService(runtime);\n    return solanaService;\n  }\n\n  /**\n   * Stops the Solana service.\n   *\n   * @param {IAgentRuntime} runtime - The agent runtime.\n   * @returns {Promise<void>} - A promise that resolves once the Solana service has stopped.\n   */\n  static async stop(runtime: IAgentRuntime): Promise<unknown> {\n    const client = runtime.getService(SOLANA_SERVICE_NAME) as SolanaService | null;\n    if (!client) {\n      runtime.logger.error('SolanaService not found during static stop');\n      return;\n    }\n    await client.stop();\n  }\n\n  /**\n   * Cleans up subscriptions\n   * @returns {Promise<void>} A Promise that resolves when the update interval is stopped.\n   */\n  async stop(): Promise<void> {\n    this.runtime.logger.info('SolanaService: Stopping instance...');\n    // Unsubscribe from all accounts\n    for (const [address] of this.subscriptions) {\n      await this.unsubscribeFromAccount(address).catch((e) =>\n        this.runtime.logger.error(\n          `Error unsubscribing from ${address} during stop:`,\n          e instanceof Error ? e.message : String(e)\n        )\n      );\n    }\n    this.subscriptions.clear();\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "466661F0A0C4158164756E2164756E21",
  "names": []
}