// src/index.ts
import { parseBooleanFromText } from "@elizaos/core";

// src/actions/swap.ts
import {
  ModelType,
  composePromptFromState,
  logger as logger2,
  parseJSONObjectFromText
} from "@elizaos/core";
import { Connection, PublicKey as PublicKey2, VersionedTransaction } from "@solana/web3.js";
import BigNumber from "bignumber.js";

// src/constants.ts
var SOLANA_SERVICE_NAME = "chain_solana";
var SOLANA_WALLET_DATA_CACHE_KEY = "solana/walletData";

// src/keypairUtils.ts
import { logger } from "@elizaos/core";
import { Keypair, PublicKey } from "@solana/web3.js";
import bs58 from "bs58";
async function getWalletKey(runtime, requirePrivateKey = true) {
  if (requirePrivateKey) {
    const privateKeyString = runtime.getSetting("SOLANA_PRIVATE_KEY") ?? runtime.getSetting("WALLET_PRIVATE_KEY");
    if (!privateKeyString) {
      throw new Error("Private key not found in settings");
    }
    try {
      const secretKey = bs58.decode(privateKeyString);
      return { keypair: Keypair.fromSecretKey(secretKey) };
    } catch (e) {
      logger.log({ e }, "Error decoding base58 private key:");
      try {
        logger.log("Try decoding base64 instead");
        const secretKey = Uint8Array.from(Buffer.from(privateKeyString, "base64"));
        return { keypair: Keypair.fromSecretKey(secretKey) };
      } catch (e2) {
        logger.error({ e: e2 }, "Error decoding private key: ");
        throw new Error("Invalid private key format");
      }
    }
  } else {
    const publicKeyString = runtime.getSetting("SOLANA_PUBLIC_KEY") ?? runtime.getSetting("WALLET_PUBLIC_KEY");
    if (!publicKeyString) {
      throw new Error("Solana Public key not found in settings, but plugin was loaded, please set SOLANA_PUBLIC_KEY");
    }
    return { publicKey: new PublicKey(publicKeyString) };
  }
}

// src/actions/swap.ts
async function getTokenDecimals(connection, mintAddress) {
  const mintPublicKey = new PublicKey2(mintAddress);
  const tokenAccountInfo = await connection.getParsedAccountInfo(mintPublicKey);
  if (tokenAccountInfo.value && typeof tokenAccountInfo.value.data === "object" && "parsed" in tokenAccountInfo.value.data) {
    const parsedInfo = tokenAccountInfo.value.data.parsed?.info;
    if (parsedInfo && typeof parsedInfo.decimals === "number") {
      return parsedInfo.decimals;
    }
  }
  throw new Error("Unable to fetch token decimals");
}
async function swapToken(connection, walletPublicKey, inputTokenCA, outputTokenCA, amount) {
  try {
    const decimals = inputTokenCA === process.env.SOL_ADDRESS ? new BigNumber(9) : new BigNumber(await getTokenDecimals(connection, inputTokenCA));
    logger2.log("Decimals:", decimals.toString());
    const amountBN = new BigNumber(amount);
    const adjustedAmount = amountBN.multipliedBy(new BigNumber(10).pow(decimals));
    logger2.log({
      inputMint: inputTokenCA,
      outputMint: outputTokenCA,
      amount: adjustedAmount
    }, "Fetching quote with params:");
    const quoteResponse = await fetch(`https://quote-api.jup.ag/v6/quote?inputMint=${inputTokenCA}&outputMint=${outputTokenCA}&amount=${adjustedAmount}&dynamicSlippage=true&maxAccounts=64`);
    const quoteData = await quoteResponse.json();
    if (!quoteData || quoteData.error) {
      logger2.error({ quoteData }, "Quote error");
      throw new Error(`Failed to get quote: ${quoteData?.error || "Unknown error"}`);
    }
    const swapRequestBody = {
      quoteResponse: quoteData,
      userPublicKey: walletPublicKey.toBase58(),
      dynamicComputeUnitLimit: true,
      dynamicSlippage: true,
      priorityLevelWithMaxLamports: {
        maxLamports: 4000000,
        priorityLevel: "veryHigh"
      }
    };
    const swapResponse = await fetch("https://quote-api.jup.ag/v6/swap", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(swapRequestBody)
    });
    const swapData = await swapResponse.json();
    if (!swapData || !swapData.swapTransaction) {
      logger2.error({ swapData }, "Swap error");
      throw new Error(`Failed to get swap transaction: ${swapData?.error || "No swap transaction returned"}`);
    }
    return swapData;
  } catch (error) {
    logger2.error({ error }, "Error in swapToken:");
    throw error;
  }
}
async function getTokenFromWallet(runtime, tokenSymbol) {
  try {
    const solanaService = runtime.getService(SOLANA_SERVICE_NAME);
    if (!solanaService) {
      throw new Error("SolanaService not initialized");
    }
    const walletData = await solanaService.getCachedData();
    if (!walletData) {
      return null;
    }
    const token = walletData.items.find((item) => item.symbol.toLowerCase() === tokenSymbol.toLowerCase());
    return token ? token.address : null;
  } catch (error) {
    logger2.error({ error }, "Error checking token in wallet");
    return null;
  }
}
var swapTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.

Example response:
\`\`\`json
{
    "inputTokenSymbol": "SOL",
    "outputTokenSymbol": "USDC",
    "inputTokenCA": "So11111111111111111111111111111111111111112",
    "outputTokenCA": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
    "amount": 1.5
}
\`\`\`

{{recentMessages}}

Given the recent messages and wallet information below:

{{walletInfo}}

Extract the following information about the requested token swap:
- Input token symbol (the token being sold)
- Output token symbol (the token being bought)
- Input token contract address if provided
- Output token contract address if provided
- Amount to swap

Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.`;
var executeSwap = {
  name: "SWAP_SOLANA",
  similes: [
    "SWAP_SOL",
    "SWAP_TOKENS_SOLANA",
    "TOKEN_SWAP_SOLANA",
    "TRADE_TOKENS_SOLANA",
    "EXCHANGE_TOKENS_SOLANA"
  ],
  validate: async (runtime, _message) => {
    const solanaService = runtime.getService(SOLANA_SERVICE_NAME);
    return !!solanaService;
  },
  description: "Perform a token swap from one token to another on Solana. Works with SOL and SPL tokens.",
  handler: async (runtime, message, state, _options, callback) => {
    state = await runtime.composeState(message, ["RECENT_MESSAGES"]);
    try {
      const solanaService = runtime.getService(SOLANA_SERVICE_NAME);
      if (!solanaService) {
        throw new Error("SolanaService not initialized");
      }
      const walletData = await solanaService.getCachedData();
      state.values.walletInfo = walletData;
      const swapPrompt = composePromptFromState({
        state,
        template: swapTemplate
      });
      const result = await runtime.useModel(ModelType.TEXT_LARGE, {
        prompt: swapPrompt
      });
      const response = parseJSONObjectFromText(result);
      if (response.inputTokenSymbol?.toUpperCase() === "SOL") {
        response.inputTokenCA = process.env.SOL_ADDRESS;
      }
      if (response.outputTokenSymbol?.toUpperCase() === "SOL") {
        response.outputTokenCA = process.env.SOL_ADDRESS;
      }
      if (!response.inputTokenCA && response.inputTokenSymbol) {
        response.inputTokenCA = await getTokenFromWallet(runtime, response.inputTokenSymbol) || undefined;
        if (!response.inputTokenCA) {
          callback?.({ text: "Could not find the input token in your wallet" });
          return;
        }
      }
      if (!response.outputTokenCA && response.outputTokenSymbol) {
        response.outputTokenCA = await getTokenFromWallet(runtime, response.outputTokenSymbol) || undefined;
        if (!response.outputTokenCA) {
          callback?.({
            text: "Could not find the output token in your wallet"
          });
          return;
        }
      }
      if (!response.amount) {
        callback?.({ text: "Please specify the amount you want to swap" });
        return;
      }
      const connection = new Connection(runtime.getSetting("SOLANA_RPC_URL") || "https://api.mainnet-beta.solana.com");
      const { publicKey: walletPublicKey } = await getWalletKey(runtime, false);
      const swapResult = await swapToken(connection, walletPublicKey, response.inputTokenCA, response.outputTokenCA, response.amount);
      const transactionBuf = Buffer.from(swapResult.swapTransaction, "base64");
      const transaction = VersionedTransaction.deserialize(transactionBuf);
      const { keypair } = await getWalletKey(runtime, true);
      if (keypair?.publicKey.toBase58() !== walletPublicKey?.toBase58()) {
        throw new Error("Generated public key doesn't match expected public key");
      }
      if (keypair) {
        transaction.sign([keypair]);
      } else {
        throw new Error("Keypair not found");
      }
      const latestBlockhash = await connection.getLatestBlockhash();
      const txid = await connection.sendTransaction(transaction, {
        skipPreflight: false,
        maxRetries: 3,
        preflightCommitment: "confirmed"
      });
      const confirmation = await connection.confirmTransaction({
        signature: txid,
        blockhash: latestBlockhash.blockhash,
        lastValidBlockHeight: latestBlockhash.lastValidBlockHeight
      }, "confirmed");
      if (confirmation.value.err) {
        throw new Error(`Transaction failed: ${confirmation.value.err}`);
      }
      callback?.({
        text: `Swap completed successfully! Transaction ID: ${txid}`,
        content: { success: true, txid }
      });
      return;
    } catch (error) {
      if (error instanceof Error) {
        logger2.error({ error }, "Error during token swap");
        callback?.({
          text: `Swap failed: ${error.message}`,
          content: { error: error.message }
        });
        return;
      }
      throw error;
    }
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "Swap 0.1 SOL for USDC"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "I'll help you swap 0.1 SOL for USDC",
          actions: ["SWAP_SOLANA"]
        }
      }
    ]
  ]
};

// src/actions/transfer.ts
import {
  ModelType as ModelType2,
  composePromptFromState as composePromptFromState2,
  logger as logger3,
  parseJSONObjectFromText as parseJSONObjectFromText2
} from "@elizaos/core";
import {
  createAssociatedTokenAccountInstruction,
  createTransferInstruction,
  getAssociatedTokenAddressSync
} from "@solana/spl-token";
import {
  Connection as Connection2,
  PublicKey as PublicKey3,
  SystemProgram,
  TransactionMessage,
  VersionedTransaction as VersionedTransaction2
} from "@solana/web3.js";
function isTransferContent(content) {
  if (!content || typeof content !== "object")
    return false;
  const c = content;
  if (typeof c.recipient !== "string")
    return false;
  if (!(typeof c.amount === "string" || typeof c.amount === "number"))
    return false;
  if (c.tokenAddress !== null && typeof c.tokenAddress !== "string")
    return false;
  return true;
}
var transferTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.

Example responses:
For SPL tokens:
\`\`\`json
{
    "tokenAddress": "BieefG47jAHCGZBxi2q87RDuHyGZyYC3vAzxpyu8pump",
    "recipient": "9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa",
    "amount": "1000"
}
\`\`\`

For SOL:
\`\`\`json
{
    "tokenAddress": null,
    "recipient": "9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa",
    "amount": 1.5
}
\`\`\`

{{recentMessages}}

Extract the following information about the requested transfer:
- Token contract address (use null for SOL transfers)
- Recipient wallet address
- Amount to transfer
`;
var transfer_default = {
  name: "TRANSFER_SOLANA",
  similes: [
    "TRANSFER_SOL",
    "SEND_TOKEN_SOLANA",
    "TRANSFER_TOKEN_SOLANA",
    "SEND_TOKENS_SOLANA",
    "TRANSFER_TOKENS_SOLANA",
    "SEND_SOL",
    "SEND_TOKEN_SOL",
    "PAY_SOL",
    "PAY_TOKEN_SOL",
    "PAY_TOKENS_SOL",
    "PAY_TOKENS_SOLANA",
    "PAY_SOLANA"
  ],
  validate: async (runtime, message) => {
    runtime.logger.log("Validating transfer from entity:", message.entityId);
    return true;
  },
  description: "Transfer SOL or SPL tokens to another address on Solana.",
  handler: async (runtime, _message, state, _options, callback) => {
    logger3.log("Starting TRANSFER handler...");
    const transferPrompt = composePromptFromState2({
      state,
      template: transferTemplate
    });
    const result = await runtime.useModel(ModelType2.TEXT_LARGE, {
      prompt: transferPrompt
    });
    const content = parseJSONObjectFromText2(result);
    if (!content) {
      if (callback) {
        callback({
          text: "Need a valid recipient address and amount to transfer.",
          content: { error: "Invalid transfer content" }
        });
      }
      return;
    }
    if (!isTransferContent(content)) {
      if (callback) {
        callback({
          text: "Need a valid recipient address and amount to transfer.",
          content: { error: "Invalid transfer content" }
        });
      }
      return;
    }
    try {
      const { keypair: senderKeypair } = await getWalletKey(runtime, true);
      if (!senderKeypair) {
        if (callback) {
          callback({
            text: "Need a valid agent address.",
            content: { error: "Invalid transfer content" }
          });
        }
        return;
      }
      const connection = new Connection2(runtime.getSetting("SOLANA_RPC_URL") || "https://api.mainnet-beta.solana.com");
      const recipientPubkey = new PublicKey3(content.recipient);
      let signature;
      if (content.tokenAddress === null) {
        const lamports = Number(content.amount) * 1e9;
        const instruction = SystemProgram.transfer({
          fromPubkey: senderKeypair.publicKey,
          toPubkey: recipientPubkey,
          lamports
        });
        const messageV0 = new TransactionMessage({
          payerKey: senderKeypair.publicKey,
          recentBlockhash: (await connection.getLatestBlockhash()).blockhash,
          instructions: [instruction]
        }).compileToV0Message();
        const transaction = new VersionedTransaction2(messageV0);
        transaction.sign([senderKeypair]);
        signature = await connection.sendTransaction(transaction);
        if (callback) {
          callback({
            text: `Sent ${content.amount} SOL. Transaction hash: ${signature}`,
            content: {
              success: true,
              signature,
              amount: content.amount,
              recipient: content.recipient
            }
          });
        }
      } else {
        const mintPubkey = new PublicKey3(content.tokenAddress);
        const mintInfo = await connection.getParsedAccountInfo(mintPubkey);
        const decimals = mintInfo.value?.data?.parsed?.info?.decimals ?? 9;
        const adjustedAmount = BigInt(Number(content.amount) * 10 ** decimals);
        const senderATA = getAssociatedTokenAddressSync(mintPubkey, senderKeypair.publicKey);
        const recipientATA = getAssociatedTokenAddressSync(mintPubkey, recipientPubkey);
        const instructions = [];
        const recipientATAInfo = await connection.getAccountInfo(recipientATA);
        if (!recipientATAInfo) {
          instructions.push(createAssociatedTokenAccountInstruction(senderKeypair.publicKey, recipientATA, recipientPubkey, mintPubkey));
        }
        instructions.push(createTransferInstruction(senderATA, recipientATA, senderKeypair.publicKey, adjustedAmount));
        const messageV0 = new TransactionMessage({
          payerKey: senderKeypair.publicKey,
          recentBlockhash: (await connection.getLatestBlockhash()).blockhash,
          instructions
        }).compileToV0Message();
        const transaction = new VersionedTransaction2(messageV0);
        transaction.sign([senderKeypair]);
        signature = await connection.sendTransaction(transaction);
        if (callback) {
          callback({
            text: `Sent ${content.amount} tokens to ${content.recipient}
Transaction hash: ${signature}`,
            content: {
              success: true,
              signature,
              amount: content.amount,
              recipient: content.recipient
            }
          });
        }
      }
      return;
    } catch (error) {
      logger3.error({ error }, "Error during transfer");
      if (callback) {
        const message = error instanceof Error ? error.message : typeof error === "string" ? error : JSON.stringify(error);
        callback({
          text: `Transfer failed: ${message}`,
          content: { error: message }
        });
      }
      return;
    }
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "Send 1.5 SOL to 9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Sending SOL now...",
          actions: ["TRANSFER_SOLANA"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Send 69 $DEGENAI BieefG47jAHCGZBxi2q87RDuHyGZyYC3vAzxpyu8pump to 9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Sending the tokens now...",
          actions: ["TRANSFER_SOLANA"]
        }
      }
    ]
  ]
};

// src/providers/wallet.ts
import { logger as logger4 } from "@elizaos/core";
import BigNumber2 from "bignumber.js";
var walletProvider = {
  name: "solana-wallet",
  description: "your solana wallet information",
  dynamic: true,
  get: async (runtime, _message, state) => {
    try {
      const portfolioCache = await runtime.getCache(SOLANA_WALLET_DATA_CACHE_KEY);
      if (!portfolioCache) {
        logger4.info("solana::wallet provider - portfolioCache is not ready");
        return { data: null, values: {}, text: "" };
      }
      const solanaService = runtime.getService("solana");
      let pubkeyStr = "";
      const { publicKey } = await getWalletKey(runtime, false);
      if (solanaService) {
        pubkeyStr = " (" + publicKey?.toBase58() + ")";
      }
      const portfolio = portfolioCache;
      const agentName = state?.agentName || runtime.character.name || "The agent";
      const values = {
        total_usd: new BigNumber2(portfolio.totalUsd).toFixed(2),
        total_sol: portfolio.totalSol?.toString() || "0"
      };
      portfolio.items.forEach((item, index) => {
        if (new BigNumber2(item.uiAmount).isGreaterThan(0)) {
          values[`token_${index}_name`] = item.name;
          values[`token_${index}_symbol`] = item.symbol;
          values[`token_${index}_amount`] = new BigNumber2(item.uiAmount).toFixed(6);
          values[`token_${index}_usd`] = new BigNumber2(item.valueUsd).toFixed(2);
          values[`token_${index}_sol`] = item.valueSol?.toString() || "0";
        }
      });
      if (portfolio.prices) {
        values.sol_price = new BigNumber2(portfolio.prices.solana.usd).toFixed(2);
        values.btc_price = new BigNumber2(portfolio.prices.bitcoin.usd).toFixed(2);
        values.eth_price = new BigNumber2(portfolio.prices.ethereum.usd).toFixed(2);
      }
      let text = `

${agentName}'s Main Solana Wallet${pubkeyStr}
`;
      text += `Total Value: $${values.total_usd} (${values.total_sol} SOL)

`;
      text += `Token Balances:
`;
      const nonZeroItems = portfolio.items.filter((item) => new BigNumber2(item.uiAmount).isGreaterThan(0));
      if (nonZeroItems.length === 0) {
        text += `No tokens found with non-zero balance
`;
      } else {
        for (const item of nonZeroItems) {
          const valueUsd = new BigNumber2(item.valueUsd).toFixed(2);
          text += `${item.name} (${item.symbol}): ${new BigNumber2(item.uiAmount).toFixed(6)} ($${valueUsd} | ${item.valueSol} SOL)
`;
        }
      }
      if (portfolio.prices) {
        text += `
Market Prices:
`;
        text += `SOL: $${values.sol_price}
`;
        text += `BTC: $${values.btc_price}
`;
        text += `ETH: $${values.eth_price}
`;
      }
      return {
        data: portfolio,
        values,
        text
      };
    } catch (error) {
      logger4.error(`Error in Solana wallet provider: ${error instanceof Error ? error.message : String(error)}`);
      return { data: null, values: {}, text: "" };
    }
  }
};

// src/service.ts
import { Service, ServiceType, logger as logger5 } from "@elizaos/core";
import { IWalletService } from "@elizaos/service-interfaces";
import {
  Connection as Connection3,
  Keypair as Keypair2,
  PublicKey as PublicKey4,
  VersionedTransaction as VersionedTransaction3,
  SendTransactionError,
  LAMPORTS_PER_SOL,
  SystemProgram as SystemProgram2,
  TransactionMessage as TransactionMessage2
} from "@solana/web3.js";
import {
  MintLayout,
  getMint,
  TOKEN_PROGRAM_ID,
  TOKEN_2022_PROGRAM_ID,
  unpackAccount,
  getAssociatedTokenAddressSync as getAssociatedTokenAddressSync2,
  ExtensionType,
  getExtensionData,
  unpackMint,
  AccountLayout
} from "@solana/spl-token";
import { unpack as unpackToken2022Metadata } from "@solana/spl-token-metadata";
import BigNumber3 from "bignumber.js";
import bs582 from "bs58";
import nacl from "tweetnacl";
var PROVIDER_CONFIG = {
  BIRDEYE_API: "https://public-api.birdeye.so",
  MAX_RETRIES: 3,
  RETRY_DELAY: 2000,
  DEFAULT_RPC: "https://api.mainnet-beta.solana.com",
  TOKEN_ADDRESSES: {
    SOL: "So11111111111111111111111111111111111111112",
    BTC: "3NZ9JMVBmGAqocybic2c7LQCJScmgsAZ6vQqTDzcqmJh",
    ETH: "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"
  }
};
var METADATA_PROGRAM_ID = new PublicKey4("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
class SolanaWalletService extends IWalletService {
  _solanaService = null;
  constructor(runtime) {
    if (!runtime)
      throw new Error("runtime is required for solana service");
    super(runtime);
  }
  get solanaService() {
    if (!this._solanaService) {
      this._solanaService = this.runtime.getService("chain_solana");
      if (!this._solanaService) {
        throw new Error("Solana Service is required for Solana Wallet Service");
      }
    }
    return this._solanaService;
  }
  async getPortfolio(owner) {
    if (owner && owner !== this.solanaService.getPublicKey()?.toBase58()) {
      throw new Error(`This SolanaService instance can only get the portfolio for its configured wallet: ${this.solanaService.getPublicKey()?.toBase58()}`);
    }
    const wp = await this.solanaService.updateWalletData(true);
    const out = {
      totalValueUsd: parseFloat(wp.totalUsd),
      assets: wp.items.map((i) => ({
        address: i.address,
        symbol: i.symbol,
        balance: Number(i.uiAmount ?? 0).toString(),
        decimals: i.decimals,
        valueUsd: Number(i.valueUsd ?? 0)
      }))
    };
    return out;
  }
  async getBalance(assetAddress, owner) {
    const ownerAddress = owner || this.solanaService.getPublicKey()?.toBase58();
    if (!ownerAddress) {
      return -1;
    }
    if (assetAddress.toUpperCase() === "SOL" || assetAddress === PROVIDER_CONFIG.TOKEN_ADDRESSES.SOL) {
      const balances = await this.solanaService.getBalancesByAddrs([ownerAddress]);
      const balance = balances[ownerAddress] ?? 0;
      return balance;
    }
    const tokensBalances = await this.solanaService.getTokenAccountsByKeypairs([ownerAddress]);
    const heldTokens = tokensBalances[ownerAddress] || [];
    for (const t of heldTokens) {
      if (t.account.data.parsed.info.mint === assetAddress) {
        return t.account.data.parsed.info.tokenAmount.uiAmount;
      }
    }
    this.runtime.logger.log("could not find", assetAddress, "in", heldTokens);
    return -1;
  }
  async transferSol(from, to, lamports) {
    try {
      const payerKey = this.solanaService.getPublicKey();
      if (!payerKey || payerKey === null) {
        throw new Error("SolanaService is not initialized with a fee payer key, cannot send transaction.");
      }
      const connection = this.solanaService.getConnection();
      const transaction = new TransactionMessage2({
        payerKey,
        recentBlockhash: (await connection.getLatestBlockhash()).blockhash,
        instructions: [
          SystemProgram2.transfer({
            fromPubkey: from.publicKey,
            toPubkey: to,
            lamports
          })
        ]
      }).compileToV0Message();
      const versionedTransaction = new VersionedTransaction3(transaction);
      const serviceKeypair = await this.solanaService.getWalletKeypair();
      versionedTransaction.sign([from, serviceKeypair]);
      const signature = await connection.sendTransaction(versionedTransaction, {
        skipPreflight: false
      });
      const confirmation = await connection.confirmTransaction(signature, "confirmed");
      if (confirmation.value.err) {
        throw new Error(`Transaction confirmation failed: ${JSON.stringify(confirmation.value.err)}`);
      }
      return signature;
    } catch (error) {
      this.runtime.logger.error({ error }, "SolanaService: transferSol failed");
      throw error;
    }
  }
  static async start(runtime) {
    runtime.logger.log(`SolanaWalletService start for ${runtime.character.name}`);
    const solanaWalletService = new SolanaWalletService(runtime);
    return solanaWalletService;
  }
  static async stop(runtime) {
    const client = runtime.getService(ServiceType.WALLET);
    if (!client) {
      logger5.error("SolanaWalletService not found during static stop");
      return;
    }
    await client.stop();
  }
  async stop() {}
}

class SolanaService extends Service {
  static serviceType = SOLANA_SERVICE_NAME;
  capabilityDescription = "The agent is able to interact with the Solana blockchain, and has access to the wallet data";
  lastUpdate = 0;
  UPDATE_INTERVAL = 2 * 60000;
  connection;
  publicKey = null;
  keypair = null;
  exchangeRegistry = {};
  subscriptions = new Map;
  jupiterService;
  static LAMPORTS2SOL = 1 / LAMPORTS_PER_SOL;
  static SOL2LAMPORTS = LAMPORTS_PER_SOL;
  decimalsCache = new Map([
    ["EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", 6],
    ["Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB", 6],
    ["So11111111111111111111111111111111111111112", 9]
  ]);
  constructor(runtime) {
    if (!runtime)
      throw new Error("runtime is required for solana service");
    super(runtime);
    this.exchangeRegistry = {};
    this.connection = new Connection3(runtime.getSetting("SOLANA_RPC_URL") || PROVIDER_CONFIG.DEFAULT_RPC);
    runtime.getServiceLoadPromise("JUPITER_SERVICE").then(async (s) => {
      this.jupiterService = runtime.getService("JUPITER_SERVICE");
    });
    getWalletKey(runtime, true).then(({ keypair }) => {
      if (keypair) {
        this.keypair = keypair;
      }
    }).catch((e) => {
      runtime.logger.log("no useable solana private key");
    });
    getWalletKey(runtime, false).then(({ publicKey }) => {
      if (!publicKey) {
        throw new Error("Failed to initialize public key");
      }
      this.publicKey = publicKey;
      this.updateWalletData();
      this.subscribeToAccount(this.publicKey.toBase58(), async (accountAddress, accountInfo, context) => {
        runtime.logger.log("Updating wallet data");
        await this.updateWalletData();
      }).catch((error) => {
        logger5.error("Error subscribing to agent wallet updates:", error);
      });
    }).catch((error) => {
      logger5.error(`Error initializing public key: ${error}`);
    });
    this.subscriptions = new Map;
  }
  getConnection() {
    return this.connection;
  }
  async registerExchange(provider) {
    const id = Object.values(this.exchangeRegistry).length + 1;
    this.runtime.logger.success(`Registered ${provider.name} as Solana provider #${id}`);
    this.exchangeRegistry[id] = provider;
    return id;
  }
  async birdeyeFetchWithRetry(url, options = {}) {
    let lastError;
    for (let i = 0;i < PROVIDER_CONFIG.MAX_RETRIES; i++) {
      try {
        const response = await globalThis.fetch(url, {
          ...options,
          headers: {
            Accept: "application/json",
            "x-chain": "solana",
            "X-API-KEY": this.runtime.getSetting("BIRDEYE_API_KEY"),
            ...options.headers
          }
        });
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
        }
        return await response.json();
      } catch (error) {
        logger5.error(`Attempt ${i + 1} failed: ${error}`);
        logger5.error({ error }, `Attempt ${i + 1} failed`);
        lastError = error;
        if (i < PROVIDER_CONFIG.MAX_RETRIES - 1) {
          await new Promise((resolve) => setTimeout(resolve, PROVIDER_CONFIG.RETRY_DELAY * 2 ** i));
        }
      }
    }
    if (lastError)
      throw lastError;
  }
  async batchGetMultipleAccountsInfo(pubkeys, label) {
    const results = [];
    for (let i = 0;i < pubkeys.length; i += 100) {
      const slice = pubkeys.slice(i, i + 100);
      console.log("batchGetMultipleAccountsInfo(" + label + ") - getMultipleAccountsInfo", slice.length + "/" + pubkeys.length);
      const infos = await this.connection.getMultipleAccountsInfo(slice);
      results.push(...infos);
    }
    return results;
  }
  verifySignature({
    publicKeyBase58,
    message,
    signatureBase64
  }) {
    const signature = Uint8Array.from(Buffer.from(signatureBase64, "base64"));
    const messageUint8 = Uint8Array.from(Buffer.from(message, "utf-8"));
    const publicKeyBytes = bs582.decode(publicKeyBase58);
    return nacl.sign.detached.verify(messageUint8, signature, publicKeyBytes);
  }
  verifySolanaSignature({
    message,
    signatureBase64,
    publicKeyBase58
  }) {
    this.runtime.logger.warn("verifySolanaSignature is deprecated, use verifySignature");
    return this.verifySignature({ message, signatureBase64, publicKeyBase58 });
  }
  isValidAddress(address, onCurveOnly = false) {
    try {
      const pubkey = new PublicKey4(address);
      if (onCurveOnly) {
        return PublicKey4.isOnCurve(pubkey.toBuffer());
      }
      return true;
    } catch {
      return false;
    }
  }
  isValidSolanaAddress(address, onCurveOnly = false) {
    this.runtime.logger.warn("isValidSolanaAddress is deprecated, use isValidAddress");
    return this.isValidAddress(address, onCurveOnly);
  }
  validateAddress(address) {
    if (!address)
      return false;
    try {
      if (!/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address)) {
        this.runtime.logger.warn(`Invalid Solana address format: ${address}`);
        return false;
      }
      const pubKey = new PublicKey4(address);
      const isValid = Boolean(pubKey.toBase58());
      return isValid;
    } catch (error) {
      this.runtime.logger.error({ error }, `Address validation error: ${address}`);
      return false;
    }
  }
  static TOKEN_ACCOUNT_DATA_LENGTH = 165;
  static TOKEN_MINT_DATA_LENGTH = 82;
  async getAddressType(address) {
    const types = await this.getAddressesTypes([address]);
    return types[address];
  }
  async getAddressesTypes(addresses) {
    const pubkeys = addresses.map((a) => new PublicKey4(a));
    const infos = await this.batchGetMultipleAccountsInfo(pubkeys, "getAddressesTypes");
    const resultList = addresses.map((addr, i) => {
      const info = infos[i];
      if (!info)
        return "Account does not exist";
      const dataLength = info.data.length;
      if (dataLength === 0)
        return "Wallet";
      if (dataLength === SolanaService.TOKEN_ACCOUNT_DATA_LENGTH)
        return "Token Account";
      if (dataLength === SolanaService.TOKEN_MINT_DATA_LENGTH)
        return "Token";
      return `Unknown (Data length: ${dataLength})`;
    });
    const out = {};
    for (const i in addresses) {
      const addr = addresses[i];
      out[addr] = resultList[i];
    }
    return out;
  }
  detectPubkeysFromString(input, checkCurve = false) {
    const results = new Set;
    const regex = /\b[1-9A-HJ-NP-Za-km-z]{32,44}\b/g;
    let match;
    while ((match = regex.exec(input)) !== null) {
      const s = match[0];
      try {
        const buf = bs582.decode(s);
        if (buf.length === 32) {
          if (checkCurve) {
            if (PublicKey4.isOnCurve(buf)) {
              results.add(s);
            }
          } else {
            results.add(s);
          }
        }
      } catch {}
    }
    return Array.from(results);
  }
  detectPrivateKeysFromString(input) {
    const results = [];
    const base58Regex = /\b[1-9A-HJ-NP-Za-km-z]{86,90}\b/g;
    const hexRegex = /\b[a-fA-F0-9]{128}\b/g;
    let m;
    while ((m = base58Regex.exec(input)) !== null) {
      const s = m[0];
      try {
        const buf = bs582.decode(s);
        if (buf.length === 64) {
          results.push({ format: "base58", match: s, bytes: Uint8Array.from(buf) });
        }
      } catch {}
    }
    while ((m = hexRegex.exec(input)) !== null) {
      const s = m[0];
      const buf = Buffer.from(s, "hex");
      if (buf.length === 64) {
        results.push({ format: "hex", match: s, bytes: Uint8Array.from(buf) });
      }
    }
    return results;
  }
  async getCirculatingSupply(mint) {
    const accounts = await this.connection.getParsedProgramAccounts(TOKEN_PROGRAM_ID, {
      filters: [
        { dataSize: 165 },
        { memcmp: { offset: 0, bytes: mint } }
      ]
    });
    const KNOWN_EXCLUDED_ACCOUNTS = [
      "MINT_AUTHORITY_WALLET",
      "TREASURY_WALLET",
      "BURN_ADDRESS"
    ];
    let circulating = 0;
    for (const acc of accounts) {
      const info = acc.account.data.parsed.info;
      const owner = info.owner;
      if (owner === "11111111111111111111111111111111")
        continue;
      if (KNOWN_EXCLUDED_ACCOUNTS.includes(owner))
        continue;
      const amount = Number(info.tokenAmount.amount);
      const decimals = info.tokenAmount.decimals;
      circulating += amount / 10 ** decimals;
    }
    return circulating;
  }
  async getCirculatingSupplies(mints) {
    return Promise.all(mints.map((m) => this.getCirculatingSupply(m)));
  }
  async fetchPrices() {
    const cacheKey = "prices_sol_btc_eth";
    const cachedValue = await this.runtime.getCache(cacheKey);
    if (cachedValue) {
      logger5.log("Cache hit for fetchPrices");
      return cachedValue;
    }
    logger5.log("Cache miss for fetchPrices");
    const { SOL, BTC, ETH } = PROVIDER_CONFIG.TOKEN_ADDRESSES;
    const tokens = [SOL, BTC, ETH];
    const prices = {
      solana: { usd: "0" },
      bitcoin: { usd: "0" },
      ethereum: { usd: "0" }
    };
    for (const token of tokens) {
      const response = await this.birdeyeFetchWithRetry(`${PROVIDER_CONFIG.BIRDEYE_API}/defi/price?address=${token}`);
      if (response?.data?.value) {
        const price = response.data.value.toString();
        prices[token === SOL ? "solana" : token === BTC ? "bitcoin" : "ethereum"].usd = price;
      }
    }
    await this.runtime.setCache(cacheKey, prices);
    return prices;
  }
  async getDecimal(mintPublicKey) {
    try {
      const key = mintPublicKey.toString();
      if (this.decimalsCache.has(key)) {
        console.log("getDecimal - HIT", key);
        return this.decimalsCache.get(key);
      }
      console.log("getDecimal - MISS getParsedAccountInfo", key);
      const acc = await this.connection.getParsedAccountInfo(mintPublicKey);
      const owner = acc.value?.owner.toString();
      if (owner === TOKEN_PROGRAM_ID.toString()) {
        console.log("getDecimal - MISS getMint", key);
        const mintInfo = await getMint(this.connection, mintPublicKey);
        this.decimalsCache.set(key, mintInfo.decimals);
        return mintInfo.decimals;
      } else if (owner === TOKEN_2022_PROGRAM_ID.toString()) {
        const mintInfo = await getMint(this.connection, mintPublicKey, undefined, TOKEN_2022_PROGRAM_ID);
        this.decimalsCache.set(key, mintInfo.decimals);
        return mintInfo.decimals;
      }
      console.error(`Unknown owner type ${owner}`, acc);
      return -1;
    } catch (error) {
      console.error(`Failed to fetch token decimals: ${error}`);
      return -1;
    }
  }
  async getDecimals(mints) {
    const mintPublicKeys = mints.map((a) => new PublicKey4(a));
    return Promise.all(mintPublicKeys.map((a) => this.getDecimal(a)));
  }
  async getMetadataAddress(mint) {
    const [metadataPDA] = await PublicKey4.findProgramAddress([
      Buffer.from("metadata"),
      METADATA_PROGRAM_ID.toBuffer(),
      mint.toBuffer()
    ], METADATA_PROGRAM_ID);
    return metadataPDA;
  }
  async getTokenSymbol(mint) {
    const metadataAddress = await this.getMetadataAddress(mint);
    console.log("getTokenSymbol - getAccountInfo");
    const accountInfo = await this.connection.getAccountInfo(metadataAddress);
    if (!accountInfo || !accountInfo.data)
      return null;
    const data = accountInfo.data;
    let offset = 1 + 32 + 32;
    const nameLen = data.readUInt32LE(offset);
    offset += 4 + nameLen;
    const symbolLen = data.readUInt32LE(offset);
    offset += 4;
    const symbol = data.slice(offset, offset + symbolLen).toString("utf8").replace(/\0/g, "");
    return symbol;
  }
  parseToken2022SymbolFromMintOrPtr = (mintData) => {
    const inline = getExtensionData(ExtensionType.TokenMetadata, mintData);
    if (inline) {
      try {
        const md = unpackToken2022Metadata(inline);
        const symbol = md?.symbol?.replace(/\0/g, "").trim() || null;
        return { symbol };
      } catch {}
    }
    const ptrExt = getExtensionData(ExtensionType.MetadataPointer, mintData);
    if (ptrExt?.metadataAddress) {
      return { symbol: null, ptr: new PublicKey4(ptrExt.metadataAddress) };
    }
    return { symbol: null };
  };
  async getTokensSymbols(mints) {
    console.log("getTokensSymbols");
    const mintKeys = mints.map((k) => new PublicKey4(k));
    const metadataAddresses = await Promise.all(mintKeys.map((mk) => this.getMetadataAddress(mk)));
    const accountInfos = await this.batchGetMultipleAccountsInfo(metadataAddresses, "getTokensSymbols/Metaplex");
    const out = {};
    const needs2022 = [];
    mintKeys.forEach((token, i) => {
      const accountInfo = accountInfos[i];
      if (!accountInfo || !accountInfo.data) {
        out[token.toBase58()] = null;
        console.log("getTokensSymbols - adding", token.toBase58(), "to token2022 list");
        needs2022.push(token);
        return;
      }
      try {
        const data = accountInfo.data;
        let offset = 1 + 32 + 32;
        const nameLen = data.readUInt32LE(offset);
        offset += 4 + nameLen;
        const symbolLen = data.readUInt32LE(offset);
        offset += 4;
        const symbol = data.slice(offset, offset + symbolLen).toString("utf8").replace(/\0/g, "").trim() || null;
        out[token.toBase58()] = symbol;
        if (!symbol)
          needs2022.push(token);
      } catch (e) {
        console.log("Metaplex parse failed; will try Token-2022:", e);
        out[token.toBase58()] = null;
        needs2022.push(token);
      }
    });
    if (needs2022.length) {
      const mintInfos = await this.batchGetMultipleAccountsInfo(needs2022, "getTokensSymbols/Token2022");
      const ptrsToFetch = [];
      const ptrOwnerByKey = new Map;
      needs2022.forEach((mint, idx) => {
        const info = mintInfos[idx];
        if (!info || !info.data) {
          console.log("getTokensSymbols - token2022 failed", mint.toBase58());
          return;
        }
        if (!info.owner.equals(TOKEN_2022_PROGRAM_ID)) {
          console.log("getTokensSymbols - not a token2022", mint.toBase58());
          return;
        }
        const { symbol, ptr } = this.parseToken2022SymbolFromMintOrPtr(info.data);
        if (symbol) {
          out[mint.toBase58()] = symbol;
        } else if (ptr) {
          ptrsToFetch.push(ptr);
          ptrOwnerByKey.set(ptr.toBase58(), mint.toBase58());
        } else {
          console.log("getTokensSymbols - no TokenMetadata or pointer", mint.toBase58());
        }
      });
      if (ptrsToFetch.length) {
        const pointerInfos = await this.batchGetMultipleAccountsInfo(ptrsToFetch, "getTokensSymbols/Token2022Pointer");
        ptrsToFetch.forEach((ptrPk, idx) => {
          const pinfo = pointerInfos[idx];
          const mintB58 = ptrOwnerByKey.get(ptrPk.toBase58());
          if (!pinfo?.data) {
            console.log("getTokensSymbols - pointer account missing", ptrPk.toBase58(), "for mint", mintB58);
            return;
          }
          try {
            const md = unpackToken2022Metadata(pinfo.data);
            const symbol = md?.symbol?.replace(/\0/g, "").trim() || null;
            if (symbol) {
              out[mintB58] = symbol;
            } else {
              console.log("getTokensSymbols - pointer metadata has no symbol", ptrPk.toBase58(), "for mint", mintB58);
            }
          } catch (e) {
            console.log("getTokensSymbols - failed to unpack pointer metadata", ptrPk.toBase58(), e);
          }
        });
      }
    }
    return out;
  }
  async getSupply(CAs) {
    const mintKeys = CAs.map((ca) => new PublicKey4(ca));
    const mintInfos = await this.batchGetMultipleAccountsInfo(mintKeys, "getSupply");
    const results = mintInfos.map((accountInfo, idx) => {
      if (!accountInfo) {
        return { address: CAs[idx], error: "Account not found" };
      }
      const buf = accountInfo.data;
      const u8 = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      const mint = MintLayout.decode(u8);
      const decimals = mint.decimals;
      const supply = BigInt(mint.supply.toString());
      let denom = 1n;
      for (let i = 0;i < decimals; i++)
        denom *= 10n;
      return {
        address: CAs[idx],
        biSupply: supply,
        human: new BigNumber3(supply.toString()).dividedBy(10 ** decimals),
        decimals
      };
    });
    const out = Object.fromEntries(results.map((r) => [r.address, {
      supply: r.biSupply,
      decimals: r.decimals,
      human: r.human
    }]));
    return out;
  }
  async parseTokenAccounts(heldTokens, options = {}) {
    const nowInMs = Date.now();
    const acceptableInMs = options.notOlderThan ?? 60 * 60000;
    let cache = [];
    if (acceptableInMs !== 0) {
      console.time("cacheCheck");
      cache = await Promise.all(heldTokens.map((t) => this.runtime.getCache("solana_token_meta_" + t.account.data.parsed.info.mint)));
      console.timeEnd("cacheCheck");
    }
    let misses = 0;
    const fetchTokens = [];
    const goodCache = {};
    for (const i in heldTokens) {
      const t = heldTokens[i];
      if (cache[i]) {
        const c = cache[i];
        let useCache = false;
        if (c.data.isMutable === false) {
          useCache = true;
        } else if (acceptableInMs !== 0) {
          const diff = nowInMs - c.setAt;
          if (diff < acceptableInMs) {
            useCache = true;
          }
        }
        if (useCache) {
          const mint = t.account.data.parsed.info.mint;
          const { amount: raw, decimals } = t.account.data.parsed.info.tokenAmount;
          const balanceUi = Number(raw) / 10 ** decimals;
          goodCache[mint] = { ...c.data, balanceUi };
          continue;
        }
      }
      fetchTokens.push(heldTokens[i]);
      misses++;
    }
    this.runtime.logger.debug("parseTokenAccounts havs", heldTokens.length - misses + "/" + heldTokens.length, "in cache (1hr default)");
    const toB58 = (pk) => typeof pk === "string" ? pk : pk.toBase58();
    const TOKEN_ID_B58 = TOKEN_PROGRAM_ID.toBase58();
    const TOKEN2022_B58 = TOKEN_2022_PROGRAM_ID.toBase58();
    const t22MintKeys = Array.from(new Set(fetchTokens.filter((t) => toB58(t.account.owner) === TOKEN2022_B58).map((t) => t.account.data.parsed.info.mint))).map((s) => new PublicKey4(s));
    const classicMintKeys = Array.from(new Set(fetchTokens.filter((t) => toB58(t.account.owner) === TOKEN_ID_B58).map((t) => t.account.data.parsed.info.mint))).map((s) => new PublicKey4(s));
    const allMintKeys = Array.from(new Set(fetchTokens.map((t) => t.account.data.parsed.info.mint))).map((s) => new PublicKey4(s));
    const mintInfos = await this.batchGetMultipleAccountsInfo(allMintKeys, "t22-mints");
    const hasT22Meta = new Set;
    const t22IsMutable = new Map;
    const t22Symbols = new Map;
    const mpSymbols = new Map;
    const t22PtrAddrByMint = new Map;
    const mpSupply = new Map;
    const stripNulls = (s) => s.replace(/\u0000+$/g, "").trim();
    function readBorshStringSafe(buf, offObj) {
      if (offObj.off + 4 > buf.length)
        return "";
      const len = buf.readUInt32LE(offObj.off);
      offObj.off += 4;
      if (len < 0 || offObj.off + len > buf.length) {
        const bytes2 = buf.subarray(offObj.off, buf.length);
        offObj.off = buf.length;
        return stripNulls(bytes2.toString("utf8"));
      }
      const bytes = buf.subarray(offObj.off, offObj.off + len);
      offObj.off += len;
      return stripNulls(bytes.toString("utf8"));
    }
    function readU32LE(buf, offObj) {
      if (offObj.off + 4 > buf.length)
        throw new Error("oob u32");
      const v = buf.readUInt32LE(offObj.off);
      offObj.off += 4;
      return v;
    }
    function readVecU8AsString(buf, offObj) {
      const len = readU32LE(buf, offObj);
      if (len < 0 || offObj.off + len > buf.length)
        throw new Error("oob str");
      const s = buf.subarray(offObj.off, offObj.off + len).toString("utf8");
      offObj.off += len;
      return s.trim();
    }
    function allZero32(b) {
      for (let i = 0;i < 32; i++)
        if (b[i] !== 0)
          return false;
      return true;
    }
    function parseToken2022MetadataTLV(ext) {
      const o = { off: 0 };
      const uaBytes = ext.subarray(o.off, o.off + 32);
      o.off += 32;
      const isMutable = !allZero32(uaBytes);
      const updateAuthority = isMutable ? new PublicKey4(uaBytes).toBase58() : undefined;
      const mint = new PublicKey4(ext.subarray(o.off, o.off + 32)).toBase58();
      o.off += 32;
      const name = readVecU8AsString(ext, o);
      const symbol = readVecU8AsString(ext, o);
      const uri = readVecU8AsString(ext, o);
      const additional = [];
      if (o.off + 4 <= ext.length) {
        const n = readU32LE(ext, o);
        for (let i = 0;i < n; i++)
          additional.push([readVecU8AsString(ext, o), readVecU8AsString(ext, o)]);
      }
      return { isMutable, updateAuthority, mint, name, symbol, uri, additional: additional.length ? additional : undefined };
    }
    function formatSupplyUiAmount(amount, decimals) {
      let denom = 1n;
      for (let i = 0;i < decimals; i++)
        denom *= 10n;
      const whole = amount / denom;
      const frac = (amount % denom).toString().padStart(decimals, "0");
      return decimals === 0 ? whole.toString() : `${whole}.${frac}`.replace(/\.$/, "");
    }
    allMintKeys.forEach((mk, i) => {
      const info = mintInfos[i];
      if (!info?.data)
        return;
      const isT22 = info.owner?.toBase58?.() === TOKEN_2022_PROGRAM_ID.toBase58();
      const mintKeyStr = mk.toBase58();
      if (isT22) {
        const parsedMint = unpackMint(mk, info, TOKEN_2022_PROGRAM_ID);
        const uiSupply = formatSupplyUiAmount(parsedMint.supply, parsedMint.decimals);
        mpSupply.set(mintKeyStr, uiSupply);
        if (this.decimalsCache.get(mintKeyStr) !== parsedMint.decimals) {
          console.log("decimalsCache", this.decimalsCache.get(mintKeyStr), "!== parsedMint.decimals", parsedMint.decimals);
        }
        this.decimalsCache.set(mintKeyStr, parsedMint.decimals);
        const tlv = parsedMint.tlvData ?? Buffer.alloc(0);
        const mdExt = getExtensionData(ExtensionType.TokenMetadata, tlv);
        if (mdExt) {
          const res = parseToken2022MetadataTLV(mdExt);
          hasT22Meta.add(mintKeyStr);
          t22IsMutable.set(mintKeyStr, res.isMutable);
          t22Symbols.set(mintKeyStr, res.symbol);
          return;
        }
      } else {
        const buf = info.data;
        const u8 = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
        const header = u8.subarray(0, MintLayout.span);
        const mintData = MintLayout.decode(header);
        const uiSupply = formatSupplyUiAmount(mintData.supply, mintData.decimals);
        mpSupply.set(mintKeyStr, uiSupply);
        if (this.decimalsCache.get(mintKeyStr) !== mintData.decimals) {
          console.log("decimalsCache", this.decimalsCache.get(mintKeyStr), "!== mintData.decimals", mintData.decimals);
        }
        this.decimalsCache.set(mintKeyStr, mintData.decimals);
      }
    });
    const missingT22s = t22MintKeys.filter((m) => !hasT22Meta.has(m.toBase58()));
    console.log("missingT22s", missingT22s.length);
    const mpMintKeys = [...classicMintKeys, ...missingT22s];
    const mpAddrs = await Promise.all(mpMintKeys.map((m) => this.getMetadataAddress(m)));
    const mpInfos = mpAddrs.length ? await this.batchGetMultipleAccountsInfo(mpAddrs, "metaplex-md") : [];
    const mpIsMutable = new Map;
    mpMintKeys.forEach((mk, i) => {
      const acc = mpInfos[i];
      const data = acc?.data;
      if (!data?.length)
        return;
      const mintAddrStr = mk.toBase58();
      const limit = data.length;
      const need = (n) => n <= limit;
      let off = 1 + 32 + 32;
      if (!need(off))
        return;
      const offObj = { off };
      const name = readBorshStringSafe(data, offObj);
      const symbol = readBorshStringSafe(data, offObj);
      readBorshStringSafe(data, offObj);
      if (offObj.off + 2 > limit)
        return;
      data.readUInt16LE(offObj.off);
      offObj.off += 2;
      if (offObj.off + 1 > limit)
        return;
      const hasCreators = data.readUInt8(offObj.off);
      offObj.off += 1;
      if (hasCreators) {
        if (offObj.off + 4 > limit)
          return;
        const n = data.readUInt32LE(offObj.off);
        offObj.off += 4;
        const creatorSize = 32 + 1 + 1;
        const bytesNeeded = n * creatorSize;
        if (offObj.off + bytesNeeded > limit)
          return;
        offObj.off += bytesNeeded;
      }
      if (offObj.off + 1 > limit)
        return;
      offObj.off += 1;
      if (offObj.off + 1 > limit)
        return;
      const isMutable = data.readUInt8(offObj.off) === 1;
      mpIsMutable.set(mintAddrStr, isMutable);
      mpSymbols.set(mintAddrStr, symbol);
    });
    const t22Set = new Set(t22MintKeys.map((k) => k.toBase58()));
    const results = heldTokens.map((t) => {
      const mintStr = t.account.data.parsed.info.mint;
      const mintKey = new PublicKey4(mintStr);
      const is2022 = t22Set.has(mintStr);
      const { amount: raw, decimals } = t.account.data.parsed.info.tokenAmount;
      const balanceUi = Number(raw) / 10 ** decimals;
      const isMutable = is2022 && hasT22Meta.has(mintStr) ? t22IsMutable.get(mintStr) ?? null : mpIsMutable.get(mintStr) ?? null;
      const symbol = is2022 && hasT22Meta.has(mintStr) ? t22Symbols.get(mintStr) ?? null : mpSymbols.get(mintStr) ?? null;
      let supply = mpSupply.get(mintStr) ?? null;
      if (supply)
        supply = parseFloat(supply);
      return {
        mint: mintKey.toBase58(),
        symbol,
        supply,
        tokenProgram: is2022 ? "Token-2022" : "Token",
        decimals,
        balanceUi,
        isMutable
      };
    });
    (async () => {
      console.time("saveCache");
      for (const t of results) {
        const copy = { ...t };
        delete copy.balanceUi;
        delete copy.mint;
        const key = "solana_token_meta_" + t.mint;
        await this.runtime.setCache(key, {
          setAt: nowInMs,
          data: copy
        });
      }
      console.timeEnd("saveCache");
    })().catch((err) => console.error("solana:parseTokenAccounts - cache save failed:", err));
    const out = Object.fromEntries(results.map((r) => [r.mint, {
      symbol: r.symbol,
      supply: r.supply,
      tokenProgram: r.tokenProgram,
      decimals: r.decimals,
      balanceUi: r.balanceUi,
      isMutable: r.isMutable
    }]));
    for (const mint in goodCache) {
      out[mint] = goodCache[mint];
    }
    return out;
  }
  async getTokenAccounts() {
    if (!this.publicKey)
      return null;
    return this.getTokenAccountsByKeypair(this.publicKey);
  }
  async getWalletKeypair() {
    const keypair = this.keypair;
    if (!keypair) {
      throw new Error("Failed to get wallet keypair");
    }
    return keypair;
  }
  getPublicKey() {
    return this.publicKey;
  }
  async updateWalletData(force = false) {
    const now = Date.now();
    if (!this.publicKey) {
      logger5.log("solana::updateWalletData - no Public Key yet");
      return { totalUsd: "0", items: [] };
    }
    if (!force && now - this.lastUpdate < this.UPDATE_INTERVAL) {
      const cached = await this.getCachedData();
      if (cached)
        return cached;
    }
    try {
      const birdeyeApiKey = this.runtime.getSetting("BIRDEYE_API_KEY");
      if (birdeyeApiKey) {
        try {
          const walletData = await this.birdeyeFetchWithRetry(`${PROVIDER_CONFIG.BIRDEYE_API}/v1/wallet/token_list?wallet=${this.publicKey.toBase58()}`);
          if (walletData?.success && walletData?.data) {
            const data = walletData.data;
            const totalUsd = new BigNumber3(data.totalUsd.toString());
            const prices = await this.fetchPrices();
            const solPriceInUSD = new BigNumber3(prices.solana.usd);
            const missingSymbols = data.items.filter((i) => !i.symbol);
            if (missingSymbols.length) {
              const symbols = await this.getTokensSymbols(missingSymbols.map((i) => i.address));
              let missing = false;
              for (const i in data.items) {
                const item = data.items[i];
                if (symbols[item.address]) {
                  data.items[i].symbol = symbols[item.address];
                } else {
                  console.log("solana::updateWalletData - no symbol for", item.address, symbols[item.address]);
                  missing = true;
                }
              }
              if (missing) {
                console.log("symbols", symbols);
              }
            }
            const portfolio2 = {
              totalUsd: totalUsd.toString(),
              totalSol: totalUsd.div(solPriceInUSD).toFixed(6),
              prices,
              lastUpdated: now,
              items: data.items.map((item) => ({
                ...item,
                valueSol: new BigNumber3(item.valueUsd || 0).div(solPriceInUSD).toFixed(6),
                name: item.name || "Unknown",
                symbol: item.symbol || "Unknown",
                priceUsd: item.priceUsd || "0",
                valueUsd: item.valueUsd || "0"
              }))
            };
            await this.runtime.setCache(SOLANA_WALLET_DATA_CACHE_KEY, portfolio2);
            this.lastUpdate = now;
            return portfolio2;
          }
        } catch (e) {
          console.log("solana::updateWalletData - exception err", e);
        }
      }
      logger5.log("Using RPC fallback for wallet data (no Birdeye)");
      const accounts = await this.getTokenAccounts();
      if (!accounts || accounts.length === 0) {
        logger5.log("No token accounts found");
        const emptyPortfolio = {
          totalUsd: "0",
          totalSol: "0",
          items: []
        };
        await this.runtime.setCache(SOLANA_WALLET_DATA_CACHE_KEY, emptyPortfolio);
        this.lastUpdate = now;
        return emptyPortfolio;
      }
      const tokenMetadata = await this.parseTokenAccounts(accounts);
      const items = accounts.map((acc) => {
        const mint = acc.account.data.parsed.info.mint;
        const metadata = tokenMetadata[mint];
        this.decimalsCache.set(mint, acc.account.data.parsed.info.tokenAmount.decimals);
        return {
          name: metadata?.symbol || "Unknown",
          address: mint,
          symbol: metadata?.symbol || "Unknown",
          decimals: acc.account.data.parsed.info.tokenAmount.decimals,
          balance: acc.account.data.parsed.info.tokenAmount.amount,
          uiAmount: acc.account.data.parsed.info.tokenAmount.uiAmount.toString(),
          priceUsd: "0",
          valueUsd: "0",
          valueSol: "0"
        };
      });
      logger5.log(`Fallback mode: Found ${items.length} tokens in wallet`);
      const portfolio = {
        totalUsd: "0",
        totalSol: "0",
        items
      };
      await this.runtime.setCache(SOLANA_WALLET_DATA_CACHE_KEY, portfolio);
      this.lastUpdate = now;
      return portfolio;
    } catch (error) {
      logger5.error(`Error updating wallet data: ${error}`);
      throw error;
    }
  }
  async getCachedData() {
    const cachedValue = await this.runtime.getCache(SOLANA_WALLET_DATA_CACHE_KEY);
    if (cachedValue) {
      return cachedValue;
    }
    return null;
  }
  async forceUpdate() {
    return await this.updateWalletData(true);
  }
  async createWallet() {
    try {
      const newKeypair = Keypair2.generate();
      const publicKey = newKeypair.publicKey.toBase58();
      const privateKey = bs582.encode(newKeypair.secretKey);
      newKeypair.secretKey.fill(0);
      return {
        publicKey,
        privateKey
      };
    } catch (error) {
      logger5.error(`Error creating wallet: ${error}`);
      throw new Error("Failed to create new wallet");
    }
  }
  async getTokenAccountsByKeypair(walletAddress, options = {}) {
    const key = "solana_" + walletAddress.toString() + "_tokens";
    try {
      const now = Date.now();
      let check = false;
      if (options.notOlderThan !== 0) {
        check = await this.runtime.getCache(key);
        if (check) {
          const diff = now - check.fetchedAt;
          const acceptableInMs = options.notOlderThan ?? 60000;
          if (diff < acceptableInMs) {
            console.log("getTokenAccountsByKeypair cache HIT, its", diff.toLocaleString() + "ms old");
            return check.data;
          }
          console.log("getTokenAccountsByKeypair cache MISS, its", diff.toLocaleString() + "ms old");
        }
      }
      console.log("getTokenAccountsByKeypair - getParsedTokenAccountsByOwner", walletAddress.toString());
      const [accounts, token2022s] = await Promise.all([
        this.connection.getParsedTokenAccountsByOwner(walletAddress, {
          programId: TOKEN_PROGRAM_ID
        }),
        this.connection.getParsedTokenAccountsByOwner(walletAddress, {
          programId: TOKEN_2022_PROGRAM_ID
        })
      ]);
      const allTokens = [...token2022s.value, ...accounts.value];
      const haveAllTokens = [];
      for (const t of allTokens) {
        const { amount, decimals } = t.account.data.parsed.info.tokenAmount;
        this.decimalsCache.set(t.account.data.parsed.info.mint, decimals);
        if (options.includeZeroBalances || amount !== "0") {
          haveAllTokens.push(t);
        }
      }
      if (check) {}
      await this.runtime.setCache(key, {
        fetchedAt: now,
        data: haveAllTokens
      });
      return haveAllTokens;
    } catch (error) {
      logger5.error(`Error fetching token accounts: ${error}`);
      return [];
    }
  }
  async getTokenAccountsByKeypairs(walletAddresses, options = {}) {
    const res = await Promise.all(walletAddresses.map((a) => this.getTokenAccountsByKeypair(new PublicKey4(a), options)));
    const out = {};
    for (const i in walletAddresses) {
      out[walletAddresses[i]] = res[i];
    }
    return out;
  }
  async getBalancesByAddrs(walletAddressArr) {
    try {
      const publicKeyObjs = walletAddressArr.map((k) => new PublicKey4(k));
      const accounts = await this.batchGetMultipleAccountsInfo(publicKeyObjs, "getBalancesByAddrs");
      const out = {};
      for (const i in accounts) {
        const a = accounts[i];
        const pk = walletAddressArr[i];
        if (a?.lamports) {
          out[pk] = a.lamports * SolanaService.LAMPORTS2SOL;
        } else {
          console.log("no lamports? a", a);
          out[pk] = 0;
        }
      }
      return out;
    } catch (error) {
      const msg = error.message || "";
      if (msg.includes("429")) {
        this.runtime.logger.warn("RPC rate limit hit, pausing before retry");
        await new Promise((waitResolve) => setTimeout(waitResolve, 1000));
        return this.getBalancesByAddrs(walletAddressArr);
      }
      this.runtime.logger.error(`solSrv:getBalancesByAddrs - unexpected error: ${error}`);
      return {};
    }
  }
  async walletAddressToHumanString(pubKey) {
    let balanceStr = "";
    const pubKeyObj = new PublicKey4(pubKey);
    const [balances, heldTokens] = await Promise.all([
      this.getBalancesByAddrs([pubKey]),
      this.getTokenAccountsByKeypair(pubKeyObj)
    ]);
    const solBal = balances[pubKey];
    balanceStr += "Wallet Address: " + pubKey + `
`;
    balanceStr += `  Token Address (Symbol)
`;
    balanceStr += "  So11111111111111111111111111111111111111111 ($sol) balance: " + (solBal ?? "unknown") + `
`;
    const tokens = await this.parseTokenAccounts(heldTokens);
    for (const ca in tokens) {
      const t = tokens[ca];
      balanceStr += "  " + ca + " ($" + t.symbol + ") balance: " + t.balanceUi + `
`;
    }
    balanceStr += `
`;
    return balanceStr;
  }
  async walletAddressToLLMString(pubKey) {
    let balanceStr = "";
    const pubKeyObj = new PublicKey4(pubKey);
    const [balances, heldTokens] = await Promise.all([
      this.getBalancesByAddrs([pubKey]),
      this.getTokenAccountsByKeypair(pubKeyObj)
    ]);
    const solBal = balances[pubKey];
    balanceStr += "Wallet Address: " + pubKey + `
`;
    balanceStr += `Current wallet contents in csv format:
`;
    balanceStr += `Token Address,Symbol,Balance
`;
    balanceStr += "So11111111111111111111111111111111111111111,sol," + (solBal ?? "unknown") + `
`;
    const tokens = await this.parseTokenAccounts(heldTokens);
    for (const ca in tokens) {
      const t = tokens[ca];
      balanceStr += ca + "," + t.symbol + "," + t.balanceUi + `
`;
    }
    balanceStr += `
`;
    return balanceStr;
  }
  async getWalletBalances(publicKeyStr, mintAddresses) {
    const owner = new PublicKey4(publicKeyStr);
    const mints = mintAddresses.map((m) => new PublicKey4(m));
    const ataPairs = mints.map((mint) => {
      const ataLegacy = getAssociatedTokenAddressSync2(mint, owner, false, TOKEN_PROGRAM_ID);
      const ata2022 = getAssociatedTokenAddressSync2(mint, owner, false, TOKEN_2022_PROGRAM_ID);
      return { mint, ataLegacy, ata2022 };
    });
    const allAtaAddrs = ataPairs.flatMap((p) => [p.ataLegacy, p.ata2022]);
    const ataInfos = await this.batchGetMultipleAccountsInfo(allAtaAddrs, "getWalletBalances");
    const mintInfos = await this.batchGetMultipleAccountsInfo(mints, "getWalletBalances");
    const mintDecimals = new Map;
    mints.forEach((mintPk, i) => {
      const acc = mintInfos[i];
      if (!acc)
        return;
      const mintData = MintLayout.decode(acc.data);
      mintDecimals.set(mintPk.toBase58(), mintData.decimals);
    });
    const byAddress = new Map;
    allAtaAddrs.forEach((ata, i) => {
      const info = ataInfos[i];
      if (!info) {
        byAddress.set(ata.toBase58(), null);
        return;
      }
      byAddress.set(ata.toBase58(), AccountLayout.decode(info.data));
    });
    const out = {};
    for (const { mint, ataLegacy, ata2022 } of ataPairs) {
      const mintStr = mint.toBase58();
      const decimals = mintDecimals.get(mintStr);
      if (decimals === undefined) {
        out[mintStr] = null;
        continue;
      }
      const legacy = byAddress.get(ataLegacy.toBase58());
      const tok2022 = byAddress.get(ata2022.toBase58());
      const chosen = legacy ?? tok2022;
      if (!chosen) {
        out[mintStr] = null;
        continue;
      }
      const rawAmount = BigInt(chosen.amount.toString());
      const amountStr = rawAmount.toString();
      const uiAmount = Number(rawAmount) / 10 ** decimals;
      out[mintStr] = { amount: amountStr, decimals, uiAmount };
    }
    return out;
  }
  async getTokenBalanceForWallets(mint, walletAddresses) {
    const walletPubkeys = walletAddresses.map((a) => new PublicKey4(a));
    const atAs = walletPubkeys.map((w) => getAssociatedTokenAddressSync2(mint, w));
    const balances = {};
    const decimals = await this.getDecimal(mint);
    const infos = await this.batchGetMultipleAccountsInfo(atAs, "getTokenBalanceForWallets");
    infos.forEach((info, idx) => {
      const walletKey = walletPubkeys[idx].toBase58();
      let uiAmount = 0;
      if (info?.data) {
        const account = unpackAccount(atAs[idx], info);
        const raw = account.amount;
        uiAmount = Number(raw) / 10 ** decimals;
      }
      balances[walletKey] = uiAmount;
    });
    return balances;
  }
  async subscribeToAccount(accountAddress, handler) {
    try {
      if (!this.validateAddress(accountAddress)) {
        throw new Error("Invalid account address");
      }
      if (this.subscriptions.has(accountAddress)) {
        return this.subscriptions.get(accountAddress);
      }
      const accountPubkeyObj = new PublicKey4(accountAddress);
      const subscriptionId = this.connection.onAccountChange(accountPubkeyObj, (accountInfo, context) => {
        handler(accountAddress, accountInfo, context);
      }, "finalized");
      this.subscriptions.set(accountAddress, subscriptionId);
      logger5.log(`Subscribed to account ${accountAddress} with ID ${subscriptionId}`);
      return subscriptionId;
    } catch (error) {
      logger5.error(`Error subscribing to account: ${error}`);
      throw error;
    }
  }
  async unsubscribeFromAccount(accountAddress) {
    try {
      const subscriptionId = this.subscriptions.get(accountAddress);
      if (!subscriptionId) {
        logger5.warn(`No subscription found for account ${accountAddress}`);
        return false;
      }
      await this.connection.removeAccountChangeListener(subscriptionId);
      this.subscriptions.delete(accountAddress);
      return true;
    } catch (error) {
      logger5.error(`Error unsubscribing from account: ${error}`);
      throw error;
    }
  }
  async calculateOptimalBuyAmount(inputMint, outputMint, availableAmount) {
    try {
      const priceImpact = await this.jupiterService.getPriceImpact({
        inputMint,
        outputMint,
        amount: availableAmount
      });
      const slippage = await this.jupiterService.findBestSlippage({
        inputMint,
        outputMint,
        amount: availableAmount
      });
      let optimalAmount = availableAmount;
      if (priceImpact > 5) {
        optimalAmount = availableAmount * 0.5;
        console.log("calculateOptimalBuyAmount - too much price impact halving", optimalAmount);
      }
      return { amount: optimalAmount, slippage };
    } catch (error) {
      logger5.error(`Error calculating optimal buy amount: ${error}`);
      throw error;
    }
  }
  async calculateOptimalBuyAmount2(quote, availableAmount) {
    try {
      const priceImpact = Number(quote.priceImpactPct);
      let optimalAmount = availableAmount;
      if (priceImpact > 5) {
        optimalAmount = availableAmount * 0.5;
        console.log("calculateOptimalBuyAmount2 - too much price impact halving", optimalAmount);
      }
      let recommendedSlippage;
      if (priceImpact < 0.5) {
        recommendedSlippage = 50;
      } else if (priceImpact < 1) {
        recommendedSlippage = 100;
      } else {
        recommendedSlippage = 200;
      }
      return { amount: optimalAmount, slippage: recommendedSlippage };
    } catch (error) {
      logger5.error(`calculateOptimalBuyAmount2 - Error calculating optimal buy amount: ${error}`);
      throw error;
    }
  }
  async executeSwap(wallets, signal) {
    const swapResponses = {};
    for (const wallet of wallets) {
      const pubKey = wallet.keypair.publicKey.toString();
      try {
        const intAmount = parseInt(wallet.amount.toString());
        if (isNaN(intAmount) || intAmount <= 0) {
          console.warn(`solana::executeSwap - Amount in ${wallet.amount} become ${intAmount}`);
          swapResponses[pubKey] = {
            success: false,
            error: "bad amount"
          };
          continue;
        }
        const balances = await this.getBalancesByAddrs([pubKey]);
        const bal = balances[pubKey];
        const baseLamports = this.jupiterService.estimateLamportsNeeded({ inputMint: signal.sourceTokenCA, inAmount: intAmount });
        const ourLamports = bal * 1e9;
        if (baseLamports > ourLamports) {
          console.log(`executeSwap - wallet ${wallet.keypair.publicKey} SOL is too low to swap baseLamports ${baseLamports.toLocaleString()} weHave ${ourLamports.toLocaleString()}`);
          swapResponses[pubKey] = {
            success: false,
            error: "not enough SOL"
          };
          continue;
        }
        console.log("signal.sourceTokenCA", signal.sourceTokenCA, "signal.targetTokenCA", signal.targetTokenCA, "wallet.amount", wallet.amount.toLocaleString());
        const initialQuote = await this.jupiterService.getQuote({
          inputMint: signal.sourceTokenCA,
          outputMint: signal.targetTokenCA,
          slippageBps: 200,
          amount: intAmount
        });
        console.log("initialQuote", initialQuote);
        if (initialQuote.totalLamportsNeeded > baseLamports) {
          console.log("initialQuote fee over estimate: ", baseLamports.toLocaleString());
          console.log("routes", initialQuote.routePlan);
        }
        const availableLamports = bal * 1e9;
        if (initialQuote.totalLamportsNeeded > availableLamports) {
          console.log(`executeSwap - wallet ${wallet.keypair.publicKey} SOL is too low, has ${availableLamports.toLocaleString()} needs ${initialQuote.totalLamportsNeeded.toLocaleString()}`);
          swapResponses[pubKey] = {
            success: false,
            error: "not enough SOL"
          };
          continue;
        }
        const impliedSlippageBps = (initialQuote.outAmount - initialQuote.otherAmountThreshold) / initialQuote.outAmount * 1e4;
        console.log("impliedSlippageBps", impliedSlippageBps, "jupSlip", initialQuote.slippageBps);
        const { amount, slippage } = await this.calculateOptimalBuyAmount2(initialQuote, wallet.amount);
        console.log("adjusted amount", Number("" + amount).toLocaleString(), "price impact slippage", slippage);
        initialQuote.inAmount = "" + amount;
        delete initialQuote.swapUsdValue;
        let swapResponse;
        const executeSwap2 = async (impliedSlippageBps2) => {
          console.log("executingSwap", pubKey, signal.sourceTokenCA, signal.targetTokenCA, "with", impliedSlippageBps2 + "bps slippage");
          swapResponse = await this.jupiterService.executeSwap({
            quoteResponse: initialQuote,
            userPublicKey: pubKey,
            slippageBps: parseInt(impliedSlippageBps2.toString())
          });
          const secretKey = bs582.decode(wallet.keypair.privateKey);
          const keypair = Keypair2.fromSecretKey(secretKey);
          const txBuffer = Buffer.from(swapResponse.swapTransaction, "base64");
          const transaction = VersionedTransaction3.deserialize(Uint8Array.from(txBuffer));
          transaction.sign([keypair]);
          let txid2 = "";
          try {
            txid2 = await this.connection.sendRawTransaction(transaction.serialize());
          } catch (err) {
            if (err instanceof SendTransactionError) {
              const logs = err.logs || await err.getLogs(this.connection);
              let showLogs = true;
              if (logs) {
                if (logs.some((l) => l.includes("custom program error: 0x1771"))) {
                  console.log(`Swap failed: slippage tolerance exceeded. ${impliedSlippageBps2}`);
                  if (signal.targetTokenCA === "So11111111111111111111111111111111111111112") {
                    if (impliedSlippageBps2 < 3000) {
                      await new Promise((resolve) => setTimeout(resolve, 1000));
                      return executeSwap2(impliedSlippageBps2 * 2);
                    }
                  } else {
                    showLogs = false;
                  }
                }
                if (logs.some((l) => l.includes("insufficient lamports"))) {
                  console.log("Transaction failed: insufficient lamports in the account.");
                }
                if (logs.some((l) => l.includes("Program X failed: custom program error"))) {
                  console.log("Custom program failure detected.");
                }
                if (showLogs) {
                  console.log("logs", logs);
                }
              }
            }
            throw err;
          }
          console.log(pubKey, signal.sourceTokenCA, signal.targetTokenCA, "txid", txid2);
          return txid2;
        };
        const txid = await executeSwap2(impliedSlippageBps);
        await this.connection.confirmTransaction(txid, "finalized");
        const txDetails = await this.connection.getTransaction(txid, {
          commitment: "confirmed",
          maxSupportedTransactionVersion: 0
        });
        let outAmount = initialQuote.outAmount;
        console.log("going to report", initialQuote.outAmount);
        if (txDetails?.meta?.preTokenBalances && txDetails?.meta?.postTokenBalances) {
          let tokenCA = signal.targetTokenCA;
          const inBal = txDetails.meta.preTokenBalances.find((tb) => tb.owner === pubKey && tb.mint === tokenCA);
          const outBal = txDetails.meta.postTokenBalances.find((tb) => tb.owner === pubKey && tb.mint === tokenCA);
          console.log("inBal", inBal?.uiTokenAmount?.uiAmount, "outBal", outBal?.uiTokenAmount?.uiAmount);
          if (outBal?.uiTokenAmount.decimals) {
            this.decimalsCache.set(tokenCA, outBal.uiTokenAmount.decimals);
          }
          if (signal.targetTokenCA === "So11111111111111111111111111111111111111112") {
            console.log("selling, how much sol we getting from meta", pubKey, txDetails.meta.postTokenBalances);
            if (inBal && outBal) {
              const lamDiff = (inBal.uiTokenAmount.uiAmount ?? 0) - (outBal.uiTokenAmount.uiAmount ?? 0);
              const diff = Number(inBal.uiTokenAmount.amount ?? 0) - Number(outBal.uiTokenAmount.amount ?? 0);
              if (diff) {
                outAmount = diff;
                console.log("changing report to", outAmount, "(", lamDiff, ")");
              }
            } else if (outBal) {
              const amt = Number(outBal.uiTokenAmount.amount);
              if (amt) {
                outAmount = amt;
                console.log("changing report to", outAmount);
              }
            } else {
              console.log("no balances? wallet", pubKey, "token", tokenCA);
              console.log("wallet", txDetails.meta.preTokenBalances.find((tb) => tb.owner === pubKey), "=>", txDetails.meta.postTokenBalances.find((tb) => tb.owner === pubKey));
            }
          } else {
            if (inBal && outBal) {
              const lamDiff = (outBal.uiTokenAmount.uiAmount ?? 0) - (inBal.uiTokenAmount.uiAmount ?? 0);
              const diff = Number(outBal.uiTokenAmount.amount ?? 0) - Number(inBal.uiTokenAmount.amount ?? 0);
              if (diff) {
                outAmount = diff;
                console.log("changing report to", outAmount, "(", lamDiff, ")");
              }
            } else if (outBal) {
              const amt = Number(outBal.uiTokenAmount.amount);
              if (amt) {
                outAmount = amt;
                console.log("changing report to", outAmount);
              }
            } else {
              console.log("no balances? wallet", pubKey, "token", tokenCA);
              console.log("wallet", txDetails?.meta?.preTokenBalances?.find((tb) => tb.owner === pubKey), "=>", txDetails?.meta?.postTokenBalances?.find((tb) => tb.owner === pubKey));
            }
          }
        }
        const fee = txDetails?.meta?.fee;
        console.log(`Transaction fee: ${fee?.toLocaleString()} lamports`);
        const fees = {
          lamports: fee,
          sol: fee ? fee * SolanaService.LAMPORTS2SOL : 0
        };
        swapResponses[pubKey] = {
          success: true,
          outAmount,
          outDecimal: await this.getDecimal(new PublicKey4(signal.targetTokenCA)),
          signature: txid,
          fees,
          swapResponse
        };
      } catch (error) {
        logger5.error(`Error in swap execution: ${error}`);
        swapResponses[pubKey] = { success: false };
      }
    }
    return swapResponses;
  }
  static async start(runtime) {
    runtime.logger.log(`SolanaService start for ${runtime.character.name}`);
    const solanaService = new SolanaService(runtime);
    return solanaService;
  }
  static async stop(runtime) {
    const client = runtime.getService(SOLANA_SERVICE_NAME);
    if (!client) {
      runtime.logger.error("SolanaService not found during static stop");
      return;
    }
    await client.stop();
  }
  async stop() {
    this.runtime.logger.info("SolanaService: Stopping instance...");
    for (const [address] of this.subscriptions) {
      await this.unsubscribeFromAccount(address).catch((e) => this.runtime.logger.error(`Error unsubscribing from ${address} during stop:`, e instanceof Error ? e.message : String(e)));
    }
    this.subscriptions.clear();
  }
}

// src/index.ts
var solanaPlugin = {
  name: SOLANA_SERVICE_NAME,
  description: "Solana blockchain plugin",
  services: [SolanaService, SolanaWalletService],
  init: async (_, runtime) => {
    if (!runtime.getSetting("SOLANA_RPC_URL")) {
      runtime.logger.log("no SOLANA_RPC_URL, skipping plugin-solana init");
      return;
    }
    const noActions = parseBooleanFromText(runtime.getSetting("SOLANA_NO_ACTIONS"));
    if (!noActions) {
      runtime.registerAction(transfer_default);
      runtime.registerAction(executeSwap);
    } else {
      runtime.logger.log("SOLANA_NO_ACTIONS is set, skipping solana actions");
    }
    runtime.registerProvider(walletProvider);
    runtime.getServiceLoadPromise("INTEL_CHAIN").then(() => {
      const traderChainService = runtime.getService("INTEL_CHAIN");
      const me = {
        name: "Solana services",
        chain: "solana",
        service: SOLANA_SERVICE_NAME
      };
      traderChainService.registerChain(me);
    }).catch((error) => {
      runtime.logger.error({ error }, "Failed to register with INTEL_CHAIN");
    });
  }
};
var src_default = solanaPlugin;
export {
  solanaPlugin,
  src_default as default,
  SolanaWalletService,
  SolanaService,
  SOLANA_SERVICE_NAME
};

//# debugId=466661F0A0C4158164756E2164756E21
