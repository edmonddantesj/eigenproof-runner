import { type IAgentRuntime, Service } from '@elizaos/core';
import { IWalletService, WalletPortfolio as siWalletPortfolio } from '@elizaos/service-interfaces';
import { Connection, Keypair, PublicKey, type AccountInfo, type ParsedAccountData } from '@solana/web3.js';
import BigNumber from 'bignumber.js';
import type { WalletPortfolio } from './types';
export type MintBalance = {
    amount: string;
    decimals: number;
    uiAmount: number;
};
type KeyedParsedTokenAccount = {
    pubkey: PublicKey;
    account: AccountInfo<ParsedAccountData>;
};
export interface ISolanaPluginServiceAPI extends Service {
    executeSwap: (wallets: Array<{
        keypair: any;
        amount: number;
    }>, signal: any) => Promise<Record<string, unknown>>;
    getPublicKey: () => PublicKey | null;
}
export declare class SolanaWalletService extends IWalletService {
    private _solanaService;
    constructor(runtime?: IAgentRuntime);
    private get solanaService();
    /**
     * Retrieves the entire portfolio of assets held by the wallet.
     * @param owner - Optional: The specific wallet address/owner to query.
     * @returns A promise that resolves to the wallet's portfolio.
     */
    getPortfolio(owner?: string): Promise<siWalletPortfolio>;
    /**
     * Retrieves the balance of a specific asset in the wallet.
     * @param assetAddress - The mint address or native identifier ('SOL') of the asset.
     * @param owner - Optional: The specific wallet address/owner to query.
     * @returns A promise that resolves to the user-friendly (decimal-adjusted) balance of the asset held.
     */
    getBalance(assetAddress: string, owner?: string): Promise<number>;
    /**
     * Transfers SOL from a specified keypair to a public key.
     * The service's own wallet is used to pay transaction fees.
     * @param {Keypair} from - The keypair of the account to send SOL from.
     * @param {PublicKey} to - The public key of the account to send SOL to.
     * @param {number} lamports - The amount of SOL to send, in lamports.
     * @returns {Promise<string>} The transaction signature.
     * @throws {Error} If the transfer fails.
     */
    transferSol(from: Keypair, to: PublicKey, lamports: number): Promise<string>;
    /**
     * Starts the Solana wallet service with the given agent runtime.
     *
     * @param {IAgentRuntime} runtime - The agent runtime to use for the Solana service.
     * @returns {Promise<SolanaService>} The initialized Solana service.
     */
    static start(runtime: IAgentRuntime): Promise<Service>;
    /**
     * Stops the Solana wallet service.
     *
     * @param {IAgentRuntime} runtime - The agent runtime.
     * @returns {Promise<void>} - A promise that resolves once the Solana service has stopped.
     */
    static stop(runtime: IAgentRuntime): Promise<unknown>;
    /**
     * @returns {Promise<void>} A Promise that resolves when the update interval is stopped.
     */
    stop(): Promise<void>;
}
/**
 * Service class for interacting with the Solana blockchain and accessing wallet data.
 * @extends Service
 */
export declare class SolanaService extends Service {
    static readonly serviceType: string;
    readonly capabilityDescription: typeof IWalletService.prototype.capabilityDescription;
    private lastUpdate;
    private readonly UPDATE_INTERVAL;
    private connection;
    private publicKey;
    private keypair;
    private exchangeRegistry;
    private subscriptions;
    jupiterService: any;
    static readonly LAMPORTS2SOL: number;
    static readonly SOL2LAMPORTS = 1000000000;
    private decimalsCache;
    /**
     * Constructor for creating an instance of the class.
     * @param {IAgentRuntime} runtime - The runtime object that provides access to agent-specific functionality.
     */
    constructor(runtime?: IAgentRuntime);
    /**
     * Retrieves the connection object.
     *
     * @returns {Connection} The connection object.
     */
    getConnection(): Connection;
    /**
     * Registers a swap provider to execute swaps
     * @param {any} provider - The provider to register
     * @returns {Promise<number>} The ID assigned to the registered provider
     */
    registerExchange(provider: any): Promise<number>;
    /**
     * Fetches data from the provided URL with retry logic.
     * @param {string} url - The URL to fetch data from.
     * @param {Record<string, any>} [options={}] - The options for the fetch request.
     * @returns {Promise<unknown>} - A promise that resolves to the fetched data.
     */
    private birdeyeFetchWithRetry;
    batchGetMultipleAccountsInfo(pubkeys: PublicKey[], label: string): Promise<(AccountInfo<Buffer> | null)[]>;
    verifySignature({ publicKeyBase58, message, signatureBase64 }: {
        message: string;
        signatureBase64: string;
        publicKeyBase58: string;
    }): boolean;
    verifySolanaSignature({ message, signatureBase64, publicKeyBase58 }: {
        message: string;
        signatureBase64: string;
        publicKeyBase58: string;
    }): boolean;
    isValidAddress(address: string, onCurveOnly?: boolean): boolean;
    isValidSolanaAddress(address: string, onCurveOnly?: boolean): boolean;
    /**
     * Validates a Solana address.
     * @param {string | undefined} address - The address to validate.
     * @returns {boolean} True if the address is valid, false otherwise.
     */
    validateAddress(address: string | undefined): boolean;
    private static readonly TOKEN_ACCOUNT_DATA_LENGTH;
    private static readonly TOKEN_MINT_DATA_LENGTH;
    getAddressType(address: string): Promise<string>;
    getAddressesTypes(addresses: string[]): Promise<Record<string, string>>;
    /**
     * Detect Solana public keys (Base58) in a string
     * @param input arbitrary text
     * @param checkCurve whether to verify the key is on the Ed25519 curve via @solana/web3.js
     * @returns list of detected public key strings
     */
    detectPubkeysFromString(input: string, checkCurve?: boolean): Array<string>;
    /**
     * Detect Solana private keys in a string.
     *
     * ⚠️ SECURITY WARNING: This method handles sensitive private key material.
     * - Never log or expose the returned bytes
     * - Clear sensitive data from memory after use
     * - Consider if this method should be public
     *
     * Supports:
     * - Base58 (≈88 chars, representing 64 bytes → 512 bits)
     * - Hexadecimal (128 hex chars → 64 bytes)
     *
     * Returns an array of objects with the original match and decoded bytes.
     */
    detectPrivateKeysFromString(input: string): Array<{
        format: 'base58' | 'hex';
        match: string;
        bytes: Uint8Array;
    }>;
    getCirculatingSupply(mint: string): Promise<number>;
    getCirculatingSupplies(mints: string[]): Promise<number[]>;
    /**
     * Asynchronously fetches the prices of SOL, BTC, and ETH tokens.
     * Uses cache to store and retrieve prices if available.
     * @returns A Promise that resolves to an object containing the prices of SOL, BTC, and ETH tokens.
     */
    private fetchPrices;
    getDecimal(mintPublicKey: PublicKey): Promise<number>;
    getDecimals(mints: string[]): Promise<number[]>;
    getMetadataAddress(mint: PublicKey): Promise<PublicKey>;
    getTokenSymbol(mint: PublicKey): Promise<string | null>;
    private parseToken2022SymbolFromMintOrPtr;
    getTokensSymbols(mints: string[]): Promise<Record<string, string | null>>;
    getSupply(CAs: string[]): Promise<{
        [k: string]: {
            supply: bigint | undefined;
            decimals: number | undefined;
            human: BigNumber | undefined;
        };
    }>;
    parseTokenAccounts(heldTokens: any[], options?: {
        notOlderThan?: number;
    }): Promise<any>;
    /**
     * Asynchronously fetches token accounts for a specific owner.
     *
     * @returns {Promise<any[]>} A promise that resolves to an array of token accounts.
     */
    private getTokenAccounts;
    /**
     * Gets the wallet keypair for operations requiring private key access
     * @returns {Promise<Keypair>} The wallet keypair
     * @throws {Error} If private key is not available
     */
    getWalletKeypair(): Promise<Keypair>;
    /**
     * Retrieves the public key of the instance.
     *
     * @returns {PublicKey} The public key of the instance.
     */
    getPublicKey(): PublicKey | null;
    /**
     * Update wallet data including fetching wallet portfolio information, prices, and caching the data.
     * @param {boolean} [force=false] - Whether to force update the wallet data even if the update interval has not passed
     * @returns {Promise<WalletPortfolio>} The updated wallet portfolio information
     */
    updateWalletData(force?: boolean): Promise<WalletPortfolio>;
    /**
     * Retrieves cached wallet portfolio data from the database adapter.
     * @returns A promise that resolves with the cached WalletPortfolio data if available, otherwise resolves with null.
     */
    getCachedData(): Promise<WalletPortfolio | null>;
    /**
     * Forces an update of the wallet data and returns the updated WalletPortfolio object.
     * @returns A promise that resolves with the updated WalletPortfolio object.
     */
    forceUpdate(): Promise<WalletPortfolio>;
    /**
     * Creates a new Solana wallet by generating a keypair
     * @returns {Promise<{publicKey: string, privateKey: string}>} Object containing base58-encoded public and private keys
     */
    createWallet(): Promise<{
        publicKey: string;
        privateKey: string;
    }>;
    getTokenAccountsByKeypair(walletAddress: PublicKey, options?: {
        notOlderThan?: number;
        includeZeroBalances?: boolean;
    }): Promise<KeyedParsedTokenAccount[]>;
    getTokenAccountsByKeypairs(walletAddresses: string[], options?: {}): Promise<Record<string, KeyedParsedTokenAccount[]>>;
    getBalancesByAddrs(walletAddressArr: string[]): Promise<Record<string, number>>;
    walletAddressToHumanString(pubKey: string): Promise<string>;
    walletAddressToLLMString(pubKey: string): Promise<string>;
    getWalletBalances(publicKeyStr: string, mintAddresses: string[]): Promise<Record<string, MintBalance | null>>;
    getTokenBalanceForWallets(mint: PublicKey, walletAddresses: string[]): Promise<Record<string, number>>;
    /**
     * Subscribes to account changes for the given public key
     * @param {string} accountAddress - The account address to subscribe to
     * @returns {Promise<number>} Subscription ID
     */
    subscribeToAccount(accountAddress: string, handler: any): Promise<number>;
    /**
     * Unsubscribes from account changes
     * @param {string} accountAddress - The account address to unsubscribe from
     * @returns {Promise<boolean>} Success status
     */
    unsubscribeFromAccount(accountAddress: string): Promise<boolean>;
    /**
     * Calculates the optimal buy amount and slippage based on market conditions
     * @param {string} inputMint - Input token mint address
     * @param {string} outputMint - Output token mint address
     * @param {number} availableAmount - Available amount to trade
     * @returns {Promise<{ amount: number; slippage: number }>} Optimal amount and slippage
     */
    calculateOptimalBuyAmount(inputMint: string, outputMint: string, availableAmount: number): Promise<{
        amount: number;
        slippage: number;
    }>;
    calculateOptimalBuyAmount2(quote: any, availableAmount: number): Promise<{
        amount: number;
        slippage: number;
    }>;
    /**
     * Executes buy/sell orders for multiple wallets
     * @param {Array<{ keypair: any; amount: number }>} wallets - Array of buy information
     * @param {any} signal - Trading signal information
     * @returns {Promise<Array<{ success: boolean; outAmount?: number; fees?: any; swapResponse?: any }>>}
     */
    executeSwap(wallets: Array<{
        keypair: any;
        amount: number;
    }>, signal: any): Promise<Record<string, unknown>>;
    /**
     * Starts the Solana service with the given agent runtime.
     *
     * @param {IAgentRuntime} runtime - The agent runtime to use for the Solana service.
     * @returns {Promise<SolanaService>} The initialized Solana service.
     */
    static start(runtime: IAgentRuntime): Promise<Service>;
    /**
     * Stops the Solana service.
     *
     * @param {IAgentRuntime} runtime - The agent runtime.
     * @returns {Promise<void>} - A promise that resolves once the Solana service has stopped.
     */
    static stop(runtime: IAgentRuntime): Promise<unknown>;
    /**
     * Cleans up subscriptions
     * @returns {Promise<void>} A Promise that resolves when the update interval is stopped.
     */
    stop(): Promise<void>;
}
export {};
//# sourceMappingURL=service.d.ts.map