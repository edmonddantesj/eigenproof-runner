/**
 * In-memory backing store for the RuntimeBridge's IDatabaseAdapter methods.
 *
 * Every collection is a plain Map or array. No persistence. Designed to give
 * Eliza plugins a functional database layer during adapter execution without
 * requiring an actual database connection.
 *
 * Each public method corresponds 1:1 to an IDatabaseAdapter method signature.
 */
import type { Agent, Component, Entity, Log, LogBody, Memory, MemoryMetadata, Participant, Relationship, Room, Task, UUID, World, Metadata } from "./eliza-types.js";
export declare class InMemoryStore {
    /** Max memories per table before oldest are evicted. */
    static readonly MAX_MEMORIES_PER_TABLE = 10000;
    /** Max total log entries before oldest are evicted. */
    static readonly MAX_LOGS = 5000;
    private agents;
    private entities;
    private rooms;
    private worlds;
    private components;
    private componentsByEntity;
    private memories;
    private memoriesById;
    private participants;
    private participantState;
    private relationships;
    private tasks;
    private logs;
    private cache;
    private embeddingDimension;
    getAgent(agentId: UUID): Promise<Agent | null>;
    getAgents(): Promise<Partial<Agent>[]>;
    createAgent(agent: Partial<Agent>): Promise<boolean>;
    updateAgent(agentId: UUID, agent: Partial<Agent>): Promise<boolean>;
    deleteAgent(agentId: UUID): Promise<boolean>;
    getEntitiesByIds(entityIds: UUID[]): Promise<Entity[] | null>;
    getEntitiesForRoom(roomId: UUID, _includeComponents?: boolean): Promise<Entity[]>;
    createEntities(ents: Entity[]): Promise<boolean>;
    updateEntity(entity: Entity): Promise<void>;
    private componentKey;
    getComponent(entityId: UUID, type: string, worldId?: UUID, sourceEntityId?: UUID): Promise<Component | null>;
    getComponents(entityId: UUID, _worldId?: UUID, _sourceEntityId?: UUID): Promise<Component[]>;
    createComponent(component: Component): Promise<boolean>;
    updateComponent(component: Component): Promise<void>;
    deleteComponent(componentId: UUID): Promise<void>;
    getMemories(params: {
        entityId?: UUID;
        agentId?: UUID;
        count?: number;
        offset?: number;
        unique?: boolean;
        tableName: string;
        start?: number;
        end?: number;
        roomId?: UUID;
        worldId?: UUID;
    }): Promise<Memory[]>;
    getMemoryById(id: UUID): Promise<Memory | null>;
    getMemoriesByIds(ids: UUID[], _tableName?: string): Promise<Memory[]>;
    getMemoriesByRoomIds(params: {
        tableName: string;
        roomIds: UUID[];
        limit?: number;
    }): Promise<Memory[]>;
    getCachedEmbeddings(_params: {
        query_table_name: string;
        query_threshold: number;
        query_input: string;
        query_field_name: string;
        query_field_sub_name: string;
        query_match_count: number;
    }): Promise<{
        embedding: number[];
        levenshtein_score: number;
    }[]>;
    searchMemories(params: {
        embedding: number[];
        match_threshold?: number;
        count?: number;
        unique?: boolean;
        tableName: string;
        query?: string;
        roomId?: UUID;
        worldId?: UUID;
        entityId?: UUID;
    }): Promise<Memory[]>;
    createMemory(memory: Memory, tableName: string, _unique?: boolean): Promise<UUID>;
    updateMemory(memory: Partial<Memory> & {
        id: UUID;
        metadata?: MemoryMetadata;
    }): Promise<boolean>;
    deleteMemory(memoryId: UUID): Promise<void>;
    deleteManyMemories(memoryIds: UUID[]): Promise<void>;
    deleteAllMemories(roomId: UUID, tableName: string): Promise<void>;
    countMemories(roomId: UUID, unique?: boolean, tableName?: string): Promise<number>;
    getRoom(roomId: UUID): Promise<Room | null>;
    getRoomsByIds(roomIds: UUID[]): Promise<Room[] | null>;
    createRooms(roomsToCreate: Room[]): Promise<UUID[]>;
    deleteRoom(roomId: UUID): Promise<void>;
    deleteRoomsByWorldId(worldId: UUID): Promise<void>;
    updateRoom(room: Room): Promise<void>;
    getRoomsForParticipant(entityId: UUID): Promise<UUID[]>;
    getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]>;
    getRoomsByWorld(worldId: UUID): Promise<Room[]>;
    addParticipantsRoom(entityIds: UUID[], roomId: UUID): Promise<boolean>;
    removeParticipant(entityId: UUID, roomId: UUID): Promise<boolean>;
    getParticipantsForEntity(entityId: UUID): Promise<Participant[]>;
    getParticipantsForRoom(roomId: UUID): Promise<UUID[]>;
    isRoomParticipant(roomId: UUID, entityId: UUID): Promise<boolean>;
    getParticipantUserState(roomId: UUID, entityId: UUID): Promise<"FOLLOWED" | "MUTED" | null>;
    setParticipantUserState(roomId: UUID, entityId: UUID, state: "FOLLOWED" | "MUTED" | null): Promise<void>;
    createWorld(world: World): Promise<UUID>;
    getWorld(id: UUID): Promise<World | null>;
    removeWorld(id: UUID): Promise<void>;
    getAllWorlds(): Promise<World[]>;
    updateWorld(world: World): Promise<void>;
    createRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
        tags?: string[];
        metadata?: Metadata;
    }): Promise<boolean>;
    updateRelationship(relationship: Relationship): Promise<void>;
    getRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
    }): Promise<Relationship | null>;
    getRelationships(params: {
        entityId: UUID;
        tags?: string[];
    }): Promise<Relationship[]>;
    createTask(task: Task): Promise<UUID>;
    getTasks(params: {
        roomId?: UUID;
        tags?: string[];
        entityId?: UUID;
    }): Promise<Task[]>;
    getTask(id: UUID): Promise<Task | null>;
    getTasksByName(name: string): Promise<Task[]>;
    updateTask(id: UUID, task: Partial<Task>): Promise<void>;
    deleteTask(id: UUID): Promise<void>;
    log(params: {
        body: LogBody;
        entityId: UUID;
        roomId: UUID;
        type: string;
    }): Promise<void>;
    getLogs(params: {
        entityId?: UUID;
        roomId?: UUID;
        type?: string;
        count?: number;
        offset?: number;
    }): Promise<Log[]>;
    deleteLog(logId: UUID): Promise<void>;
    getCache<T>(key: string): Promise<T | undefined>;
    setCache<T>(key: string, value: T): Promise<boolean>;
    deleteCache(key: string): Promise<boolean>;
    ensureEmbeddingDimension(dimension: number): Promise<void>;
    getEmbeddingDimension(): number;
    clear(): void;
}
//# sourceMappingURL=in-memory-store.d.ts.map