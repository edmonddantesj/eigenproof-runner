import { buildMemoryFromToolParams } from "./memory-builder.js";
import { convertActionParameters, fallbackActionSchema, KNOWN_ACTION_SCHEMAS } from "./schema-converter.js";
export function adaptActionToTool(action, bridge) {
    let schema;
    if (action.parameters && action.parameters.length > 0) {
        schema = convertActionParameters(action.parameters);
    }
    else if (action.name in KNOWN_ACTION_SCHEMAS) {
        schema = KNOWN_ACTION_SCHEMAS[action.name];
    }
    else {
        schema = fallbackActionSchema(action.description);
    }
    const toolName = `eliza_${action.name.toLowerCase().replace(/[^a-z0-9_]/g, "_")}`;
    return {
        name: toolName,
        label: action.name.replace(/_/g, " "),
        description: action.description,
        parameters: schema,
        async execute(_toolCallId, args) {
            const message = buildMemoryFromToolParams(args, action.name, bridge.agentId);
            if (!(await action.validate(bridge, message, undefined))) {
                return {
                    content: [{ type: "text", text: `Action "${action.name}" validation failed. Check required settings.` }],
                    details: { error: "validation_failed", action: action.name },
                };
            }
            const state = await bridge.composeState(message);
            const responses = [];
            const callback = async (response) => {
                const mem = { content: response, entityId: bridge.agentId, roomId: message.roomId, createdAt: Date.now() };
                responses.push(mem);
                return [mem];
            };
            let result;
            try {
                result = await action.handler(bridge, message, state, { parameters: args }, callback, responses);
            }
            catch (err) {
                bridge.logger.error(`[eliza-adapter] Action "${action.name}" threw: ${err instanceof Error ? err.message : String(err)}`);
                throw err;
            }
            return formatResult(action.name, result ?? undefined, responses);
        },
    };
}
function formatResult(actionName, result, responses) {
    const content = [];
    const details = { action: actionName };
    if (result?.text)
        content.push({ type: "text", text: result.text });
    for (const r of responses) {
        if (r.content.text)
            content.push({ type: "text", text: r.content.text });
    }
    if (content.length === 0) {
        const status = result?.success !== false ? "completed" : "failed";
        const err = result?.error instanceof Error ? result.error.message : result?.error;
        content.push({ type: "text", text: err ? `Action "${actionName}" ${status}: ${err}` : `Action "${actionName}" ${status}.` });
    }
    if (result?.data)
        details["data"] = result.data;
    details["success"] = result?.success !== false;
    return { content, details };
}
//# sourceMappingURL=action-to-tool.js.map