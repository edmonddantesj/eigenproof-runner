import { buildMemory } from "./memory-builder.js";
function minState(bridge, text) {
    return { values: { agentName: bridge.character.name ?? "Eliza" }, data: {}, text };
}
export function adaptEvaluatorToHook(evaluator, bridge) {
    if ((evaluator.phase ?? "post") === "pre") {
        return {
            hookName: "message_received",
            evaluatorName: evaluator.name,
            async handler(event) {
                const message = buildMemory({ text: event.content, agentId: bridge.agentId, source: event.from });
                const state = minState(bridge, event.content);
                if (!evaluator.alwaysRun && !(await evaluator.validate(bridge, message, state)))
                    return;
                const result = await evaluator.handler(bridge, message, state, {}, undefined, undefined);
                if (result && typeof result === "object" && "blocked" in result && result.blocked) {
                    bridge.logger.warn(`[eliza-adapter] Pre-evaluator "${evaluator.name}" blocked message: ${result.reason ?? "no reason"}`);
                }
            },
        };
    }
    return {
        hookName: "agent_end",
        evaluatorName: evaluator.name,
        async handler(event) {
            if (!event.success)
                return;
            const message = buildMemory({ text: "Agent conversation ended", agentId: bridge.agentId });
            const state = minState(bridge, "");
            if (!evaluator.alwaysRun && !(await evaluator.validate(bridge, message, state)))
                return;
            await evaluator.handler(bridge, message, state, {}, undefined, undefined);
        },
    };
}
//# sourceMappingURL=evaluator-to-hook.js.map