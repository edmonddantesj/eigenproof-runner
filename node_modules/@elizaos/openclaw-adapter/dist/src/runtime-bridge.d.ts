import type { Action, ActionResult, Agent, Character, Component, Entity, Evaluator, EventPayload, IAgentRuntime, Log, LogBody, Memory, MemoryMetadata, Plugin, PluginLogger, PreEvaluatorResult, Provider, Relationship, Room, Route, RuntimeEventStorage, Service, ServiceClass, ServiceTypeName, State, Task, TaskWorker, UUID, World } from "./eliza-types.js";
import { InMemoryStore } from "./in-memory-store.js";
import { type ElizaCompatLogger } from "./logger-adapter.js";
import type { ElizaAdapterConfig } from "./types.js";
export type RuntimeBridgeOptions = {
    config: ElizaAdapterConfig;
    openclawLogger: PluginLogger;
};
type EventHandlerFn = (params: EventPayload) => Promise<void>;
export declare class RuntimeBridge implements IAgentRuntime {
    readonly agentId: UUID;
    readonly character: Character;
    readonly enableAutonomy = false;
    readonly initPromise: Promise<void>;
    providers: Provider[];
    actions: Action[];
    evaluators: Evaluator[];
    plugins: Plugin[];
    routes: Route[];
    services: Map<string, Service[]>;
    events: RuntimeEventStorage;
    fetch: typeof globalThis.fetch | null;
    logger: ElizaCompatLogger;
    stateCache: Map<string, State>;
    messageService: null;
    db: object;
    private readonly store;
    private readonly settings;
    private readonly taskWorkers;
    private currentRunId;
    private actionResultsStore;
    private serviceLoadPromises;
    constructor(opts: RuntimeBridgeOptions);
    getSetting(key: string): string | boolean | number | null;
    setSetting(key: string, value: string | boolean | null): void;
    getService<T extends Service>(svc: ServiceTypeName | string): T | null;
    getServicesByType<T extends Service>(svc: ServiceTypeName | string): T[];
    getAllServices(): Map<ServiceTypeName, Service[]>;
    registerService(sc: ServiceClass): Promise<void>;
    injectService(type: string, instance: Service): void;
    getServiceLoadPromise(type: ServiceTypeName): Promise<Service>;
    getRegisteredServiceTypes(): ServiceTypeName[];
    hasService(type: ServiceTypeName | string): boolean;
    registerPlugin(plugin: Plugin): Promise<void>;
    registerProvider(p: Provider): void;
    registerAction(a: Action): void;
    registerEvaluator(e: Evaluator): void;
    getAllActions(): Action[];
    getFilteredActions(): Action[];
    isActionAllowed(): {
        allowed: boolean;
        reason: string;
    };
    composeState(message: Memory, includeList?: string[] | null, _onlyInclude?: boolean, skipCache?: boolean): Promise<State>;
    registerEvent(_event: string, handler: EventHandlerFn): void;
    getEvent(event: string): EventHandlerFn[] | undefined;
    emitEvent(event: string | string[], params: EventPayload): Promise<void>;
    registerTaskWorker(tw: TaskWorker): void;
    getTaskWorker(name: string): TaskWorker | undefined;
    createRunId(): UUID;
    startRun(): UUID;
    endRun(): void;
    getCurrentRunId(): UUID;
    getActionResults(id: UUID): ActionResult[];
    storeActionResult(id: UUID, r: ActionResult): void;
    getConversationLength(): number;
    isActionPlanningEnabled(): boolean;
    getLLMMode(): "DEFAULT";
    isCheckShouldRespondEnabled(): boolean;
    initialize(): Promise<void>;
    registerDatabaseAdapter(): void;
    init(): Promise<void>;
    isReady(): Promise<boolean>;
    close(): Promise<void>;
    getConnection(): Promise<object>;
    ensureEmbeddingDimension(d: number): Promise<void>;
    getAgent(id: UUID): Promise<Agent | null>;
    getAgents(): Promise<Partial<Agent>[]>;
    createAgent(a: Partial<Agent>): Promise<boolean>;
    updateAgent(id: UUID, a: Partial<Agent>): Promise<boolean>;
    deleteAgent(id: UUID): Promise<boolean>;
    getEntitiesByIds(ids: UUID[]): Promise<Entity[] | null>;
    getEntitiesForRoom(id: UUID, inc?: boolean): Promise<Entity[]>;
    createEntities(e: Entity[]): Promise<boolean>;
    updateEntity(e: Entity): Promise<void>;
    getComponent(eid: UUID, type: string, wid?: UUID, sid?: UUID): Promise<Component | null>;
    getComponents(eid: UUID, wid?: UUID, sid?: UUID): Promise<Component[]>;
    createComponent(c: Component): Promise<boolean>;
    updateComponent(c: Component): Promise<void>;
    deleteComponent(id: UUID): Promise<void>;
    getMemories(p: Parameters<InMemoryStore["getMemories"]>[0]): Promise<Memory[]>;
    getMemoryById(id: UUID): Promise<Memory | null>;
    getMemoriesByIds(ids: UUID[], t?: string): Promise<Memory[]>;
    getMemoriesByRoomIds(p: Parameters<InMemoryStore["getMemoriesByRoomIds"]>[0]): Promise<Memory[]>;
    getCachedEmbeddings(p: Parameters<InMemoryStore["getCachedEmbeddings"]>[0]): Promise<{
        embedding: number[];
        levenshtein_score: number;
    }[]>;
    searchMemories(p: Parameters<InMemoryStore["searchMemories"]>[0]): Promise<Memory[]>;
    createMemory(m: Memory, t: string, u?: boolean): Promise<string>;
    updateMemory(m: Partial<Memory> & {
        id: UUID;
        metadata?: MemoryMetadata;
    }): Promise<boolean>;
    deleteMemory(id: UUID): Promise<void>;
    deleteManyMemories(ids: UUID[]): Promise<void>;
    deleteAllMemories(rid: UUID, t: string): Promise<void>;
    countMemories(rid: UUID, u?: boolean, t?: string): Promise<number>;
    getRoomsByIds(ids: UUID[]): Promise<Room[] | null>;
    createRooms(r: Room[]): Promise<string[]>;
    deleteRoom(id: UUID): Promise<void>;
    deleteRoomsByWorldId(id: UUID): Promise<void>;
    updateRoom(r: Room): Promise<void>;
    getRoomsForParticipant(id: UUID): Promise<string[]>;
    getRoomsForParticipants(ids: UUID[]): Promise<string[]>;
    getRoomsByWorld(id: UUID): Promise<Room[]>;
    removeParticipant(eid: UUID, rid: UUID): Promise<boolean>;
    getParticipantsForEntity(id: UUID): Promise<import("./eliza-types.js").Participant[]>;
    getParticipantsForRoom(id: UUID): Promise<string[]>;
    isRoomParticipant(rid: UUID, eid: UUID): Promise<boolean>;
    addParticipantsRoom(ids: UUID[], rid: UUID): Promise<boolean>;
    getParticipantUserState(rid: UUID, eid: UUID): Promise<"FOLLOWED" | "MUTED" | null>;
    setParticipantUserState(rid: UUID, eid: UUID, s: "FOLLOWED" | "MUTED" | null): Promise<void>;
    createWorld(w: World): Promise<string>;
    getWorld(id: UUID): Promise<World | null>;
    removeWorld(id: UUID): Promise<void>;
    getAllWorlds(): Promise<World[]>;
    updateWorld(w: World): Promise<void>;
    createRelationship(p: Parameters<InMemoryStore["createRelationship"]>[0]): Promise<boolean>;
    updateRelationship(r: Relationship): Promise<void>;
    getRelationship(p: Parameters<InMemoryStore["getRelationship"]>[0]): Promise<Relationship | null>;
    getRelationships(p: Parameters<InMemoryStore["getRelationships"]>[0]): Promise<Relationship[]>;
    getCache<T>(k: string): Promise<T | undefined>;
    setCache<T>(k: string, v: T): Promise<boolean>;
    deleteCache(k: string): Promise<boolean>;
    createTask(t: Task): Promise<string>;
    getTasks(p: Parameters<InMemoryStore["getTasks"]>[0]): Promise<Task[]>;
    getTask(id: UUID): Promise<Task | null>;
    getTasksByName(n: string): Promise<Task[]>;
    updateTask(id: UUID, t: Partial<Task>): Promise<void>;
    deleteTask(id: UUID): Promise<void>;
    log(p: {
        body: LogBody;
        entityId: UUID;
        roomId: UUID;
        type: string;
    }): Promise<void>;
    getLogs(p: Parameters<InMemoryStore["getLogs"]>[0]): Promise<Log[]>;
    deleteLog(id: UUID): Promise<void>;
    getEntityById(id: UUID): Promise<Entity | null>;
    getRoom(id: UUID): Promise<Room | null>;
    createEntity(e: Entity): Promise<boolean>;
    createRoom(r: Room): Promise<UUID>;
    addParticipant(eid: UUID, rid: UUID): Promise<boolean>;
    getRooms(wid: UUID): Promise<Room[]>;
    ensureParticipantInRoom(eid: UUID, rid: UUID): Promise<void>;
    ensureWorldExists(w: World): Promise<void>;
    ensureRoomExists(r: Room): Promise<void>;
    getAllMemories(): Promise<Memory[]>;
    clearAllAgentMemories(): Promise<void>;
    redactSecrets(text: string): string;
    useModel(): Promise<string>;
    generateText(): Promise<{
        text: string;
        finishReason: string;
    }>;
    dynamicPromptExecFromState(): Promise<Record<string, unknown> | null>;
    processActions(): Promise<void>;
    evaluate(): Promise<null>;
    sendMessageToTarget(): Promise<void>;
    registerModel(): void;
    getModel(): undefined;
    evaluatePre(): Promise<PreEvaluatorResult>;
    addEmbeddingToMemory(m: Memory): Promise<Memory>;
    queueEmbeddingGeneration(): Promise<void>;
    registerSendHandler(): void;
    ensureConnection(p: {
        entityId: UUID;
        roomId: UUID;
        worldId: UUID;
        userName?: string;
        worldName?: string;
        [k: string]: unknown;
    }): Promise<void>;
    ensureConnections(entities: Entity[], rooms: Room[], _src: string, world: World): Promise<void>;
    stop(): Promise<void>;
}
export {};
//# sourceMappingURL=runtime-bridge.d.ts.map