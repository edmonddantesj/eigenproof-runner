import { randomUUID } from "node:crypto";
import { InMemoryStore } from "./in-memory-store.js";
import { createElizaLogger } from "./logger-adapter.js";
import { NotImplementedError } from "./types.js";
export class RuntimeBridge {
    agentId = randomUUID();
    character;
    enableAutonomy = false;
    initPromise = Promise.resolve();
    providers = [];
    actions = [];
    evaluators = [];
    plugins = [];
    routes = [];
    services = new Map();
    events = {};
    fetch = globalThis.fetch?.bind(globalThis) ?? null;
    logger;
    stateCache = new Map();
    messageService = null;
    db;
    store;
    settings;
    taskWorkers = new Map();
    currentRunId = randomUUID();
    actionResultsStore = new Map();
    serviceLoadPromises = new Map();
    constructor(opts) {
        this.settings = { ...opts.config.settings };
        this.logger = createElizaLogger(opts.openclawLogger);
        this.store = new InMemoryStore();
        this.db = this.store;
        this.character = { name: opts.config.agentName, settings: { secrets: { ...opts.config.settings } } };
    }
    // -- Settings ---------------------------------------------------------------
    getSetting(key) {
        const v = this.settings[key];
        if (v !== undefined)
            return v;
        const secrets = this.character.settings?.secrets;
        if (secrets && key in secrets)
            return secrets[key];
        const env = process.env[key];
        if (env !== undefined)
            return env;
        return null;
    }
    setSetting(key, value) {
        if (value === null) {
            delete this.settings[key];
            if (this.character.settings?.secrets)
                delete this.character.settings.secrets[key];
        }
        else {
            this.settings[key] = value;
        }
    }
    // -- Services ---------------------------------------------------------------
    getService(svc) {
        const list = this.services.get(svc);
        return (list && list.length > 0 ? list[0] : null);
    }
    getServicesByType(svc) { return (this.services.get(svc) ?? []); }
    getAllServices() { return this.services; }
    async registerService(sc) {
        this.injectService(sc.serviceType, await sc.start(this));
    }
    injectService(type, instance) {
        const list = this.services.get(type) ?? [];
        list.push(instance);
        this.services.set(type, list);
        const pending = this.serviceLoadPromises.get(type);
        if (pending) {
            pending.resolve(instance);
            this.serviceLoadPromises.delete(type);
        }
    }
    getServiceLoadPromise(type) {
        const existing = this.services.get(type);
        if (existing && existing.length > 0)
            return Promise.resolve(existing[0]);
        const pending = this.serviceLoadPromises.get(type);
        if (pending)
            return pending.promise;
        let resolve;
        const promise = new Promise((r) => { resolve = r; });
        this.serviceLoadPromises.set(type, { resolve, promise });
        return promise;
    }
    getRegisteredServiceTypes() { return [...this.services.keys()]; }
    hasService(type) { const l = this.services.get(type); return l !== undefined && l.length > 0; }
    // -- Plugin registry --------------------------------------------------------
    async registerPlugin(plugin) {
        this.plugins.push(plugin);
        if (plugin.actions)
            this.actions.push(...plugin.actions);
        if (plugin.providers)
            this.providers.push(...plugin.providers);
        if (plugin.evaluators)
            this.evaluators.push(...plugin.evaluators);
        if (plugin.routes)
            this.routes.push(...plugin.routes);
    }
    registerProvider(p) { this.providers.push(p); }
    registerAction(a) { this.actions.push(a); }
    registerEvaluator(e) { this.evaluators.push(e); }
    getAllActions() { return this.actions; }
    getFilteredActions() { return this.actions; }
    isActionAllowed() { return { allowed: true, reason: "adapter-mode" }; }
    // -- State ------------------------------------------------------------------
    async composeState(message, includeList, _onlyInclude, skipCache) {
        // Return cached state if available and not skipped
        if (!skipCache && message.id) {
            const cached = this.stateCache.get(message.id);
            if (cached)
                return cached;
        }
        const values = {
            agentName: this.character.name ?? "Eliza",
            actionNames: this.actions.map((a) => a.name).join(", "),
            providers: this.providers.map((p) => p.name).join(", "),
        };
        const data = {};
        const textParts = [];
        const baseList = includeList
            ? this.providers.filter((p) => includeList.includes(p.name))
            : this.providers.filter((p) => !p.private && !p.dynamic);
        const alwaysRun = this.providers.filter((p) => p.alwaysRun && !p.private && !baseList.includes(p));
        for (const provider of [...baseList, ...alwaysRun]) {
            let result;
            try {
                result = await provider.get(this, message, { values, data, text: "" });
            }
            catch (err) {
                this.logger.warn(`Provider "${provider.name}" failed: ${err instanceof Error ? err.message : String(err)}`);
                continue;
            }
            if (!result)
                continue;
            if (result.text)
                textParts.push(result.text);
            if (result.values)
                Object.assign(values, result.values);
            if (result.data)
                Object.assign(data, result.data);
        }
        const state = { values, data, text: textParts.join("\n") };
        // Cache by message ID
        if (message.id)
            this.stateCache.set(message.id, state);
        return state;
    }
    // -- Events -----------------------------------------------------------------
    registerEvent(_event, handler) {
        const list = this.events[_event] ?? [];
        list.push(handler);
        this.events[_event] = list;
    }
    getEvent(event) {
        return this.events[event];
    }
    async emitEvent(event, params) {
        for (const name of Array.isArray(event) ? event : [event])
            for (const h of this.getEvent(name) ?? [])
                await h(params);
    }
    // -- Task workers & runs ----------------------------------------------------
    registerTaskWorker(tw) { this.taskWorkers.set(tw.name, tw); }
    getTaskWorker(name) { return this.taskWorkers.get(name); }
    createRunId() { return randomUUID(); }
    startRun() { this.currentRunId = randomUUID(); return this.currentRunId; }
    endRun() { }
    getCurrentRunId() { return this.currentRunId; }
    getActionResults(id) { return this.actionResultsStore.get(id) ?? []; }
    storeActionResult(id, r) { const l = this.actionResultsStore.get(id) ?? []; l.push(r); this.actionResultsStore.set(id, l); }
    // -- Config flags -----------------------------------------------------------
    getConversationLength() { return 0; }
    isActionPlanningEnabled() { return false; }
    getLLMMode() { return "DEFAULT"; }
    isCheckShouldRespondEnabled() { return false; }
    // -- Init -------------------------------------------------------------------
    async initialize() { await this.store.ensureEmbeddingDimension(384); }
    registerDatabaseAdapter() { }
    // -- DB delegation ----------------------------------------------------------
    async init() { }
    async isReady() { return true; }
    async close() { this.store.clear(); }
    async getConnection() { return this.store; }
    async ensureEmbeddingDimension(d) { await this.store.ensureEmbeddingDimension(d); }
    async getAgent(id) { return this.store.getAgent(id); }
    async getAgents() { return this.store.getAgents(); }
    async createAgent(a) { return this.store.createAgent(a); }
    async updateAgent(id, a) { return this.store.updateAgent(id, a); }
    async deleteAgent(id) { return this.store.deleteAgent(id); }
    async getEntitiesByIds(ids) { return this.store.getEntitiesByIds(ids); }
    async getEntitiesForRoom(id, inc) { return this.store.getEntitiesForRoom(id, inc); }
    async createEntities(e) { return this.store.createEntities(e); }
    async updateEntity(e) { return this.store.updateEntity(e); }
    async getComponent(eid, type, wid, sid) { return this.store.getComponent(eid, type, wid, sid); }
    async getComponents(eid, wid, sid) { return this.store.getComponents(eid, wid, sid); }
    async createComponent(c) { return this.store.createComponent(c); }
    async updateComponent(c) { return this.store.updateComponent(c); }
    async deleteComponent(id) { return this.store.deleteComponent(id); }
    async getMemories(p) { return this.store.getMemories(p); }
    async getMemoryById(id) { return this.store.getMemoryById(id); }
    async getMemoriesByIds(ids, t) { return this.store.getMemoriesByIds(ids, t); }
    async getMemoriesByRoomIds(p) { return this.store.getMemoriesByRoomIds(p); }
    async getCachedEmbeddings(p) { return this.store.getCachedEmbeddings(p); }
    async searchMemories(p) { return this.store.searchMemories(p); }
    async createMemory(m, t, u) { return this.store.createMemory(m, t, u); }
    async updateMemory(m) { return this.store.updateMemory(m); }
    async deleteMemory(id) { return this.store.deleteMemory(id); }
    async deleteManyMemories(ids) { return this.store.deleteManyMemories(ids); }
    async deleteAllMemories(rid, t) { return this.store.deleteAllMemories(rid, t); }
    async countMemories(rid, u, t) { return this.store.countMemories(rid, u, t); }
    async getRoomsByIds(ids) { return this.store.getRoomsByIds(ids); }
    async createRooms(r) { return this.store.createRooms(r); }
    async deleteRoom(id) { return this.store.deleteRoom(id); }
    async deleteRoomsByWorldId(id) { return this.store.deleteRoomsByWorldId(id); }
    async updateRoom(r) { return this.store.updateRoom(r); }
    async getRoomsForParticipant(id) { return this.store.getRoomsForParticipant(id); }
    async getRoomsForParticipants(ids) { return this.store.getRoomsForParticipants(ids); }
    async getRoomsByWorld(id) { return this.store.getRoomsByWorld(id); }
    async removeParticipant(eid, rid) { return this.store.removeParticipant(eid, rid); }
    async getParticipantsForEntity(id) { return this.store.getParticipantsForEntity(id); }
    async getParticipantsForRoom(id) { return this.store.getParticipantsForRoom(id); }
    async isRoomParticipant(rid, eid) { return this.store.isRoomParticipant(rid, eid); }
    async addParticipantsRoom(ids, rid) { return this.store.addParticipantsRoom(ids, rid); }
    async getParticipantUserState(rid, eid) { return this.store.getParticipantUserState(rid, eid); }
    async setParticipantUserState(rid, eid, s) { return this.store.setParticipantUserState(rid, eid, s); }
    async createWorld(w) { return this.store.createWorld(w); }
    async getWorld(id) { return this.store.getWorld(id); }
    async removeWorld(id) { return this.store.removeWorld(id); }
    async getAllWorlds() { return this.store.getAllWorlds(); }
    async updateWorld(w) { return this.store.updateWorld(w); }
    async createRelationship(p) { return this.store.createRelationship(p); }
    async updateRelationship(r) { return this.store.updateRelationship(r); }
    async getRelationship(p) { return this.store.getRelationship(p); }
    async getRelationships(p) { return this.store.getRelationships(p); }
    async getCache(k) { return this.store.getCache(k); }
    async setCache(k, v) { return this.store.setCache(k, v); }
    async deleteCache(k) { return this.store.deleteCache(k); }
    async createTask(t) { return this.store.createTask(t); }
    async getTasks(p) { return this.store.getTasks(p); }
    async getTask(id) { return this.store.getTask(id); }
    async getTasksByName(n) { return this.store.getTasksByName(n); }
    async updateTask(id, t) { return this.store.updateTask(id, t); }
    async deleteTask(id) { return this.store.deleteTask(id); }
    async log(p) { return this.store.log(p); }
    async getLogs(p) { return this.store.getLogs(p); }
    async deleteLog(id) { return this.store.deleteLog(id); }
    // -- Convenience ------------------------------------------------------------
    async getEntityById(id) { const r = await this.store.getEntitiesByIds([id]); return r && r.length > 0 ? r[0] : null; }
    async getRoom(id) { return this.store.getRoom(id); }
    async createEntity(e) { return this.store.createEntities([e]); }
    async createRoom(r) { return (await this.store.createRooms([r]))[0]; }
    async addParticipant(eid, rid) { return this.store.addParticipantsRoom([eid], rid); }
    async getRooms(wid) { return this.store.getRoomsByWorld(wid); }
    async ensureParticipantInRoom(eid, rid) {
        if (!(await this.store.isRoomParticipant(rid, eid)))
            await this.store.addParticipantsRoom([eid], rid);
    }
    async ensureWorldExists(w) {
        if (!w.id || !(await this.store.getWorld(w.id)))
            await this.store.createWorld(w);
    }
    async ensureRoomExists(r) {
        if (!r.id || !(await this.store.getRoom(r.id)))
            await this.store.createRooms([r]);
    }
    async getAllMemories() { return this.store.getMemories({ tableName: "messages" }); }
    async clearAllAgentMemories() { this.store.clear(); }
    redactSecrets(text) {
        let r = text;
        for (const v of Object.values(this.settings)) {
            if (typeof v === "string" && v.length > 4)
                r = r.replaceAll(v, "***REDACTED***");
        }
        return r;
    }
    // -- Not implemented --------------------------------------------------------
    async useModel() { throw new NotImplementedError("useModel"); }
    async generateText() { throw new NotImplementedError("generateText"); }
    async dynamicPromptExecFromState() { throw new NotImplementedError("dynamicPromptExecFromState"); }
    async processActions() { throw new NotImplementedError("processActions"); }
    async evaluate() { throw new NotImplementedError("evaluate"); }
    async sendMessageToTarget() { throw new NotImplementedError("sendMessageToTarget"); }
    registerModel() { }
    getModel() { return undefined; }
    async evaluatePre() { return { blocked: false }; }
    async addEmbeddingToMemory(m) { return m; }
    async queueEmbeddingGeneration() { }
    registerSendHandler() { }
    async ensureConnection(p) {
        await this.ensureWorldExists({ id: p.worldId, name: p.worldName ?? "default" });
        await this.ensureRoomExists({ id: p.roomId, worldId: p.worldId });
        if (!(await this.getEntityById(p.entityId)))
            await this.createEntity({ id: p.entityId, names: [p.userName ?? "unknown"] });
        await this.ensureParticipantInRoom(p.entityId, p.roomId);
    }
    async ensureConnections(entities, rooms, _src, world) {
        await this.ensureWorldExists(world);
        for (const r of rooms)
            await this.ensureRoomExists(r);
        if (entities.length > 0)
            await this.createEntities(entities);
    }
    async stop() {
        for (const [, list] of this.services)
            for (const svc of list)
                await svc.stop();
        this.store.clear();
    }
}
//# sourceMappingURL=runtime-bridge.js.map