/**
 * In-memory backing store for the RuntimeBridge's IDatabaseAdapter methods.
 *
 * Every collection is a plain Map or array. No persistence. Designed to give
 * Eliza plugins a functional database layer during adapter execution without
 * requiring an actual database connection.
 *
 * Each public method corresponds 1:1 to an IDatabaseAdapter method signature.
 */
import { randomUUID } from "node:crypto";
// ---------------------------------------------------------------------------
// Store
// ---------------------------------------------------------------------------
export class InMemoryStore {
    /** Max memories per table before oldest are evicted. */
    static MAX_MEMORIES_PER_TABLE = 10_000;
    /** Max total log entries before oldest are evicted. */
    static MAX_LOGS = 5_000;
    agents = new Map();
    entities = new Map();
    rooms = new Map();
    worlds = new Map();
    components = new Map(); // key: `${entityId}:${type}:${worldId}:${sourceEntityId}`
    componentsByEntity = new Map();
    memories = new Map(); // key: tableName
    memoriesById = new Map();
    participants = new Map(); // roomId -> entityIds
    participantState = new Map(); // `${roomId}:${entityId}`
    relationships = [];
    tasks = new Map();
    logs = [];
    cache = new Map();
    embeddingDimension = 384;
    // -------------------------------------------------------------------------
    // Agent
    // -------------------------------------------------------------------------
    async getAgent(agentId) {
        return this.agents.get(agentId) ?? null;
    }
    async getAgents() {
        return [...this.agents.values()];
    }
    async createAgent(agent) {
        const id = agent.id ?? randomUUID();
        this.agents.set(id, { ...agent, id });
        return true;
    }
    async updateAgent(agentId, agent) {
        const existing = this.agents.get(agentId);
        if (!existing)
            return false;
        this.agents.set(agentId, { ...existing, ...agent, id: agentId });
        return true;
    }
    async deleteAgent(agentId) {
        return this.agents.delete(agentId);
    }
    // -------------------------------------------------------------------------
    // Entity
    // -------------------------------------------------------------------------
    async getEntitiesByIds(entityIds) {
        const result = [];
        for (const id of entityIds) {
            const entity = this.entities.get(id);
            if (entity)
                result.push(entity);
        }
        return result.length > 0 ? result : null;
    }
    async getEntitiesForRoom(roomId, _includeComponents) {
        const participantIds = this.participants.get(roomId);
        if (!participantIds)
            return [];
        const result = [];
        for (const id of participantIds) {
            const entity = this.entities.get(id);
            if (entity)
                result.push(entity);
        }
        return result;
    }
    async createEntities(ents) {
        for (const entity of ents) {
            const id = entity.id ?? randomUUID();
            this.entities.set(id, { ...entity, id });
        }
        return true;
    }
    async updateEntity(entity) {
        if (entity.id) {
            this.entities.set(entity.id, entity);
        }
    }
    // -------------------------------------------------------------------------
    // Component
    // -------------------------------------------------------------------------
    componentKey(entityId, type, worldId, sourceEntityId) {
        return `${entityId}:${type}:${worldId ?? ""}:${sourceEntityId ?? ""}`;
    }
    async getComponent(entityId, type, worldId, sourceEntityId) {
        return (this.components.get(this.componentKey(entityId, type, worldId, sourceEntityId)) ?? null);
    }
    async getComponents(entityId, _worldId, _sourceEntityId) {
        return this.componentsByEntity.get(entityId) ?? [];
    }
    async createComponent(component) {
        const id = component.id ?? randomUUID();
        const full = { ...component, id };
        const key = this.componentKey(component.entityId, component.type, component.worldId, component.sourceEntityId);
        this.components.set(key, full);
        const existing = this.componentsByEntity.get(component.entityId) ?? [];
        existing.push(full);
        this.componentsByEntity.set(component.entityId, existing);
        return true;
    }
    async updateComponent(component) {
        const key = this.componentKey(component.entityId, component.type, component.worldId, component.sourceEntityId);
        this.components.set(key, component);
        const existing = this.componentsByEntity.get(component.entityId) ?? [];
        const idx = existing.findIndex((c) => c.id === component.id);
        if (idx >= 0)
            existing[idx] = component;
        else
            existing.push(component);
        this.componentsByEntity.set(component.entityId, existing);
    }
    async deleteComponent(componentId) {
        for (const [key, comp] of this.components.entries()) {
            if (comp.id === componentId) {
                this.components.delete(key);
                const entityComps = this.componentsByEntity.get(comp.entityId) ?? [];
                const idx = entityComps.findIndex((c) => c.id === componentId);
                if (idx >= 0)
                    entityComps.splice(idx, 1);
                break;
            }
        }
    }
    // -------------------------------------------------------------------------
    // Memory
    // -------------------------------------------------------------------------
    async getMemories(params) {
        const table = this.memories.get(params.tableName) ?? [];
        let result = table.filter((m) => {
            if (params.entityId && m.entityId !== params.entityId)
                return false;
            if (params.agentId && m.agentId !== params.agentId)
                return false;
            if (params.roomId && m.roomId !== params.roomId)
                return false;
            if (params.worldId && m.worldId !== params.worldId)
                return false;
            if (params.unique && !m.unique)
                return false;
            if (params.start && m.createdAt && m.createdAt < params.start)
                return false;
            if (params.end && m.createdAt && m.createdAt > params.end)
                return false;
            return true;
        });
        // Sort by createdAt descending (newest first)
        result.sort((a, b) => (b.createdAt ?? 0) - (a.createdAt ?? 0));
        if (params.offset)
            result = result.slice(params.offset);
        if (params.count)
            result = result.slice(0, params.count);
        return result;
    }
    async getMemoryById(id) {
        return this.memoriesById.get(id) ?? null;
    }
    async getMemoriesByIds(ids, _tableName) {
        const result = [];
        for (const id of ids) {
            const mem = this.memoriesById.get(id);
            if (mem)
                result.push(mem);
        }
        return result;
    }
    async getMemoriesByRoomIds(params) {
        const table = this.memories.get(params.tableName) ?? [];
        const roomIdSet = new Set(params.roomIds);
        let result = table.filter((m) => roomIdSet.has(m.roomId));
        result.sort((a, b) => (b.createdAt ?? 0) - (a.createdAt ?? 0));
        if (params.limit)
            result = result.slice(0, params.limit);
        return result;
    }
    async getCachedEmbeddings(_params) {
        // No cached embeddings in memory store
        return [];
    }
    async searchMemories(params) {
        const table = this.memories.get(params.tableName) ?? [];
        const threshold = params.match_threshold ?? 0.5;
        const limit = params.count ?? 10;
        // Filter memories that have embeddings
        const candidates = table.filter((m) => {
            if (!m.embedding || m.embedding.length === 0)
                return false;
            if (params.roomId && m.roomId !== params.roomId)
                return false;
            if (params.worldId && m.worldId !== params.worldId)
                return false;
            if (params.entityId && m.entityId !== params.entityId)
                return false;
            if (params.unique && !m.unique)
                return false;
            return true;
        });
        // Compute cosine similarity
        const scored = candidates
            .map((m) => ({
            memory: m,
            similarity: cosineSimilarity(params.embedding, m.embedding),
        }))
            .filter((s) => s.similarity >= threshold)
            .sort((a, b) => b.similarity - a.similarity)
            .slice(0, limit);
        return scored.map((s) => ({ ...s.memory, similarity: s.similarity }));
    }
    async createMemory(memory, tableName, _unique) {
        const id = memory.id ?? randomUUID();
        const full = {
            ...memory,
            id,
            createdAt: memory.createdAt ?? Date.now(),
        };
        const table = this.memories.get(tableName) ?? [];
        table.push(full);
        // Evict oldest entries when table exceeds cap
        while (table.length > InMemoryStore.MAX_MEMORIES_PER_TABLE) {
            const evicted = table.shift();
            if (evicted?.id)
                this.memoriesById.delete(evicted.id);
        }
        this.memories.set(tableName, table);
        this.memoriesById.set(id, full);
        return id;
    }
    async updateMemory(memory) {
        const existing = this.memoriesById.get(memory.id);
        if (!existing)
            return false;
        const updated = { ...existing, ...memory };
        this.memoriesById.set(memory.id, updated);
        // Update in table arrays
        for (const [, table] of this.memories) {
            const idx = table.findIndex((m) => m.id === memory.id);
            if (idx >= 0) {
                table[idx] = updated;
                break;
            }
        }
        return true;
    }
    async deleteMemory(memoryId) {
        this.memoriesById.delete(memoryId);
        for (const [, table] of this.memories) {
            const idx = table.findIndex((m) => m.id === memoryId);
            if (idx >= 0) {
                table.splice(idx, 1);
                break;
            }
        }
    }
    async deleteManyMemories(memoryIds) {
        for (const id of memoryIds) {
            await this.deleteMemory(id);
        }
    }
    async deleteAllMemories(roomId, tableName) {
        const table = this.memories.get(tableName);
        if (!table)
            return;
        const remaining = table.filter((m) => m.roomId !== roomId);
        const removed = table.filter((m) => m.roomId === roomId);
        this.memories.set(tableName, remaining);
        for (const m of removed) {
            if (m.id)
                this.memoriesById.delete(m.id);
        }
    }
    async countMemories(roomId, unique, tableName) {
        if (tableName) {
            const table = this.memories.get(tableName) ?? [];
            return table.filter((m) => {
                if (m.roomId !== roomId)
                    return false;
                if (unique && !m.unique)
                    return false;
                return true;
            }).length;
        }
        let count = 0;
        for (const [, table] of this.memories) {
            count += table.filter((m) => {
                if (m.roomId !== roomId)
                    return false;
                if (unique && !m.unique)
                    return false;
                return true;
            }).length;
        }
        return count;
    }
    // -------------------------------------------------------------------------
    // Room
    // -------------------------------------------------------------------------
    async getRoom(roomId) {
        return this.rooms.get(roomId) ?? null;
    }
    async getRoomsByIds(roomIds) {
        const result = [];
        for (const id of roomIds) {
            const room = this.rooms.get(id);
            if (room)
                result.push(room);
        }
        return result.length > 0 ? result : null;
    }
    async createRooms(roomsToCreate) {
        const ids = [];
        for (const room of roomsToCreate) {
            const id = room.id ?? randomUUID();
            this.rooms.set(id, { ...room, id });
            ids.push(id);
        }
        return ids;
    }
    async deleteRoom(roomId) {
        this.rooms.delete(roomId);
        this.participants.delete(roomId);
    }
    async deleteRoomsByWorldId(worldId) {
        for (const [id, room] of this.rooms) {
            if (room.worldId === worldId) {
                this.rooms.delete(id);
                this.participants.delete(id);
            }
        }
    }
    async updateRoom(room) {
        if (room.id)
            this.rooms.set(room.id, room);
    }
    async getRoomsForParticipant(entityId) {
        const result = [];
        for (const [roomId, parts] of this.participants) {
            if (parts.has(entityId))
                result.push(roomId);
        }
        return result;
    }
    async getRoomsForParticipants(userIds) {
        const userIdSet = new Set(userIds);
        const result = [];
        for (const [roomId, parts] of this.participants) {
            for (const uid of userIdSet) {
                if (parts.has(uid)) {
                    result.push(roomId);
                    break;
                }
            }
        }
        return result;
    }
    async getRoomsByWorld(worldId) {
        const result = [];
        for (const room of this.rooms.values()) {
            if (room.worldId === worldId)
                result.push(room);
        }
        return result;
    }
    // -------------------------------------------------------------------------
    // Participant
    // -------------------------------------------------------------------------
    async addParticipantsRoom(entityIds, roomId) {
        const parts = this.participants.get(roomId) ?? new Set();
        for (const id of entityIds)
            parts.add(id);
        this.participants.set(roomId, parts);
        return true;
    }
    async removeParticipant(entityId, roomId) {
        const parts = this.participants.get(roomId);
        if (!parts)
            return false;
        return parts.delete(entityId);
    }
    async getParticipantsForEntity(entityId) {
        const result = [];
        for (const [roomId, parts] of this.participants) {
            if (parts.has(entityId)) {
                result.push({ id: randomUUID(), entityId, roomId });
            }
        }
        return result;
    }
    async getParticipantsForRoom(roomId) {
        const parts = this.participants.get(roomId);
        return parts ? [...parts] : [];
    }
    async isRoomParticipant(roomId, entityId) {
        return this.participants.get(roomId)?.has(entityId) ?? false;
    }
    async getParticipantUserState(roomId, entityId) {
        return this.participantState.get(`${roomId}:${entityId}`) ?? null;
    }
    async setParticipantUserState(roomId, entityId, state) {
        this.participantState.set(`${roomId}:${entityId}`, state);
    }
    // -------------------------------------------------------------------------
    // World
    // -------------------------------------------------------------------------
    async createWorld(world) {
        const id = world.id ?? randomUUID();
        this.worlds.set(id, { ...world, id });
        return id;
    }
    async getWorld(id) {
        return this.worlds.get(id) ?? null;
    }
    async removeWorld(id) {
        this.worlds.delete(id);
    }
    async getAllWorlds() {
        return [...this.worlds.values()];
    }
    async updateWorld(world) {
        if (world.id)
            this.worlds.set(world.id, world);
    }
    // -------------------------------------------------------------------------
    // Relationship
    // -------------------------------------------------------------------------
    async createRelationship(params) {
        this.relationships.push({
            id: randomUUID(),
            sourceEntityId: params.sourceEntityId,
            targetEntityId: params.targetEntityId,
            tags: params.tags ?? [],
            metadata: params.metadata ?? {},
        });
        return true;
    }
    async updateRelationship(relationship) {
        const idx = this.relationships.findIndex((r) => r.id === relationship.id);
        if (idx >= 0)
            this.relationships[idx] = relationship;
    }
    async getRelationship(params) {
        return (this.relationships.find((r) => r.sourceEntityId === params.sourceEntityId &&
            r.targetEntityId === params.targetEntityId) ?? null);
    }
    async getRelationships(params) {
        return this.relationships.filter((r) => {
            if (r.sourceEntityId !== params.entityId &&
                r.targetEntityId !== params.entityId)
                return false;
            if (params.tags && params.tags.length > 0) {
                const rTags = new Set(r.tags ?? []);
                return params.tags.some((t) => rTags.has(t));
            }
            return true;
        });
    }
    // -------------------------------------------------------------------------
    // Task
    // -------------------------------------------------------------------------
    async createTask(task) {
        const id = task.id ?? randomUUID();
        this.tasks.set(id, { ...task, id });
        return id;
    }
    async getTasks(params) {
        return [...this.tasks.values()].filter((t) => {
            if (params.roomId && t.roomId !== params.roomId)
                return false;
            if (params.entityId && t.entityId !== params.entityId)
                return false;
            if (params.tags && params.tags.length > 0) {
                const tTags = new Set(t.tags ?? []);
                return params.tags.some((tag) => tTags.has(tag));
            }
            return true;
        });
    }
    async getTask(id) {
        return this.tasks.get(id) ?? null;
    }
    async getTasksByName(name) {
        return [...this.tasks.values()].filter((t) => t.name === name);
    }
    async updateTask(id, task) {
        const existing = this.tasks.get(id);
        if (existing) {
            this.tasks.set(id, { ...existing, ...task, id });
        }
    }
    async deleteTask(id) {
        this.tasks.delete(id);
    }
    // -------------------------------------------------------------------------
    // Log
    // -------------------------------------------------------------------------
    async log(params) {
        this.logs.push({
            id: randomUUID(),
            body: params.body,
            entityId: params.entityId,
            roomId: params.roomId,
            type: params.type,
            createdAt: Date.now(),
        });
        // Evict oldest logs when cap exceeded
        while (this.logs.length > InMemoryStore.MAX_LOGS) {
            this.logs.shift();
        }
    }
    async getLogs(params) {
        let result = this.logs.filter((l) => {
            if (params.entityId && l.entityId !== params.entityId)
                return false;
            if (params.roomId && l.roomId !== params.roomId)
                return false;
            if (params.type && l.type !== params.type)
                return false;
            return true;
        });
        if (params.offset)
            result = result.slice(params.offset);
        if (params.count)
            result = result.slice(0, params.count);
        return result;
    }
    async deleteLog(logId) {
        const idx = this.logs.findIndex((l) => l.id === logId);
        if (idx >= 0)
            this.logs.splice(idx, 1);
    }
    // -------------------------------------------------------------------------
    // Cache
    // -------------------------------------------------------------------------
    async getCache(key) {
        return this.cache.get(key);
    }
    async setCache(key, value) {
        this.cache.set(key, value);
        return true;
    }
    async deleteCache(key) {
        return this.cache.delete(key);
    }
    // -------------------------------------------------------------------------
    // Embedding dimension
    // -------------------------------------------------------------------------
    async ensureEmbeddingDimension(dimension) {
        this.embeddingDimension = dimension;
    }
    getEmbeddingDimension() {
        return this.embeddingDimension;
    }
    // -------------------------------------------------------------------------
    // Teardown
    // -------------------------------------------------------------------------
    clear() {
        this.agents.clear();
        this.entities.clear();
        this.rooms.clear();
        this.worlds.clear();
        this.components.clear();
        this.componentsByEntity.clear();
        this.memories.clear();
        this.memoriesById.clear();
        this.participants.clear();
        this.participantState.clear();
        this.relationships.length = 0;
        this.tasks.clear();
        this.logs.length = 0;
        this.cache.clear();
    }
}
// ---------------------------------------------------------------------------
// Cosine similarity (for searchMemories)
// ---------------------------------------------------------------------------
function cosineSimilarity(a, b) {
    if (a.length !== b.length || a.length === 0)
        return 0;
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < a.length; i++) {
        dotProduct += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
    }
    const denominator = Math.sqrt(normA) * Math.sqrt(normB);
    if (denominator === 0)
        return 0;
    return dotProduct / denominator;
}
//# sourceMappingURL=in-memory-store.js.map