"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUTXOs = void 0;
const base_js_1 = require("../../errors/base.js");
const request_js_1 = require("../../errors/request.js");
const rpc_js_1 = require("../../errors/rpc.js");
const utxo_js_1 = require("../../errors/utxo.js");
const url_js_1 = require("../../utils/url.js");
const getBalance_js_1 = require("./getBalance.js");
const blockChairUTXOTransformer = (scriptHex) => (data) => ({
    blockHeight: data.block_id,
    scriptHex,
    txId: data.transaction_hash,
    value: data.value,
    vout: data.index,
});
const MAX_API_LIMIT = '100,100';
const getUTXOs = async (client, { baseUrl, apiKey }, { address, minValue }) => {
    async function* fetchUTXOs() {
        let offset = 0;
        let hasMore = true;
        while (hasMore) {
            const apiUrl = (0, url_js_1.urlWithParams)(`${baseUrl}/dashboards/addresses/${address}`, {
                key: apiKey,
                offset: `0,${offset}`,
                limit: MAX_API_LIMIT,
            });
            const response = (await client.request({
                url: apiUrl,
                fetchOptions: { method: 'GET' },
            }));
            if (response.context?.code !== 200 && response.context?.code !== 404) {
                throw new request_js_1.RpcRequestError({
                    url: apiUrl,
                    body: {
                        method: 'fetchUTXOs',
                        params: {
                            address,
                            minValue,
                        },
                    },
                    error: {
                        code: response.context.code === 429
                            ? rpc_js_1.RpcErrorCode.ACCESS_DENIED
                            : rpc_js_1.RpcErrorCode.MISC_ERROR,
                        message: response.context.error || 'Error fetching utxos',
                    },
                });
            }
            if (!response.data || response.data.utxo.length === 0) {
                hasMore = false;
                continue;
            }
            const { limit } = response.context;
            const totalRows = response.data.addresses[address].unspent_output_count;
            if (limit && totalRows) {
                const [, utxoLimit] = String(limit)
                    .split(',')
                    .map((val) => Number(val));
                hasMore = offset + utxoLimit < totalRows;
                offset += utxoLimit;
            }
            else {
                hasMore = false;
                offset += 0;
            }
            yield response.data;
        }
    }
    if (minValue) {
        const { error, result: balance } = await (0, getBalance_js_1.getBalance)(client, { baseUrl, apiKey }, { address });
        if (error) {
            throw new base_js_1.BaseError('Error fetching balance', {
                cause: error,
            });
        }
        if (balance === undefined) {
            throw new base_js_1.BaseError('Balance is undefined', {
                cause: new Error('Unable to determine balance'),
            });
        }
        if (minValue > Number(balance)) {
            throw new utxo_js_1.InsufficientUTXOBalanceError({
                minValue,
                address,
                balance: Number(balance),
            });
        }
    }
    const utxos = [];
    let valueCount = 0;
    for await (const batch of fetchUTXOs()) {
        const addressScriptHex = batch.addresses[address].script_hex;
        const utxoBatch = batch.utxo.map(blockChairUTXOTransformer(addressScriptHex));
        utxos.push(...utxoBatch);
        if (minValue) {
            valueCount += utxoBatch.reduce((sum, utxo) => sum + utxo.value, 0);
            if (valueCount >= minValue) {
                break;
            }
        }
    }
    return { result: utxos };
};
exports.getUTXOs = getUTXOs;
//# sourceMappingURL=getUTXOs.js.map