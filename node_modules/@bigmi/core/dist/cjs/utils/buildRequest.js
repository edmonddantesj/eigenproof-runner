"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildRequest = buildRequest;
exports.shouldRetry = shouldRetry;
const base_js_1 = require("../errors/base.js");
const request_js_1 = require("../errors/request.js");
const rpc_js_1 = require("../errors/rpc.js");
const converter_js_1 = require("./converter.js");
const stringify_js_1 = require("./stringify.js");
const withDedupe_js_1 = require("./withDedupe.js");
const withRetry_js_1 = require("./withRetry.js");
function buildRequest(request, options = {}) {
    return async (args, overrideOptions = {}) => {
        const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid, } = {
            ...options,
            ...overrideOptions,
        };
        const { method } = args;
        if (methods?.exclude?.includes(method)) {
            throw new rpc_js_1.MethodNotSupportedRpcError(method);
        }
        if (methods?.include && !methods.include.includes(method)) {
            throw new rpc_js_1.MethodNotSupportedRpcError(method);
        }
        const requestId = dedupe
            ? (0, converter_js_1.stringToHex)(`${uid}.${(0, stringify_js_1.stringify)(args)}`)
            : undefined;
        return (0, withDedupe_js_1.withDedupe)(() => (0, withRetry_js_1.withRetry)(async () => {
            try {
                return await request(args);
            }
            catch (err_) {
                const err = err_;
                switch (err.code) {
                    case rpc_js_1.RpcErrorCode.METHOD_NOT_SUPPORTED:
                        throw new rpc_js_1.MethodNotSupportedRpcError(method);
                    case rpc_js_1.RpcErrorCode.USER_REJECTION:
                        throw new rpc_js_1.UserRejectedRequestError(err.message);
                    case 5000:
                        throw new rpc_js_1.UserRejectedRequestError(err.message);
                    default:
                        if (err_ instanceof base_js_1.BaseError) {
                            throw err_;
                        }
                        throw new base_js_1.BaseError('Unknown Error', { cause: err_ });
                }
            }
        }, {
            delay: ({ count, error }) => {
                if (error && error instanceof request_js_1.HttpRequestError) {
                    const retryAfter = error?.headers?.get('Retry-After');
                    if (retryAfter?.match(/\d/)) {
                        return Number.parseInt(retryAfter, 10) * 1000;
                    }
                }
                return ~~(1 << count) * retryDelay;
            },
            retryCount,
            shouldRetry: ({ error }) => shouldRetry(error),
        }), { enabled: dedupe, id: requestId });
    };
}
function shouldRetry(error) {
    if ('code' in error && typeof error.code === 'number') {
        if (error.code === -1) {
            return true;
        }
        if (error.code === rpc_js_1.RpcErrorCode.INTERNAL_ERROR) {
            return true;
        }
        return false;
    }
    if (error instanceof request_js_1.HttpRequestError && error.status) {
        if (error.status === 403) {
            return true;
        }
        if (error.status === 408) {
            return true;
        }
        if (error.status === 413) {
            return true;
        }
        if (error.status === 429) {
            return true;
        }
        if (error.status === 500) {
            return true;
        }
        if (error.status === 502) {
            return true;
        }
        if (error.status === 503) {
            return true;
        }
        if (error.status === 504) {
            return true;
        }
        return false;
    }
    return true;
}
//# sourceMappingURL=buildRequest.js.map