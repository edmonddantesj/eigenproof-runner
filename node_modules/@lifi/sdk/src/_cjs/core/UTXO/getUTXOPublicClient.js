"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUTXOPublicClient = void 0;
const core_1 = require("@bigmi/core");
const config_js_1 = require("../../config.js");
const rpc_js_1 = require("../rpc.js");
const utils_js_1 = require("./utils.js");
const publicClients = {};
const getUTXOPublicClient = async (chainId) => {
    if (!publicClients[chainId]) {
        const urls = await (0, rpc_js_1.getRpcUrls)(chainId);
        const fallbackTransports = urls.map((url) => (0, core_1.http)(url, {
            fetchOptions: {
                method: 'POST',
            },
        }));
        const _chain = await config_js_1.config.getChainById(chainId);
        const chain = {
            ..._chain,
            ..._chain.metamask,
            id: (0, utils_js_1.toBigmiChainId)(_chain.id),
            name: _chain.metamask.chainName,
            rpcUrls: {
                default: { http: _chain.metamask.rpcUrls },
                public: { http: _chain.metamask.rpcUrls },
            },
        };
        const client = (0, core_1.createClient)({
            chain,
            rpcSchema: (0, core_1.rpcSchema)(),
            transport: (0, core_1.fallback)([
                (0, core_1.blockchair)(),
                (0, core_1.blockcypher)(),
                (0, core_1.mempool)(),
                ...fallbackTransports,
            ]),
            pollingInterval: 10_000,
        })
            .extend(core_1.publicActions)
            .extend(core_1.walletActions);
        publicClients[chainId] = client;
    }
    if (!publicClients[chainId]) {
        throw new Error(`Unable to configure provider for chain ${chainId}`);
    }
    return publicClients[chainId];
};
exports.getUTXOPublicClient = getUTXOPublicClient;
//# sourceMappingURL=getUTXOPublicClient.js.map