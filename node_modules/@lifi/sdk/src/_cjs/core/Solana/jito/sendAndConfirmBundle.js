"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendAndConfirmBundle = sendAndConfirmBundle;
const sleep_js_1 = require("../../../utils/sleep.js");
const connection_js_1 = require("../connection.js");
async function sendAndConfirmBundle(signedTransactions) {
    const jitoConnections = await (0, connection_js_1.getJitoConnections)();
    if (jitoConnections.length === 0) {
        throw new Error('No Jito-enabled RPC connection available for bundle submission');
    }
    const abortController = new AbortController();
    const confirmPromises = jitoConnections.map(async (jitoConnection) => {
        try {
            let bundleId;
            try {
                bundleId = await jitoConnection.sendBundle(signedTransactions);
            }
            catch (_) {
                return null;
            }
            const [blockhashResult, initialBlockHeight] = await Promise.all([
                jitoConnection.getLatestBlockhash('confirmed'),
                jitoConnection.getBlockHeight('confirmed'),
            ]);
            let currentBlockHeight = initialBlockHeight;
            while (currentBlockHeight < blockhashResult.lastValidBlockHeight &&
                !abortController.signal.aborted) {
                const statusResponse = await jitoConnection.getBundleStatuses([
                    bundleId,
                ]);
                const bundleStatus = statusResponse.value[0];
                if (bundleStatus &&
                    (bundleStatus.confirmation_status === 'confirmed' ||
                        bundleStatus.confirmation_status === 'finalized')) {
                    const txSignatures = bundleStatus.transactions;
                    const sigResponse = await jitoConnection.getSignatureStatuses(txSignatures);
                    if (!sigResponse?.value || !Array.isArray(sigResponse.value)) {
                        continue;
                    }
                    abortController.abort();
                    return {
                        bundleId,
                        txSignatures,
                        signatureResults: sigResponse.value,
                    };
                }
                await (0, sleep_js_1.sleep)(400);
                if (!abortController.signal.aborted) {
                    currentBlockHeight = await jitoConnection.getBlockHeight('confirmed');
                }
            }
            return null;
        }
        catch (error) {
            if (abortController.signal.aborted) {
                return null;
            }
            throw error;
        }
    });
    const result = await Promise.any(confirmPromises).catch(() => null);
    if (!abortController.signal.aborted) {
        abortController.abort();
    }
    if (!result) {
        throw new Error('Failed to send and confirm bundle');
    }
    return result;
}
//# sourceMappingURL=sendAndConfirmBundle.js.map