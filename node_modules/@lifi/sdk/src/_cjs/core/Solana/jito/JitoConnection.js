"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JitoConnection = void 0;
const web3_js_1 = require("@solana/web3.js");
const uint8ArrayToBase64_js_1 = require("../../../utils/uint8ArrayToBase64.js");
const constants_js_1 = require("./constants.js");
async function rpcRequest(endpoint, method, params) {
    const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method,
            params,
        }),
    });
    if (!response.ok) {
        throw new Error(`Jito RPC Error: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    if (data.error) {
        throw new Error(`Jito RPC Error: ${data.error.message}`);
    }
    return data.result;
}
class JitoConnection extends web3_js_1.Connection {
    tipAccountsCache = null;
    static async isJitoRpc(rpcUrl) {
        try {
            await rpcRequest(rpcUrl, 'getTipAccounts', []);
            return true;
        }
        catch {
            return false;
        }
    }
    async rpcRequest(method, params) {
        try {
            return await rpcRequest(this.rpcEndpoint, method, params);
        }
        catch (error) {
            console.error(`Jito RPC request failed: ${method}`, {
                endpoint: this.rpcEndpoint,
                params,
                error,
            });
            throw error;
        }
    }
    serializeTransaction(transaction) {
        return (0, uint8ArrayToBase64_js_1.uint8ArrayToBase64)(transaction.serialize());
    }
    async getTipAccounts() {
        if (this.tipAccountsCache) {
            return this.tipAccountsCache;
        }
        try {
            const accounts = await this.rpcRequest('getTipAccounts', []);
            if (!accounts.length) {
                throw new Error('RPC has no tip accounts');
            }
            this.tipAccountsCache = accounts;
            return accounts;
        }
        catch (error) {
            const fallbackAccounts = constants_js_1.JITO_TIP_ACCOUNTS;
            console.warn(`Failed to fetch tip accounts from RPC, using  fallback`, error);
            return fallbackAccounts;
        }
    }
    async getRandomTipAccount() {
        const accounts = await this.getTipAccounts();
        return accounts[Math.floor(Math.random() * accounts.length)];
    }
    async refreshTipAccounts() {
        this.tipAccountsCache = null;
        return this.getTipAccounts();
    }
    async simulateBundle(bundle) {
        const encodedTransactions = bundle.map((tx) => this.serializeTransaction(tx));
        return this.rpcRequest('simulateBundle', [
            { encodedTransactions },
        ]);
    }
    async sendBundle(bundle) {
        const encodedTransactions = bundle.map((tx) => this.serializeTransaction(tx));
        return this.rpcRequest('sendBundle', [encodedTransactions]);
    }
    async getBundleStatuses(bundleIds) {
        return this.rpcRequest('getBundleStatuses', [bundleIds]);
    }
}
exports.JitoConnection = JitoConnection;
//# sourceMappingURL=JitoConnection.js.map