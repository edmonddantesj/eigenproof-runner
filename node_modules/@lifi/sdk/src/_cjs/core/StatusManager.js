"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatusManager = void 0;
const executionState_js_1 = require("./executionState.js");
const processMessages_js_1 = require("./processMessages.js");
class StatusManager {
    routeId;
    shouldUpdate = true;
    constructor(routeId) {
        this.routeId = routeId;
    }
    initExecutionObject = (step) => {
        if (!step.execution) {
            step.execution = {
                status: 'PENDING',
                process: [],
                startedAt: Date.now(),
            };
            this.updateStepInRoute(step);
        }
        if (step.execution.status === 'FAILED') {
            step.execution.startedAt = Date.now();
            step.execution.status = 'PENDING';
            this.updateStepInRoute(step);
        }
        return step.execution;
    };
    updateExecution(step, status, execution) {
        if (!step.execution) {
            throw Error("Can't update empty execution.");
        }
        step.execution.status = status;
        if (status === 'DONE') {
            step.execution.doneAt = Date.now();
        }
        if (execution) {
            step.execution = {
                ...step.execution,
                ...execution,
            };
        }
        this.updateStepInRoute(step);
        return step;
    }
    findProcess(step, type, status) {
        if (!step.execution?.process) {
            throw new Error("Execution hasn't been initialized.");
        }
        const process = step.execution.process.find((p) => p.type === type);
        if (process && status && process.status !== status) {
            process.status = status;
            this.updateStepInRoute(step);
        }
        return process;
    }
    findOrCreateProcess = ({ step, type, chainId, status, startedAt, }) => {
        const process = this.findProcess(step, type, status);
        if (process) {
            return process;
        }
        const newProcess = {
            type: type,
            startedAt: startedAt ?? Date.now(),
            message: (0, processMessages_js_1.getProcessMessage)(type, status ?? 'STARTED'),
            status: status ?? 'STARTED',
            chainId: chainId,
        };
        step.execution.process.push(newProcess);
        this.updateStepInRoute(step);
        return newProcess;
    };
    updateProcess = (step, type, status, params) => {
        if (!step.execution) {
            throw new Error("Can't update an empty step execution.");
        }
        const currentProcess = this.findProcess(step, type);
        if (!currentProcess) {
            throw new Error("Can't find a process for the given type.");
        }
        switch (status) {
            case 'CANCELLED':
                currentProcess.doneAt = Date.now();
                break;
            case 'FAILED':
                currentProcess.doneAt = Date.now();
                step.execution.status = 'FAILED';
                break;
            case 'DONE':
                currentProcess.doneAt = Date.now();
                break;
            case 'PENDING':
                step.execution.status = 'PENDING';
                currentProcess.pendingAt = Date.now();
                break;
            case 'RESET_REQUIRED':
            case 'MESSAGE_REQUIRED':
            case 'ACTION_REQUIRED':
                step.execution.status = 'ACTION_REQUIRED';
                currentProcess.actionRequiredAt = Date.now();
                break;
            default:
                break;
        }
        currentProcess.status = status;
        currentProcess.message = (0, processMessages_js_1.getProcessMessage)(type, status);
        if (params) {
            for (const [key, value] of Object.entries(params)) {
                currentProcess[key] = value;
            }
        }
        step.execution.process = [
            ...step.execution.process.filter((process) => process.status === 'DONE'),
            ...step.execution.process.filter((process) => process.status !== 'DONE'),
        ];
        this.updateStepInRoute(step);
        return currentProcess;
    };
    removeProcess = (step, type) => {
        if (!step.execution) {
            throw new Error("Execution hasn't been initialized.");
        }
        const index = step.execution.process.findIndex((p) => p.type === type);
        step.execution.process.splice(index, 1);
        this.updateStepInRoute(step);
    };
    updateStepInRoute = (step) => {
        if (!this.shouldUpdate) {
            return step;
        }
        const data = executionState_js_1.executionState.get(this.routeId);
        if (!data) {
            throw new Error('Execution data not found.');
        }
        const stepIndex = data.route.steps.findIndex((routeStep) => routeStep.id === step.id);
        if (stepIndex === -1) {
            throw new Error("Couldn't find a step to update.");
        }
        data.route.steps[stepIndex] = { ...data.route.steps[stepIndex], ...step };
        data.executionOptions?.updateRouteHook?.(data.route);
        return data.route.steps[stepIndex];
    };
    allowUpdates(value) {
        this.shouldUpdate = value;
    }
}
exports.StatusManager = StatusManager;
//# sourceMappingURL=StatusManager.js.map