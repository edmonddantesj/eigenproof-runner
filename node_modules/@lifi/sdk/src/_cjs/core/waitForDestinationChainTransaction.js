"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForDestinationChainTransaction = waitForDestinationChainTransaction;
const constants_js_1 = require("../errors/constants.js");
const getTransactionMessage_js_1 = require("../utils/getTransactionMessage.js");
const waitForTransactionStatus_js_1 = require("./waitForTransactionStatus.js");
async function waitForDestinationChainTransaction(step, process, fromChain, toChain, statusManager, pollingInterval) {
    const transactionHash = process.txHash || process.taskId;
    let processType = process.type;
    try {
        if (!transactionHash) {
            throw new Error('Transaction hash is undefined.');
        }
        const isBridgeExecution = fromChain.id !== toChain.id;
        if (isBridgeExecution) {
            const receivingChainProcess = statusManager.findOrCreateProcess({
                step,
                type: 'RECEIVING_CHAIN',
                status: 'PENDING',
                chainId: toChain.id,
                startedAt: process.doneAt,
            });
            processType = receivingChainProcess.type;
        }
        const statusResponse = (await (0, waitForTransactionStatus_js_1.waitForTransactionStatus)(statusManager, transactionHash, step, processType, pollingInterval));
        const statusReceiving = statusResponse.receiving;
        statusManager.updateProcess(step, processType, 'DONE', {
            chainId: statusReceiving?.chainId || toChain.id,
            substatus: statusResponse.substatus,
            substatusMessage: statusResponse.substatusMessage,
            txHash: statusReceiving?.txHash,
            txLink: statusReceiving?.txLink ||
                `${toChain.metamask.blockExplorerUrls[0]}tx/${statusReceiving?.txHash}`,
        });
        statusManager.updateExecution(step, 'DONE', {
            ...(statusResponse.sending.amount && {
                fromAmount: statusResponse.sending.amount,
            }),
            ...(statusReceiving?.amount && { toAmount: statusReceiving.amount }),
            ...(statusReceiving?.token && { toToken: statusReceiving.token }),
            internalTxLink: statusResponse?.lifiExplorerLink,
            externalTxLink: statusResponse?.bridgeExplorerLink,
            gasCosts: [
                {
                    amount: statusResponse.sending.gasAmount,
                    amountUSD: statusResponse.sending.gasAmountUSD,
                    token: statusResponse.sending.gasToken,
                    estimate: statusResponse.sending.gasUsed,
                    limit: statusResponse.sending.gasUsed,
                    price: statusResponse.sending.gasPrice,
                    type: 'SEND',
                },
            ],
        });
        return step;
    }
    catch (e) {
        const htmlMessage = await (0, getTransactionMessage_js_1.getTransactionFailedMessage)(step, `${toChain.metamask.blockExplorerUrls[0]}tx/${transactionHash}`);
        statusManager.updateProcess(step, processType, 'FAILED', {
            error: {
                code: constants_js_1.LiFiErrorCode.TransactionFailed,
                message: 'Failed while waiting for status of destination chain transaction.',
                htmlMessage,
            },
        });
        statusManager.updateExecution(step, 'FAILED');
        throw e;
    }
}
//# sourceMappingURL=waitForDestinationChainTransaction.js.map