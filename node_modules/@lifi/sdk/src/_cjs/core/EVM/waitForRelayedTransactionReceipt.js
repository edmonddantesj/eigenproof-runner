"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForRelayedTransactionReceipt = void 0;
const constants_js_1 = require("../../errors/constants.js");
const errors_js_1 = require("../../errors/errors.js");
const api_js_1 = require("../../services/api.js");
const waitForResult_js_1 = require("../../utils/waitForResult.js");
const waitForRelayedTransactionReceipt = async (taskId, step) => {
    return (0, waitForResult_js_1.waitForResult)(async () => {
        const result = await (0, api_js_1.getRelayedTransactionStatus)({
            taskId,
            fromChain: step.action.fromChainId,
            toChain: step.action.toChainId,
            ...(step.tool !== 'custom' && { bridge: step.tool }),
        }).catch((e) => {
            if (process.env.NODE_ENV === 'development') {
                console.debug('Fetching status from relayer failed.', e);
            }
            return undefined;
        });
        switch (result?.status) {
            case 'PENDING':
                return undefined;
            case 'DONE': {
                const sending = result?.transactionStatus?.sending ||
                    result
                        ?.sending;
                return {
                    status: 'success',
                    gasUsed: sending?.gasUsed,
                    transactionHash: result?.metadata.txHash || sending?.txHash,
                    transactionLink: sending?.txLink,
                };
            }
            case 'FAILED':
                throw new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionFailed, 'Transaction was reverted.');
            default:
                throw new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionNotFound, 'Transaction not found.');
        }
    }, 5000, 3, (_, error) => {
        return !(error instanceof errors_js_1.TransactionError &&
            error.code === constants_js_1.LiFiErrorCode.TransactionFailed);
    });
};
exports.waitForRelayedTransactionReceipt = waitForRelayedTransactionReceipt;
//# sourceMappingURL=waitForRelayedTransactionReceipt.js.map