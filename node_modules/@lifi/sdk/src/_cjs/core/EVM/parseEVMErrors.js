"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAtomicReadyWalletRejectedUpgradeError = exports.parseEVMErrors = void 0;
const viem_1 = require("viem");
const baseError_js_1 = require("../../errors/baseError.js");
const constants_js_1 = require("../../errors/constants.js");
const errors_js_1 = require("../../errors/errors.js");
const SDKError_js_1 = require("../../errors/SDKError.js");
const fetchTxErrorDetails_js_1 = require("../../utils/fetchTxErrorDetails.js");
const parseEVMErrors = async (e, step, process) => {
    if (e instanceof SDKError_js_1.SDKError) {
        e.step = e.step ?? step;
        e.process = e.process ?? process;
        return e;
    }
    const baseError = await handleSpecificErrors(e, step, process);
    return new SDKError_js_1.SDKError(baseError, step, process);
};
exports.parseEVMErrors = parseEVMErrors;
const handleSpecificErrors = async (e, step, process) => {
    if (e.name === 'UserRejectedRequestError' ||
        e.cause?.name === 'UserRejectedRequestError' ||
        e.name === 'UnknownBundleIdError') {
        return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.SignatureRejected, e.message, e);
    }
    if (e.cause?.code === -32000 ||
        (e.name === 'TransactionExecutionError' &&
            e.cause?.details?.includes('rejected'))) {
        return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.SignatureRejected, e.message, e);
    }
    if (e.cause?.code === -32603) {
        return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionRejected, e.message, e);
    }
    if (e.name === 'InsufficientPrefundError' ||
        e.cause?.name === 'InsufficientPrefundError' ||
        e.cause?.cause?.name === 'InsufficientPrefundError') {
        return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.InsufficientGas, e.message, e);
    }
    if (step &&
        process?.txHash &&
        e.code === constants_js_1.LiFiErrorCode.TransactionFailed &&
        e.message === constants_js_1.ErrorMessage.TransactionReverted) {
        const response = await (0, fetchTxErrorDetails_js_1.fetchTxErrorDetails)(process.txHash, step.action.fromChainId);
        const errorMessage = response?.error_message;
        if (errorMessage?.toLowerCase().includes('out of gas')) {
            return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.GasLimitError, constants_js_1.ErrorMessage.GasLimitLow, e);
        }
    }
    if (e instanceof baseError_js_1.BaseError) {
        return e;
    }
    return new errors_js_1.UnknownError(e.message || constants_js_1.ErrorMessage.UnknownError, e);
};
const isAtomicReadyWalletRejectedUpgradeError = (e) => {
    if (e.cause?.code === viem_1.AtomicReadyWalletRejectedUpgradeError.code) {
        return true;
    }
    const details = e.cause?.details?.toLowerCase();
    const isTransactionError = e.name === 'TransactionExecutionError' ||
        e.cause?.name === 'TransactionExecutionError';
    const hasRejectedUpgrade = details?.includes('rejected') && details?.includes('upgrade');
    const has7702ErrorCode = details?.includes('7702');
    return isTransactionError && (hasRejectedUpgrade || has7702ErrorCode);
};
exports.isAtomicReadyWalletRejectedUpgradeError = isAtomicReadyWalletRejectedUpgradeError;
//# sourceMappingURL=parseEVMErrors.js.map