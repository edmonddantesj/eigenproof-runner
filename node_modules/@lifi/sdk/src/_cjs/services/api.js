"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchContractCalls = exports.getTransactionHistory = exports.getConnections = exports.getGasRecommendation = exports.getTools = exports.getToken = exports.getChains = exports.getRelayedTransactionStatus = exports.relayTransaction = exports.getRelayerQuote = exports.getStatus = exports.getStepTransaction = exports.getContractCallsQuote = exports.getRoutes = void 0;
exports.getQuote = getQuote;
exports.getTokens = getTokens;
const types_1 = require("@lifi/types");
const config_js_1 = require("../config.js");
const baseError_js_1 = require("../errors/baseError.js");
const constants_js_1 = require("../errors/constants.js");
const errors_js_1 = require("../errors/errors.js");
const SDKError_js_1 = require("../errors/SDKError.js");
const request_js_1 = require("../request.js");
const typeguards_js_1 = require("../typeguards.js");
const decode_js_1 = require("../utils/decode.js");
const withDedupe_js_1 = require("../utils/withDedupe.js");
async function getQuote(params, options) {
    const requiredParameters = [
        'fromChain',
        'fromToken',
        'fromAddress',
        'toChain',
        'toToken',
    ];
    for (const requiredParameter of requiredParameters) {
        if (!params[requiredParameter]) {
            throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError(`Required parameter "${requiredParameter}" is missing.`));
        }
    }
    const isFromAmountRequest = 'fromAmount' in params && params.fromAmount !== undefined;
    const isToAmountRequest = 'toAmount' in params && params.toAmount !== undefined;
    if (!isFromAmountRequest && !isToAmountRequest) {
        throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError('Required parameter "fromAmount" or "toAmount" is missing.'));
    }
    if (isFromAmountRequest && isToAmountRequest) {
        throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError('Cannot provide both "fromAmount" and "toAmount" parameters.'));
    }
    const _config = config_js_1.config.get();
    params.integrator ??= _config.integrator;
    params.order ??= _config.routeOptions?.order;
    params.slippage ??= _config.routeOptions?.slippage;
    params.referrer ??= _config.routeOptions?.referrer;
    params.fee ??= _config.routeOptions?.fee;
    params.allowBridges ??= _config.routeOptions?.bridges?.allow;
    params.denyBridges ??= _config.routeOptions?.bridges?.deny;
    params.preferBridges ??= _config.routeOptions?.bridges?.prefer;
    params.allowExchanges ??= _config.routeOptions?.exchanges?.allow;
    params.denyExchanges ??= _config.routeOptions?.exchanges?.deny;
    params.preferExchanges ??= _config.routeOptions?.exchanges?.prefer;
    for (const key of Object.keys(params)) {
        if (!params[key]) {
            delete params[key];
        }
    }
    return await (0, request_js_1.request)(`${_config.apiUrl}/${isFromAmountRequest ? 'quote' : 'quote/toAmount'}?${new URLSearchParams(params)}`, {
        signal: options?.signal,
    });
}
const getRoutes = async (params, options) => {
    if (!(0, typeguards_js_1.isRoutesRequest)(params)) {
        throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError('Invalid routes request.'));
    }
    const _config = config_js_1.config.get();
    params.options = {
        integrator: _config.integrator,
        ..._config.routeOptions,
        ...params.options,
    };
    return await (0, request_js_1.request)(`${_config.apiUrl}/advanced/routes`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(params),
        signal: options?.signal,
    });
};
exports.getRoutes = getRoutes;
const getContractCallsQuote = async (params, options) => {
    const requiredParameters = [
        'fromChain',
        'fromToken',
        'fromAddress',
        'toChain',
        'toToken',
        'contractCalls',
    ];
    for (const requiredParameter of requiredParameters) {
        if (!params[requiredParameter]) {
            throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError(`Required parameter "${requiredParameter}" is missing.`));
        }
    }
    if (!(0, types_1.isContractCallsRequestWithFromAmount)(params) &&
        !(0, types_1.isContractCallsRequestWithToAmount)(params)) {
        throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError(`Required parameter "fromAmount" or "toAmount" is missing.`));
    }
    const _config = config_js_1.config.get();
    params.integrator ??= _config.integrator;
    params.slippage ??= _config.routeOptions?.slippage;
    params.referrer ??= _config.routeOptions?.referrer;
    params.fee ??= _config.routeOptions?.fee;
    params.allowBridges ??= _config.routeOptions?.bridges?.allow;
    params.denyBridges ??= _config.routeOptions?.bridges?.deny;
    params.preferBridges ??= _config.routeOptions?.bridges?.prefer;
    params.allowExchanges ??= _config.routeOptions?.exchanges?.allow;
    params.denyExchanges ??= _config.routeOptions?.exchanges?.deny;
    params.preferExchanges ??= _config.routeOptions?.exchanges?.prefer;
    return await (0, request_js_1.request)(`${_config.apiUrl}/quote/contractCalls`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(params),
        signal: options?.signal,
    });
};
exports.getContractCallsQuote = getContractCallsQuote;
const getStepTransaction = async (step, options) => {
    if (!(0, typeguards_js_1.isStep)(step)) {
        console.warn('SDK Validation: Invalid Step', step);
    }
    const _config = config_js_1.config.get();
    let requestUrl = `${_config.apiUrl}/advanced/stepTransaction`;
    const isJitoBundleEnabled = Boolean(_config.routeOptions?.jitoBundle);
    if (isJitoBundleEnabled && step.action.fromChainId === types_1.ChainId.SOL) {
        const queryParams = new URLSearchParams({ jitoBundle: 'true' });
        requestUrl = `${requestUrl}?${queryParams}`;
    }
    return await (0, request_js_1.request)(requestUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(step),
        signal: options?.signal,
    });
};
exports.getStepTransaction = getStepTransaction;
const getStatus = async (params, options) => {
    if (!('taskId' in params && params.taskId) &&
        !('txHash' in params && params.txHash)) {
        throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError('Either "taskId" or "txHash" must be provided and non-empty.'));
    }
    const queryParams = new URLSearchParams(params);
    return await (0, request_js_1.request)(`${config_js_1.config.get().apiUrl}/status?${queryParams}`, {
        signal: options?.signal,
    });
};
exports.getStatus = getStatus;
const getRelayerQuote = async (params, options) => {
    const requiredParameters = [
        'fromChain',
        'fromToken',
        'fromAddress',
        'fromAmount',
        'toChain',
        'toToken',
    ];
    for (const requiredParameter of requiredParameters) {
        if (!params[requiredParameter]) {
            throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError(`Required parameter "${requiredParameter}" is missing.`));
        }
    }
    const _config = config_js_1.config.get();
    params.integrator ??= _config.integrator;
    params.order ??= _config.routeOptions?.order;
    params.slippage ??= _config.routeOptions?.slippage;
    params.referrer ??= _config.routeOptions?.referrer;
    params.fee ??= _config.routeOptions?.fee;
    params.allowBridges ??= _config.routeOptions?.bridges?.allow;
    params.denyBridges ??= _config.routeOptions?.bridges?.deny;
    params.preferBridges ??= _config.routeOptions?.bridges?.prefer;
    params.allowExchanges ??= _config.routeOptions?.exchanges?.allow;
    params.denyExchanges ??= _config.routeOptions?.exchanges?.deny;
    params.preferExchanges ??= _config.routeOptions?.exchanges?.prefer;
    for (const key of Object.keys(params)) {
        if (!params[key]) {
            delete params[key];
        }
    }
    const result = await (0, request_js_1.request)(`${config_js_1.config.get().apiUrl}/relayer/quote?${new URLSearchParams(params)}`, {
        signal: options?.signal,
    });
    if (result.status === 'error') {
        throw new baseError_js_1.BaseError(constants_js_1.ErrorName.ServerError, result.data.code, result.data.message);
    }
    return result.data;
};
exports.getRelayerQuote = getRelayerQuote;
const relayTransaction = async (params, options) => {
    const requiredParameters = ['typedData'];
    for (const requiredParameter of requiredParameters) {
        if (!params[requiredParameter]) {
            throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError(`Required parameter "${requiredParameter}" is missing.`));
        }
    }
    const relayerPath = params.typedData.some((t) => t.primaryType === 'PermitWitnessTransferFrom')
        ? '/relayer/relay'
        : '/advanced/relay';
    const result = await (0, request_js_1.request)(`${config_js_1.config.get().apiUrl}${relayerPath}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(params, (_, value) => {
            if (typeof value === 'bigint') {
                return value.toString();
            }
            return value;
        }),
        signal: options?.signal,
    });
    if (result.status === 'error') {
        throw new baseError_js_1.BaseError(constants_js_1.ErrorName.ServerError, result.data.code, result.data.message);
    }
    return result.data;
};
exports.relayTransaction = relayTransaction;
const getRelayedTransactionStatus = async (params, options) => {
    if (!params.taskId) {
        throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError('Required parameter "taskId" is missing.'));
    }
    const { taskId, ...otherParams } = params;
    const queryParams = new URLSearchParams(otherParams);
    const decodedTaskId = (0, decode_js_1.decodeTaskId)(taskId);
    if (decodedTaskId.length === 3) {
        return (await (0, exports.getStatus)(params, options));
    }
    const result = await (0, request_js_1.request)(`${config_js_1.config.get().apiUrl}/relayer/status/${taskId}?${queryParams}`, {
        signal: options?.signal,
    });
    if (result.status === 'error') {
        throw new baseError_js_1.BaseError(constants_js_1.ErrorName.ServerError, result.data.code, result.data.message);
    }
    return result.data;
};
exports.getRelayedTransactionStatus = getRelayedTransactionStatus;
const getChains = async (params, options) => {
    if (params) {
        for (const key of Object.keys(params)) {
            if (!params[key]) {
                delete params[key];
            }
        }
    }
    const urlSearchParams = new URLSearchParams(params).toString();
    const response = await (0, withDedupe_js_1.withDedupe)(() => (0, request_js_1.request)(`${config_js_1.config.get().apiUrl}/chains?${urlSearchParams}`, {
        signal: options?.signal,
    }), { id: `${exports.getChains.name}.${urlSearchParams}` });
    return response.chains;
};
exports.getChains = getChains;
async function getTokens(params, options) {
    if (params) {
        for (const key of Object.keys(params)) {
            if (!params[key]) {
                delete params[key];
            }
        }
    }
    const urlSearchParams = new URLSearchParams(params).toString();
    const isExtended = params?.extended === true;
    const response = await (0, withDedupe_js_1.withDedupe)(() => (0, request_js_1.request)(`${config_js_1.config.get().apiUrl}/tokens?${urlSearchParams}`, {
        signal: options?.signal,
    }), { id: `${getTokens.name}.${urlSearchParams}` });
    return response;
}
const getToken = async (chain, token, options) => {
    if (!chain) {
        throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError('Required parameter "chain" is missing.'));
    }
    if (!token) {
        throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError('Required parameter "token" is missing.'));
    }
    return await (0, request_js_1.request)(`${config_js_1.config.get().apiUrl}/token?${new URLSearchParams({
        chain,
        token,
    })}`, {
        signal: options?.signal,
    });
};
exports.getToken = getToken;
const getTools = async (params, options) => {
    if (params) {
        for (const key of Object.keys(params)) {
            if (!params[key]) {
                delete params[key];
            }
        }
    }
    return await (0, request_js_1.request)(`${config_js_1.config.get().apiUrl}/tools?${new URLSearchParams(params)}`, {
        signal: options?.signal,
    });
};
exports.getTools = getTools;
const getGasRecommendation = async (params, options) => {
    if (!params.chainId) {
        throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError('Required parameter "chainId" is missing.'));
    }
    const url = new URL(`${config_js_1.config.get().apiUrl}/gas/suggestion/${params.chainId}`);
    if (params.fromChain) {
        url.searchParams.append('fromChain', params.fromChain);
    }
    if (params.fromToken) {
        url.searchParams.append('fromToken', params.fromToken);
    }
    return await (0, request_js_1.request)(url.toString(), {
        signal: options?.signal,
    });
};
exports.getGasRecommendation = getGasRecommendation;
const getConnections = async (connectionRequest, options) => {
    const url = new URL(`${config_js_1.config.get().apiUrl}/connections`);
    const { fromChain, fromToken, toChain, toToken } = connectionRequest;
    if (fromChain) {
        url.searchParams.append('fromChain', fromChain);
    }
    if (fromToken) {
        url.searchParams.append('fromToken', fromToken);
    }
    if (toChain) {
        url.searchParams.append('toChain', toChain);
    }
    if (toToken) {
        url.searchParams.append('toToken', toToken);
    }
    const connectionRequestArrayParams = [
        'allowBridges',
        'denyBridges',
        'preferBridges',
        'allowExchanges',
        'denyExchanges',
        'preferExchanges',
    ];
    for (const parameter of connectionRequestArrayParams) {
        const connectionRequestArrayParam = connectionRequest[parameter];
        if (connectionRequestArrayParam?.length) {
            for (const value of connectionRequestArrayParam) {
                url.searchParams.append(parameter, value);
            }
        }
    }
    return await (0, request_js_1.request)(url, options);
};
exports.getConnections = getConnections;
const getTransactionHistory = async ({ wallet, status, fromTimestamp, toTimestamp }, options) => {
    if (!wallet) {
        throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError('Required parameter "wallet" is missing.'));
    }
    const _config = config_js_1.config.get();
    const url = new URL(`${_config.apiUrl}/analytics/transfers`);
    url.searchParams.append('integrator', _config.integrator);
    url.searchParams.append('wallet', wallet);
    if (status) {
        url.searchParams.append('status', status);
    }
    if (fromTimestamp) {
        url.searchParams.append('fromTimestamp', fromTimestamp.toString());
    }
    if (toTimestamp) {
        url.searchParams.append('toTimestamp', toTimestamp.toString());
    }
    return await (0, request_js_1.request)(url, options);
};
exports.getTransactionHistory = getTransactionHistory;
const patchContractCalls = async (params, options) => {
    return await (0, request_js_1.request)(`${config_js_1.config.get().apiUrl}/patcher`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(params),
        signal: options?.signal,
    });
};
exports.patchContractCalls = patchContractCalls;
//# sourceMappingURL=api.js.map