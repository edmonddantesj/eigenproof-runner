"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertQuoteToRoute = void 0;
exports.formatTokenPrice = formatTokenPrice;
const viem_1 = require("viem");
const errors_js_1 = require("../errors/errors.js");
const SDKError_js_1 = require("../errors/SDKError.js");
const parseBigInt = (value) => {
    if (!value) {
        return 0n;
    }
    try {
        return BigInt(value);
    }
    catch {
        return 0n;
    }
};
const parseNumber = (value) => {
    if (!value) {
        return 0;
    }
    const parsed = Number(value);
    return Number.isNaN(parsed) ? 0 : parsed;
};
const isZeroOutput = (toAmount, toAmountMin, toAmountUSD) => {
    return (!parseBigInt(toAmount) &&
        !parseBigInt(toAmountMin) &&
        !parseNumber(toAmountUSD));
};
const hasNonZeroOutput = (step) => {
    return (!!parseBigInt(step.estimate.toAmount) ||
        !!parseBigInt(step.estimate.toAmountMin));
};
const findPreviousNonZeroStep = (steps) => {
    for (let i = steps.length - 1; i >= 0; i--) {
        const step = steps[i];
        if (hasNonZeroOutput(step)) {
            return step;
        }
    }
    return undefined;
};
function formatTokenPrice(amount, price, decimals) {
    if (!amount || !price) {
        return 0;
    }
    const formattedAmount = typeof amount === 'bigint' && decimals !== undefined
        ? (0, viem_1.formatUnits)(amount, decimals)
        : amount.toString();
    if (Number.isNaN(Number(formattedAmount)) || Number.isNaN(Number(price))) {
        return 0;
    }
    return Number.parseFloat(formattedAmount) * Number.parseFloat(price);
}
const convertQuoteToRoute = (quote, options) => {
    let toAmount = quote.estimate.toAmount;
    let toAmountMin = quote.estimate.toAmountMin;
    let toAmountUSD = quote.estimate.toAmountUSD;
    if (options?.adjustZeroOutputFromPreviousStep &&
        quote.includedSteps?.length &&
        isZeroOutput(toAmount, toAmountMin, toAmountUSD)) {
        const previousStep = findPreviousNonZeroStep(quote.includedSteps);
        if (previousStep) {
            toAmount = previousStep.estimate.toAmount;
            toAmountMin = previousStep.estimate.toAmountMin;
            toAmountUSD = formatTokenPrice(parseBigInt(toAmount), previousStep.action.toToken.priceUSD, previousStep.action.toToken.decimals).toFixed(2);
            const lastStep = quote.includedSteps[quote.includedSteps.length - 1];
            if (lastStep && !hasNonZeroOutput(lastStep)) {
                lastStep.estimate.toAmount = toAmount;
                lastStep.estimate.toAmountMin = toAmountMin;
            }
        }
    }
    if (!quote.estimate.fromAmountUSD) {
        throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError("Missing 'fromAmountUSD' in step estimate."));
    }
    if (!toAmountUSD) {
        throw new SDKError_js_1.SDKError(new errors_js_1.ValidationError("Missing 'toAmountUSD' in step estimate."));
    }
    const route = {
        id: quote.id,
        fromChainId: quote.action.fromToken.chainId,
        fromToken: quote.action.fromToken,
        fromAmount: quote.action.fromAmount,
        fromAmountUSD: quote.estimate.fromAmountUSD,
        fromAddress: quote.action.fromAddress,
        toChainId: quote.action.toToken.chainId,
        toToken: quote.action.toToken,
        toAmount,
        toAmountMin,
        toAmountUSD,
        toAddress: quote.action.toAddress || quote.action.fromAddress,
        gasCostUSD: quote.estimate.gasCosts?.[0]?.amountUSD || '0',
        steps: [quote],
        insurance: { state: 'NOT_INSURABLE', feeAmountUsd: '0' },
    };
    return route;
};
exports.convertQuoteToRoute = convertQuoteToRoute;
//# sourceMappingURL=convertQuoteToRoute.js.map