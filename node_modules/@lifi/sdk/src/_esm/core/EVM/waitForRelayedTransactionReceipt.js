import { LiFiErrorCode } from '../../errors/constants.js';
import { TransactionError } from '../../errors/errors.js';
import { getRelayedTransactionStatus } from '../../services/api.js';
import { waitForResult } from '../../utils/waitForResult.js';
export const waitForRelayedTransactionReceipt = async (taskId, step) => {
    return waitForResult(async () => {
        const result = await getRelayedTransactionStatus({
            taskId,
            fromChain: step.action.fromChainId,
            toChain: step.action.toChainId,
            ...(step.tool !== 'custom' && { bridge: step.tool }),
        }).catch((e) => {
            if (process.env.NODE_ENV === 'development') {
                console.debug('Fetching status from relayer failed.', e);
            }
            return undefined;
        });
        switch (result?.status) {
            case 'PENDING':
                return undefined;
            case 'DONE': {
                const sending = result?.transactionStatus?.sending ||
                    result
                        ?.sending;
                return {
                    status: 'success',
                    gasUsed: sending?.gasUsed,
                    transactionHash: result?.metadata.txHash || sending?.txHash,
                    transactionLink: sending?.txLink,
                };
            }
            case 'FAILED':
                throw new TransactionError(LiFiErrorCode.TransactionFailed, 'Transaction was reverted.');
            default:
                throw new TransactionError(LiFiErrorCode.TransactionNotFound, 'Transaction not found.');
        }
    }, 5000, 3, (_, error) => {
        return !(error instanceof TransactionError &&
            error.code === LiFiErrorCode.TransactionFailed);
    });
};
//# sourceMappingURL=waitForRelayedTransactionReceipt.js.map